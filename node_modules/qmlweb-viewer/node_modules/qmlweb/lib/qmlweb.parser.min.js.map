{"version":3,"sources":["qmlweb.parser.min.js","/source/parse-js.js","/source/api.js"],"names":["exports","is_letter","ch","UNICODE","letter","test","is_digit","charCodeAt","is_unicode_digit","digit","is_alphanumeric_char","is_unicode_combining_mark","combining_mark","is_unicode_connector_punctuation","connector_punctuation","is_identifier_start","is_identifier_char","parse_js_number","num","RE_HEX_NUMBER","parseInt","substr","RE_OCT_NUMBER","RE_DEC_NUMBER","parseFloat","JS_Parse_Error","message","line","col","pos","this","stack","Error","js_error","is_token","token","type","val","value","tokenizer","$TEXT","peek","S","text","charAt","next","signal_eof","in_string","EX_EOF","newline_before","find","what","indexOf","start_token","tokline","tokcol","tokpos","is_comment","regex_allowed","HOP","UNARY_POSTFIX","KEYWORDS_BEFORE_EXPRESSION","PUNC_BEFORE_EXPRESSION","ret","endpos","nlb","comments_before","i","len","length","skip_whitespace","WHITESPACE_CHARS","read_while","pred","parse_error","err","read_num","prefix","has_e","after_e","has_x","has_dot","valid","isNaN","read_escaped_char","String","fromCharCode","hex_bytes","n","read_string","with_eof_error","quote","octal_len","first","read_line_comment","substring","read_multiline_comment","split","warn","read_name","hex","backslash","name","escaped","KEYWORDS","toString","toUpperCase","slice","read_regexp","regexp","prev_backslash","in_class","mods","read_operator","grow","op","bigger","OPERATORS","handle_slash","push","next_token","handle_dot","read_word","word","KEYWORDS_ATOM","eof_error","cont","ex","force_regexp","PUNC_CHARS","OPERATOR_CHARS","replace","context","nc","NodeWithToken","str","start","end","parse","exigent_mode","embed_tokens","is","peeked","input","prev","in_directives","croak","msg","ctx","token_error","unexpected","expect_token","expect","punc","can_insert_semicolon","semicolon","as","arguments","parenthesised","expression","add_tokens","maybe_embed_tokens","parser","ast","apply","labeled_statement","label","labels","stat","statement","STATEMENTS_WITH_LABELS","pop","simple_statement","prog1","break_cont","member","in_loop","for_","init","var_","for_in","regular_for","step","lhs","obj","if_","belse","cond","body","block_","a","try_","bcatch","bfinally","vardefs","no_in","const_","new_","args","newexp","expr_atom","expr_list","subscripts","closing","allow_trailing_comma","allow_empty","array_","object_","as_property_name","as_name","function_","expr","allow_calls","curry","maybe_unary","UNARY_PREFIX","make_unary","tag","is_assignable","expr_op","left","min_prec","prec","PRECEDENCE","right","expr_ops","maybe_conditional","yes","maybe_assign","ASSIGNMENT","in_function","dir","switch_block_","in_statement","loop","cur","ATOMIC_START_TOKEN","atom","commas","f","concat","Function","array_to_hash","Array","prototype","call","characters","array","prop","Object","hasOwnProperty","clone","temp","key","QMLParseError","source","comment","extractLinesForErrorDiag","file","qmlweb_parse","nowParsingFile","r","lines","mark","qmlweb_tokenizer","document_type","as_statement","res","TEXT","maybe_qmlelem","undefined","qmlblock","qml_is_element","qmlstatement","qmlpropdef","objName","propName","in_qmlpropdef","qmldefaultprop","qmlsignaldef","from","to","propname","onProp","subname","todo","qml_pragma_statement","pragma","qmlimport","moduleName","isDottedNotation","version","namespace","qmldocument","imports","root","jsdocument","statements","amIn","s","console","log","statement_js","JSResource","qmlweb_jsparse","AST_Tree","main_scope","item","RESERVED_WORDS","RegExp","=","b","j","set_logger","logger","QMLDocument","window"],"mappings":"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","file":"qmlweb.parser.min.js","sourcesContent":[";(function(exports) {\n/* This bundle consists of two parts: UglifyJS and QmlWeb parser additions\n * on top of it. Those parts have different copyrights, but are both licensed\n * under BSD-2-Clause license (text follows). Each part has a separate header.\n */\n\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n\n  This version is suitable for Node.js.  With minimal changes (the\n  exports stuff) it should work on any JS platform.\n\n  This file contains the tokenizer/parser.  It is a port to JavaScript\n  of parse-js [1], a JavaScript parser library written in Common Lisp\n  by Marijn Haverbeke.  Thank you Marijn!\n\n  [1] http://marijn.haverbeke.nl/parse-js/\n\n  Exported functions:\n\n    - tokenizer(code) -- returns a function.  Call the returned\n      function to fetch the next token.\n\n    - parse(code) -- returns an AST of the given JavaScript code.\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>\n    Based on parse-js (http://marijn.haverbeke.nl/parse-js/).\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n/* -----[ Tokenizer (constants) ]----- */\n\nvar KEYWORDS = array_to_hash([\n    \"break\",\n    \"case\",\n    \"catch\",\n    \"const\",\n    \"continue\",\n    \"debugger\",\n    \"default\",\n    \"delete\",\n    \"do\",\n    \"else\",\n    \"finally\",\n    \"for\",\n    \"function\",\n    \"if\",\n    \"in\",\n    \"instanceof\",\n    \"new\",\n    \"return\",\n    \"switch\",\n    \"throw\",\n    \"try\",\n    \"typeof\",\n    \"var\",\n    \"void\",\n    \"while\",\n    \"with\"\n]);\n\nvar RESERVED_WORDS = array_to_hash([\n    \"abstract\",\n    \"boolean\",\n    \"byte\",\n    \"char\",\n    \"class\",\n    \"double\",\n    \"enum\",\n    \"export\",\n    \"extends\",\n    \"final\",\n    \"float\",\n    \"goto\",\n    \"implements\",\n    \"import\",\n    \"int\",\n    \"interface\",\n    \"long\",\n    \"native\",\n    \"package\",\n    \"private\",\n    \"protected\",\n    \"public\",\n    \"short\",\n    \"static\",\n    \"super\",\n    \"synchronized\",\n    \"throws\",\n    \"transient\",\n    \"volatile\"\n]);\n\nvar KEYWORDS_BEFORE_EXPRESSION = array_to_hash([\n    \"return\",\n    \"new\",\n    \"delete\",\n    \"throw\",\n    \"else\",\n    \"case\"\n]);\n\nvar KEYWORDS_ATOM = array_to_hash([\n    \"false\",\n    \"null\",\n    \"true\",\n    \"undefined\"\n]);\n\nvar OPERATOR_CHARS = array_to_hash(characters(\"+-*&%=<>!?|~^\"));\n\nvar RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;\nvar RE_OCT_NUMBER = /^0[0-7]+$/;\nvar RE_DEC_NUMBER = /^\\d*\\.?\\d*(?:e[+-]?\\d*(?:\\d\\.?|\\.?\\d)\\d*)?$/i;\n\nvar OPERATORS = array_to_hash([\n    \"in\",\n    \"instanceof\",\n    \"typeof\",\n    \"new\",\n    \"void\",\n    \"delete\",\n    \"++\",\n    \"--\",\n    \"+\",\n    \"-\",\n    \"!\",\n    \"~\",\n    \"&\",\n    \"|\",\n    \"^\",\n    \"*\",\n    \"/\",\n    \"%\",\n    \">>\",\n    \"<<\",\n    \">>>\",\n    \"<\",\n    \">\",\n    \"<=\",\n    \">=\",\n    \"==\",\n    \"===\",\n    \"!=\",\n    \"!==\",\n    \"?\",\n    \"=\",\n    \"+=\",\n    \"-=\",\n    \"/=\",\n    \"*=\",\n    \"%=\",\n    \">>=\",\n    \"<<=\",\n    \">>>=\",\n    \"|=\",\n    \"^=\",\n    \"&=\",\n    \"&&\",\n    \"||\"\n]);\n\nvar WHITESPACE_CHARS = array_to_hash(characters(\" \\u00a0\\n\\r\\t\\f\\u000b\\u200b\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\uFEFF\"));\n\nvar PUNC_BEFORE_EXPRESSION = array_to_hash(characters(\"[{(,.;:\"));\n\nvar PUNC_CHARS = array_to_hash(characters(\"[]{}(),;:\"));\n\nvar REGEXP_MODIFIERS = array_to_hash(characters(\"gmsiy\"));\n\n/* -----[ Tokenizer ]----- */\n\nvar UNICODE = {  // Unicode 6.1\n    letter: new RegExp(\"[\\\\u0041-\\\\u005A\\\\u0061-\\\\u007A\\\\u00AA\\\\u00B5\\\\u00BA\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037A-\\\\u037D\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03F5\\\\u03F7-\\\\u0481\\\\u048A-\\\\u0527\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0620-\\\\u064A\\\\u066E\\\\u066F\\\\u0671-\\\\u06D3\\\\u06D5\\\\u06E5\\\\u06E6\\\\u06EE\\\\u06EF\\\\u06FA-\\\\u06FC\\\\u06FF\\\\u0710\\\\u0712-\\\\u072F\\\\u074D-\\\\u07A5\\\\u07B1\\\\u07CA-\\\\u07EA\\\\u07F4\\\\u07F5\\\\u07FA\\\\u0800-\\\\u0815\\\\u081A\\\\u0824\\\\u0828\\\\u0840-\\\\u0858\\\\u08A0\\\\u08A2-\\\\u08AC\\\\u0904-\\\\u0939\\\\u093D\\\\u0950\\\\u0958-\\\\u0961\\\\u0971-\\\\u0977\\\\u0979-\\\\u097F\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09BD\\\\u09CE\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0\\\\u09F1\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AD0\\\\u0AE0\\\\u0AE1\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B35-\\\\u0B39\\\\u0B3D\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B71\\\\u0B83\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB9\\\\u0BD0\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C33\\\\u0C35-\\\\u0C39\\\\u0C3D\\\\u0C58\\\\u0C59\\\\u0C60\\\\u0C61\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CBD\\\\u0CDE\\\\u0CE0\\\\u0CE1\\\\u0CF1\\\\u0CF2\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D3A\\\\u0D3D\\\\u0D4E\\\\u0D60\\\\u0D61\\\\u0D7A-\\\\u0D7F\\\\u0D85-\\\\u0D96\\\\u0D9A-\\\\u0DB1\\\\u0DB3-\\\\u0DBB\\\\u0DBD\\\\u0DC0-\\\\u0DC6\\\\u0E01-\\\\u0E30\\\\u0E32\\\\u0E33\\\\u0E40-\\\\u0E46\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD-\\\\u0EB0\\\\u0EB2\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0EC6\\\\u0EDC-\\\\u0EDF\\\\u0F00\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F6C\\\\u0F88-\\\\u0F8C\\\\u1000-\\\\u102A\\\\u103F\\\\u1050-\\\\u1055\\\\u105A-\\\\u105D\\\\u1061\\\\u1065\\\\u1066\\\\u106E-\\\\u1070\\\\u1075-\\\\u1081\\\\u108E\\\\u10A0-\\\\u10C5\\\\u10C7\\\\u10CD\\\\u10D0-\\\\u10FA\\\\u10FC-\\\\u1248\\\\u124A-\\\\u124D\\\\u1250-\\\\u1256\\\\u1258\\\\u125A-\\\\u125D\\\\u1260-\\\\u1288\\\\u128A-\\\\u128D\\\\u1290-\\\\u12B0\\\\u12B2-\\\\u12B5\\\\u12B8-\\\\u12BE\\\\u12C0\\\\u12C2-\\\\u12C5\\\\u12C8-\\\\u12D6\\\\u12D8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135A\\\\u1380-\\\\u138F\\\\u13A0-\\\\u13F4\\\\u1401-\\\\u166C\\\\u166F-\\\\u167F\\\\u1681-\\\\u169A\\\\u16A0-\\\\u16EA\\\\u16EE-\\\\u16F0\\\\u1700-\\\\u170C\\\\u170E-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176C\\\\u176E-\\\\u1770\\\\u1780-\\\\u17B3\\\\u17D7\\\\u17DC\\\\u1820-\\\\u1877\\\\u1880-\\\\u18A8\\\\u18AA\\\\u18B0-\\\\u18F5\\\\u1900-\\\\u191C\\\\u1950-\\\\u196D\\\\u1970-\\\\u1974\\\\u1980-\\\\u19AB\\\\u19C1-\\\\u19C7\\\\u1A00-\\\\u1A16\\\\u1A20-\\\\u1A54\\\\u1AA7\\\\u1B05-\\\\u1B33\\\\u1B45-\\\\u1B4B\\\\u1B83-\\\\u1BA0\\\\u1BAE\\\\u1BAF\\\\u1BBA-\\\\u1BE5\\\\u1C00-\\\\u1C23\\\\u1C4D-\\\\u1C4F\\\\u1C5A-\\\\u1C7D\\\\u1CE9-\\\\u1CEC\\\\u1CEE-\\\\u1CF1\\\\u1CF5\\\\u1CF6\\\\u1D00-\\\\u1DBF\\\\u1E00-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u2071\\\\u207F\\\\u2090-\\\\u209C\\\\u2102\\\\u2107\\\\u210A-\\\\u2113\\\\u2115\\\\u2119-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u212D\\\\u212F-\\\\u2139\\\\u213C-\\\\u213F\\\\u2145-\\\\u2149\\\\u214E\\\\u2160-\\\\u2188\\\\u2C00-\\\\u2C2E\\\\u2C30-\\\\u2C5E\\\\u2C60-\\\\u2CE4\\\\u2CEB-\\\\u2CEE\\\\u2CF2\\\\u2CF3\\\\u2D00-\\\\u2D25\\\\u2D27\\\\u2D2D\\\\u2D30-\\\\u2D67\\\\u2D6F\\\\u2D80-\\\\u2D96\\\\u2DA0-\\\\u2DA6\\\\u2DA8-\\\\u2DAE\\\\u2DB0-\\\\u2DB6\\\\u2DB8-\\\\u2DBE\\\\u2DC0-\\\\u2DC6\\\\u2DC8-\\\\u2DCE\\\\u2DD0-\\\\u2DD6\\\\u2DD8-\\\\u2DDE\\\\u2E2F\\\\u3005-\\\\u3007\\\\u3021-\\\\u3029\\\\u3031-\\\\u3035\\\\u3038-\\\\u303C\\\\u3041-\\\\u3096\\\\u309D-\\\\u309F\\\\u30A1-\\\\u30FA\\\\u30FC-\\\\u30FF\\\\u3105-\\\\u312D\\\\u3131-\\\\u318E\\\\u31A0-\\\\u31BA\\\\u31F0-\\\\u31FF\\\\u3400-\\\\u4DB5\\\\u4E00-\\\\u9FCC\\\\uA000-\\\\uA48C\\\\uA4D0-\\\\uA4FD\\\\uA500-\\\\uA60C\\\\uA610-\\\\uA61F\\\\uA62A\\\\uA62B\\\\uA640-\\\\uA66E\\\\uA67F-\\\\uA697\\\\uA6A0-\\\\uA6EF\\\\uA717-\\\\uA71F\\\\uA722-\\\\uA788\\\\uA78B-\\\\uA78E\\\\uA790-\\\\uA793\\\\uA7A0-\\\\uA7AA\\\\uA7F8-\\\\uA801\\\\uA803-\\\\uA805\\\\uA807-\\\\uA80A\\\\uA80C-\\\\uA822\\\\uA840-\\\\uA873\\\\uA882-\\\\uA8B3\\\\uA8F2-\\\\uA8F7\\\\uA8FB\\\\uA90A-\\\\uA925\\\\uA930-\\\\uA946\\\\uA960-\\\\uA97C\\\\uA984-\\\\uA9B2\\\\uA9CF\\\\uAA00-\\\\uAA28\\\\uAA40-\\\\uAA42\\\\uAA44-\\\\uAA4B\\\\uAA60-\\\\uAA76\\\\uAA7A\\\\uAA80-\\\\uAAAF\\\\uAAB1\\\\uAAB5\\\\uAAB6\\\\uAAB9-\\\\uAABD\\\\uAAC0\\\\uAAC2\\\\uAADB-\\\\uAADD\\\\uAAE0-\\\\uAAEA\\\\uAAF2-\\\\uAAF4\\\\uAB01-\\\\uAB06\\\\uAB09-\\\\uAB0E\\\\uAB11-\\\\uAB16\\\\uAB20-\\\\uAB26\\\\uAB28-\\\\uAB2E\\\\uABC0-\\\\uABE2\\\\uAC00-\\\\uD7A3\\\\uD7B0-\\\\uD7C6\\\\uD7CB-\\\\uD7FB\\\\uF900-\\\\uFA6D\\\\uFA70-\\\\uFAD9\\\\uFB00-\\\\uFB06\\\\uFB13-\\\\uFB17\\\\uFB1D\\\\uFB1F-\\\\uFB28\\\\uFB2A-\\\\uFB36\\\\uFB38-\\\\uFB3C\\\\uFB3E\\\\uFB40\\\\uFB41\\\\uFB43\\\\uFB44\\\\uFB46-\\\\uFBB1\\\\uFBD3-\\\\uFD3D\\\\uFD50-\\\\uFD8F\\\\uFD92-\\\\uFDC7\\\\uFDF0-\\\\uFDFB\\\\uFE70-\\\\uFE74\\\\uFE76-\\\\uFEFC\\\\uFF21-\\\\uFF3A\\\\uFF41-\\\\uFF5A\\\\uFF66-\\\\uFFBE\\\\uFFC2-\\\\uFFC7\\\\uFFCA-\\\\uFFCF\\\\uFFD2-\\\\uFFD7\\\\uFFDA-\\\\uFFDC]\"),\n    combining_mark: new RegExp(\"[\\\\u0300-\\\\u036F\\\\u0483-\\\\u0487\\\\u0591-\\\\u05BD\\\\u05BF\\\\u05C1\\\\u05C2\\\\u05C4\\\\u05C5\\\\u05C7\\\\u0610-\\\\u061A\\\\u064B-\\\\u065F\\\\u0670\\\\u06D6-\\\\u06DC\\\\u06DF-\\\\u06E4\\\\u06E7\\\\u06E8\\\\u06EA-\\\\u06ED\\\\u0711\\\\u0730-\\\\u074A\\\\u07A6-\\\\u07B0\\\\u07EB-\\\\u07F3\\\\u0816-\\\\u0819\\\\u081B-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082D\\\\u0859-\\\\u085B\\\\u08E4-\\\\u08FE\\\\u0900-\\\\u0903\\\\u093A-\\\\u093C\\\\u093E-\\\\u094F\\\\u0951-\\\\u0957\\\\u0962\\\\u0963\\\\u0981-\\\\u0983\\\\u09BC\\\\u09BE-\\\\u09C4\\\\u09C7\\\\u09C8\\\\u09CB-\\\\u09CD\\\\u09D7\\\\u09E2\\\\u09E3\\\\u0A01-\\\\u0A03\\\\u0A3C\\\\u0A3E-\\\\u0A42\\\\u0A47\\\\u0A48\\\\u0A4B-\\\\u0A4D\\\\u0A51\\\\u0A70\\\\u0A71\\\\u0A75\\\\u0A81-\\\\u0A83\\\\u0ABC\\\\u0ABE-\\\\u0AC5\\\\u0AC7-\\\\u0AC9\\\\u0ACB-\\\\u0ACD\\\\u0AE2\\\\u0AE3\\\\u0B01-\\\\u0B03\\\\u0B3C\\\\u0B3E-\\\\u0B44\\\\u0B47\\\\u0B48\\\\u0B4B-\\\\u0B4D\\\\u0B56\\\\u0B57\\\\u0B62\\\\u0B63\\\\u0B82\\\\u0BBE-\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCD\\\\u0BD7\\\\u0C01-\\\\u0C03\\\\u0C3E-\\\\u0C44\\\\u0C46-\\\\u0C48\\\\u0C4A-\\\\u0C4D\\\\u0C55\\\\u0C56\\\\u0C62\\\\u0C63\\\\u0C82\\\\u0C83\\\\u0CBC\\\\u0CBE-\\\\u0CC4\\\\u0CC6-\\\\u0CC8\\\\u0CCA-\\\\u0CCD\\\\u0CD5\\\\u0CD6\\\\u0CE2\\\\u0CE3\\\\u0D02\\\\u0D03\\\\u0D3E-\\\\u0D44\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4D\\\\u0D57\\\\u0D62\\\\u0D63\\\\u0D82\\\\u0D83\\\\u0DCA\\\\u0DCF-\\\\u0DD4\\\\u0DD6\\\\u0DD8-\\\\u0DDF\\\\u0DF2\\\\u0DF3\\\\u0E31\\\\u0E34-\\\\u0E3A\\\\u0E47-\\\\u0E4E\\\\u0EB1\\\\u0EB4-\\\\u0EB9\\\\u0EBB\\\\u0EBC\\\\u0EC8-\\\\u0ECD\\\\u0F18\\\\u0F19\\\\u0F35\\\\u0F37\\\\u0F39\\\\u0F3E\\\\u0F3F\\\\u0F71-\\\\u0F84\\\\u0F86\\\\u0F87\\\\u0F8D-\\\\u0F97\\\\u0F99-\\\\u0FBC\\\\u0FC6\\\\u102B-\\\\u103E\\\\u1056-\\\\u1059\\\\u105E-\\\\u1060\\\\u1062-\\\\u1064\\\\u1067-\\\\u106D\\\\u1071-\\\\u1074\\\\u1082-\\\\u108D\\\\u108F\\\\u109A-\\\\u109D\\\\u135D-\\\\u135F\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17B4-\\\\u17D3\\\\u17DD\\\\u180B-\\\\u180D\\\\u18A9\\\\u1920-\\\\u192B\\\\u1930-\\\\u193B\\\\u19B0-\\\\u19C0\\\\u19C8\\\\u19C9\\\\u1A17-\\\\u1A1B\\\\u1A55-\\\\u1A5E\\\\u1A60-\\\\u1A7C\\\\u1A7F\\\\u1B00-\\\\u1B04\\\\u1B34-\\\\u1B44\\\\u1B6B-\\\\u1B73\\\\u1B80-\\\\u1B82\\\\u1BA1-\\\\u1BAD\\\\u1BE6-\\\\u1BF3\\\\u1C24-\\\\u1C37\\\\u1CD0-\\\\u1CD2\\\\u1CD4-\\\\u1CE8\\\\u1CED\\\\u1CF2-\\\\u1CF4\\\\u1DC0-\\\\u1DE6\\\\u1DFC-\\\\u1DFF\\\\u20D0-\\\\u20DC\\\\u20E1\\\\u20E5-\\\\u20F0\\\\u2CEF-\\\\u2CF1\\\\u2D7F\\\\u2DE0-\\\\u2DFF\\\\u302A-\\\\u302F\\\\u3099\\\\u309A\\\\uA66F\\\\uA674-\\\\uA67D\\\\uA69F\\\\uA6F0\\\\uA6F1\\\\uA802\\\\uA806\\\\uA80B\\\\uA823-\\\\uA827\\\\uA880\\\\uA881\\\\uA8B4-\\\\uA8C4\\\\uA8E0-\\\\uA8F1\\\\uA926-\\\\uA92D\\\\uA947-\\\\uA953\\\\uA980-\\\\uA983\\\\uA9B3-\\\\uA9C0\\\\uAA29-\\\\uAA36\\\\uAA43\\\\uAA4C\\\\uAA4D\\\\uAA7B\\\\uAAB0\\\\uAAB2-\\\\uAAB4\\\\uAAB7\\\\uAAB8\\\\uAABE\\\\uAABF\\\\uAAC1\\\\uAAEB-\\\\uAAEF\\\\uAAF5\\\\uAAF6\\\\uABE3-\\\\uABEA\\\\uABEC\\\\uABED\\\\uFB1E\\\\uFE00-\\\\uFE0F\\\\uFE20-\\\\uFE26]\"),\n    connector_punctuation: new RegExp(\"[\\\\u005F\\\\u203F\\\\u2040\\\\u2054\\\\uFE33\\\\uFE34\\\\uFE4D-\\\\uFE4F\\\\uFF3F]\"),\n    digit: new RegExp(\"[\\\\u0030-\\\\u0039\\\\u0660-\\\\u0669\\\\u06F0-\\\\u06F9\\\\u07C0-\\\\u07C9\\\\u0966-\\\\u096F\\\\u09E6-\\\\u09EF\\\\u0A66-\\\\u0A6F\\\\u0AE6-\\\\u0AEF\\\\u0B66-\\\\u0B6F\\\\u0BE6-\\\\u0BEF\\\\u0C66-\\\\u0C6F\\\\u0CE6-\\\\u0CEF\\\\u0D66-\\\\u0D6F\\\\u0E50-\\\\u0E59\\\\u0ED0-\\\\u0ED9\\\\u0F20-\\\\u0F29\\\\u1040-\\\\u1049\\\\u1090-\\\\u1099\\\\u17E0-\\\\u17E9\\\\u1810-\\\\u1819\\\\u1946-\\\\u194F\\\\u19D0-\\\\u19D9\\\\u1A80-\\\\u1A89\\\\u1A90-\\\\u1A99\\\\u1B50-\\\\u1B59\\\\u1BB0-\\\\u1BB9\\\\u1C40-\\\\u1C49\\\\u1C50-\\\\u1C59\\\\uA620-\\\\uA629\\\\uA8D0-\\\\uA8D9\\\\uA900-\\\\uA909\\\\uA9D0-\\\\uA9D9\\\\uAA50-\\\\uAA59\\\\uABF0-\\\\uABF9\\\\uFF10-\\\\uFF19]\")\n};\n\nfunction is_letter(ch) {\n    return UNICODE.letter.test(ch);\n};\n\nfunction is_digit(ch) {\n    ch = ch.charCodeAt(0);\n    return ch >= 48 && ch <= 57;\n};\n\nfunction is_unicode_digit(ch) {\n    return UNICODE.digit.test(ch);\n}\n\nfunction is_alphanumeric_char(ch) {\n    return is_digit(ch) || is_letter(ch);\n};\n\nfunction is_unicode_combining_mark(ch) {\n    return UNICODE.combining_mark.test(ch);\n};\n\nfunction is_unicode_connector_punctuation(ch) {\n    return UNICODE.connector_punctuation.test(ch);\n};\n\nfunction is_identifier_start(ch) {\n    return ch == \"$\" || ch == \"_\" || is_letter(ch);\n};\n\nfunction is_identifier_char(ch) {\n    return is_identifier_start(ch)\n        || is_unicode_combining_mark(ch)\n        || is_unicode_digit(ch)\n        || is_unicode_connector_punctuation(ch)\n        || ch == \"\\u200c\" // zero-width non-joiner <ZWNJ>\n        || ch == \"\\u200d\" // zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)\n    ;\n};\n\nfunction parse_js_number(num) {\n    if (RE_HEX_NUMBER.test(num)) {\n        return parseInt(num.substr(2), 16);\n    } else if (RE_OCT_NUMBER.test(num)) {\n        return parseInt(num.substr(1), 8);\n    } else if (RE_DEC_NUMBER.test(num)) {\n        return parseFloat(num);\n    }\n};\n\nfunction JS_Parse_Error(message, line, col, pos) {\n    this.message = message;\n    this.line = line + 1;\n    this.col = col + 1;\n    this.pos = pos + 1;\n    this.stack = new Error().stack;\n};\n\nJS_Parse_Error.prototype.toString = function() {\n    return this.message + \" (line: \" + this.line + \", col: \" + this.col + \", pos: \" + this.pos + \")\" + \"\\n\\n\" + this.stack;\n};\n\nfunction js_error(message, line, col, pos) {\n    throw new JS_Parse_Error(message, line, col, pos);\n};\n\nfunction is_token(token, type, val) {\n    return token.type == type && (val == null || token.value == val);\n};\n\nvar EX_EOF = {};\n\nfunction tokenizer($TEXT) {\n\n    var S = {\n        text            : $TEXT.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\").replace(/^\\uFEFF/, ''),\n        pos             : 0,\n        tokpos          : 0,\n        line            : 0,\n        tokline         : 0,\n        col             : 0,\n        tokcol          : 0,\n        newline_before  : false,\n        regex_allowed   : false,\n        comments_before : []\n    };\n\n    function peek() { return S.text.charAt(S.pos); };\n\n    function next(signal_eof, in_string) {\n        var ch = S.text.charAt(S.pos++);\n        if (signal_eof && !ch)\n            throw EX_EOF;\n        if (ch == \"\\n\") {\n            S.newline_before = S.newline_before || !in_string;\n            ++S.line;\n            S.col = 0;\n        } else {\n            ++S.col;\n        }\n        return ch;\n    };\n\n    function eof() {\n        return !S.peek();\n    };\n\n    function find(what, signal_eof) {\n        var pos = S.text.indexOf(what, S.pos);\n        if (signal_eof && pos == -1) throw EX_EOF;\n        return pos;\n    };\n\n    function start_token() {\n        S.tokline = S.line;\n        S.tokcol = S.col;\n        S.tokpos = S.pos;\n    };\n\n    function token(type, value, is_comment) {\n        S.regex_allowed = ((type == \"operator\" && !HOP(UNARY_POSTFIX, value)) ||\n                           (type == \"keyword\" && HOP(KEYWORDS_BEFORE_EXPRESSION, value)) ||\n                           (type == \"punc\" && HOP(PUNC_BEFORE_EXPRESSION, value)));\n        var ret = {\n            type   : type,\n            value  : value,\n            line   : S.tokline,\n            col    : S.tokcol,\n            pos    : S.tokpos,\n            endpos : S.pos,\n            nlb    : S.newline_before\n        };\n        if (!is_comment) {\n            ret.comments_before = S.comments_before;\n            S.comments_before = [];\n            // make note of any newlines in the comments that came before\n            for (var i = 0, len = ret.comments_before.length; i < len; i++) {\n                ret.nlb = ret.nlb || ret.comments_before[i].nlb;\n            }\n        }\n        S.newline_before = false;\n        return ret;\n    };\n\n    function skip_whitespace() {\n        while (HOP(WHITESPACE_CHARS, peek()))\n            next();\n    };\n\n    function read_while(pred) {\n        var ret = \"\", ch = peek(), i = 0;\n        while (ch && pred(ch, i++)) {\n            ret += next();\n            ch = peek();\n        }\n        return ret;\n    };\n\n    function parse_error(err) {\n        js_error(err, S.tokline, S.tokcol, S.tokpos);\n    };\n\n    function read_num(prefix) {\n        var has_e = false, after_e = false, has_x = false, has_dot = prefix == \".\";\n        var num = read_while(function(ch, i){\n            if (ch == \"x\" || ch == \"X\") {\n                if (has_x) return false;\n                return has_x = true;\n            }\n            if (!has_x && (ch == \"E\" || ch == \"e\")) {\n                if (has_e) return false;\n                return has_e = after_e = true;\n            }\n            if (ch == \"-\") {\n                if (after_e || (i == 0 && !prefix)) return true;\n                return false;\n            }\n            if (ch == \"+\") return after_e;\n            after_e = false;\n            if (ch == \".\") {\n                if (!has_dot && !has_x && !has_e)\n                    return has_dot = true;\n                return false;\n            }\n            return is_alphanumeric_char(ch);\n        });\n        if (prefix)\n            num = prefix + num;\n        var valid = parse_js_number(num);\n        if (!isNaN(valid)) {\n            return token(\"num\", valid);\n        } else {\n            parse_error(\"Invalid syntax: \" + num);\n        }\n    };\n\n    function read_escaped_char(in_string) {\n        var ch = next(true, in_string);\n        switch (ch) {\n          case \"n\" : return \"\\n\";\n          case \"r\" : return \"\\r\";\n          case \"t\" : return \"\\t\";\n          case \"b\" : return \"\\b\";\n          case \"v\" : return \"\\u000b\";\n          case \"f\" : return \"\\f\";\n          case \"0\" : return \"\\0\";\n          case \"x\" : return String.fromCharCode(hex_bytes(2));\n          case \"u\" : return String.fromCharCode(hex_bytes(4));\n          case \"\\n\": return \"\";\n          default  : return ch;\n        }\n    };\n\n    function hex_bytes(n) {\n        var num = 0;\n        for (; n > 0; --n) {\n            var digit = parseInt(next(true), 16);\n            if (isNaN(digit))\n                parse_error(\"Invalid hex-character pattern in string\");\n            num = (num << 4) | digit;\n        }\n        return num;\n    };\n\n    function read_string() {\n        return with_eof_error(\"Unterminated string constant\", function(){\n            var quote = next(), ret = \"\";\n            for (;;) {\n                var ch = next(true);\n                if (ch == \"\\\\\") {\n                    // read OctalEscapeSequence (XXX: deprecated if \"strict mode\")\n                    // https://github.com/mishoo/UglifyJS/issues/178\n                    var octal_len = 0, first = null;\n                    ch = read_while(function(ch){\n                        if (ch >= \"0\" && ch <= \"7\") {\n                            if (!first) {\n                                first = ch;\n                                return ++octal_len;\n                            }\n                            else if (first <= \"3\" && octal_len <= 2) return ++octal_len;\n                            else if (first >= \"4\" && octal_len <= 1) return ++octal_len;\n                        }\n                        return false;\n                    });\n                    if (octal_len > 0) ch = String.fromCharCode(parseInt(ch, 8));\n                    else ch = read_escaped_char(true);\n                }\n                else if (ch == quote) break;\n                else if (ch == \"\\n\") throw EX_EOF;\n                ret += ch;\n            }\n            return token(\"string\", ret);\n        });\n    };\n\n    function read_line_comment() {\n        next();\n        var i = find(\"\\n\"), ret;\n        if (i == -1) {\n            ret = S.text.substr(S.pos);\n            S.pos = S.text.length;\n        } else {\n            ret = S.text.substring(S.pos, i);\n            S.pos = i;\n        }\n        return token(\"comment1\", ret, true);\n    };\n\n    function read_multiline_comment() {\n        next();\n        return with_eof_error(\"Unterminated multiline comment\", function(){\n            var i = find(\"*/\", true),\n            text = S.text.substring(S.pos, i);\n            S.pos = i + 2;\n            S.line += text.split(\"\\n\").length - 1;\n            S.newline_before = S.newline_before || text.indexOf(\"\\n\") >= 0;\n\n            // https://github.com/mishoo/UglifyJS/issues/#issue/100\n            if (/^@cc_on/i.test(text)) {\n                warn(\"WARNING: at line \" + S.line);\n                warn(\"*** Found \\\"conditional comment\\\": \" + text);\n                warn(\"*** UglifyJS DISCARDS ALL COMMENTS.  This means your code might no longer work properly in Internet Explorer.\");\n            }\n\n            return token(\"comment2\", text, true);\n        });\n    };\n\n    function read_name() {\n        var backslash = false, name = \"\", ch, escaped = false, hex;\n        while ((ch = peek()) != null) {\n            if (!backslash) {\n                if (ch == \"\\\\\") escaped = backslash = true, next();\n                else if (is_identifier_char(ch)) name += next();\n                else break;\n            }\n            else {\n                if (ch != \"u\") parse_error(\"Expecting UnicodeEscapeSequence -- uXXXX\");\n                ch = read_escaped_char();\n                if (!is_identifier_char(ch)) parse_error(\"Unicode char: \" + ch.charCodeAt(0) + \" is not valid in identifier\");\n                name += ch;\n                backslash = false;\n            }\n        }\n        if (HOP(KEYWORDS, name) && escaped) {\n            hex = name.charCodeAt(0).toString(16).toUpperCase();\n            name = \"\\\\u\" + \"0000\".substr(hex.length) + hex + name.slice(1);\n        }\n        return name;\n    };\n\n    function read_regexp(regexp) {\n        return with_eof_error(\"Unterminated regular expression\", function(){\n            var prev_backslash = false, ch, in_class = false;\n            while ((ch = next(true))) if (prev_backslash) {\n                regexp += \"\\\\\" + ch;\n                prev_backslash = false;\n            } else if (ch == \"[\") {\n                in_class = true;\n                regexp += ch;\n            } else if (ch == \"]\" && in_class) {\n                in_class = false;\n                regexp += ch;\n            } else if (ch == \"/\" && !in_class) {\n                break;\n            } else if (ch == \"\\\\\") {\n                prev_backslash = true;\n            } else {\n                regexp += ch;\n            }\n            var mods = read_name();\n            return token(\"regexp\", [ regexp, mods ]);\n        });\n    };\n\n    function read_operator(prefix) {\n        function grow(op) {\n            if (!peek()) return op;\n            var bigger = op + peek();\n            if (HOP(OPERATORS, bigger)) {\n                next();\n                return grow(bigger);\n            } else {\n                return op;\n            }\n        };\n        return token(\"operator\", grow(prefix || next()));\n    };\n\n    function handle_slash() {\n        next();\n        var regex_allowed = S.regex_allowed;\n        switch (peek()) {\n          case \"/\":\n            S.comments_before.push(read_line_comment());\n            S.regex_allowed = regex_allowed;\n            return next_token();\n          case \"*\":\n            S.comments_before.push(read_multiline_comment());\n            S.regex_allowed = regex_allowed;\n            return next_token();\n        }\n        return S.regex_allowed ? read_regexp(\"\") : read_operator(\"/\");\n    };\n\n    function handle_dot() {\n        next();\n        return is_digit(peek())\n            ? read_num(\".\")\n            : token(\"punc\", \".\");\n    };\n\n    function read_word() {\n        var word = read_name();\n        return !HOP(KEYWORDS, word)\n            ? token(\"name\", word)\n            : HOP(OPERATORS, word)\n            ? token(\"operator\", word)\n            : HOP(KEYWORDS_ATOM, word)\n            ? token(\"atom\", word)\n            : token(\"keyword\", word);\n    };\n\n    function with_eof_error(eof_error, cont) {\n        try {\n            return cont();\n        } catch(ex) {\n            if (ex === EX_EOF) parse_error(eof_error);\n            else throw ex;\n        }\n    };\n\n    function next_token(force_regexp) {\n        if (force_regexp != null)\n            return read_regexp(force_regexp);\n        skip_whitespace();\n        start_token();\n        var ch = peek();\n        if (!ch) return token(\"eof\");\n        if (is_digit(ch)) return read_num();\n        if (ch == '\"' || ch == \"'\") return read_string();\n        if (HOP(PUNC_CHARS, ch)) return token(\"punc\", next());\n        if (ch == \".\") return handle_dot();\n        if (ch == \"/\") return handle_slash();\n        if (HOP(OPERATOR_CHARS, ch)) return read_operator();\n        if (ch == \"\\\\\" || is_identifier_start(ch)) return read_word();\n        parse_error(\"Unexpected character '\" + ch + \"'\");\n    };\n\n    next_token.context = function(nc) {\n        if (nc) S = nc;\n        return S;\n    };\n\n    return next_token;\n\n};\n\n/* -----[ Parser (constants) ]----- */\n\nvar UNARY_PREFIX = array_to_hash([\n    \"typeof\",\n    \"void\",\n    \"delete\",\n    \"--\",\n    \"++\",\n    \"!\",\n    \"~\",\n    \"-\",\n    \"+\"\n]);\n\nvar UNARY_POSTFIX = array_to_hash([ \"--\", \"++\" ]);\n\nvar ASSIGNMENT = (function(a, ret, i){\n    while (i < a.length) {\n        ret[a[i]] = a[i].substr(0, a[i].length - 1);\n        i++;\n    }\n    return ret;\n})(\n    [\"+=\", \"-=\", \"/=\", \"*=\", \"%=\", \">>=\", \"<<=\", \">>>=\", \"|=\", \"^=\", \"&=\"],\n    { \"=\": true },\n    0\n);\n\nvar PRECEDENCE = (function(a, ret){\n    for (var i = 0, n = 1; i < a.length; ++i, ++n) {\n        var b = a[i];\n        for (var j = 0; j < b.length; ++j) {\n            ret[b[j]] = n;\n        }\n    }\n    return ret;\n})(\n    [\n        [\"||\"],\n        [\"&&\"],\n        [\"|\"],\n        [\"^\"],\n        [\"&\"],\n        [\"==\", \"===\", \"!=\", \"!==\"],\n        [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n        [\">>\", \"<<\", \">>>\"],\n        [\"+\", \"-\"],\n        [\"*\", \"/\", \"%\"]\n    ],\n    {}\n);\n\nvar STATEMENTS_WITH_LABELS = array_to_hash([ \"for\", \"do\", \"while\", \"switch\" ]);\n\nvar ATOMIC_START_TOKEN = array_to_hash([ \"atom\", \"num\", \"string\", \"regexp\", \"name\" ]);\n\n/* -----[ Parser ]----- */\n\nfunction NodeWithToken(str, start, end) {\n    this.name = str;\n    this.start = start;\n    this.end = end;\n};\n\nNodeWithToken.prototype.toString = function() { return this.name; };\n\nfunction parse($TEXT, exigent_mode, embed_tokens) {\n\n    var S = {\n        input         : typeof $TEXT == \"string\" ? tokenizer($TEXT, true) : $TEXT,\n        token         : null,\n        prev          : null,\n        peeked        : null,\n        in_function   : 0,\n        in_directives : true,\n        in_loop       : 0,\n        labels        : []\n    };\n\n    S.token = next();\n\n    function is(type, value) {\n        return is_token(S.token, type, value);\n    };\n\n    function peek() { return S.peeked || (S.peeked = S.input()); };\n\n    function next() {\n        S.prev = S.token;\n        if (S.peeked) {\n            S.token = S.peeked;\n            S.peeked = null;\n        } else {\n            S.token = S.input();\n        }\n        S.in_directives = S.in_directives && (\n            S.token.type == \"string\" || is(\"punc\", \";\")\n        );\n        return S.token;\n    };\n\n    function prev() {\n        return S.prev;\n    };\n\n    function croak(msg, line, col, pos) {\n        var ctx = S.input.context();\n        js_error(msg,\n                 line != null ? line : ctx.tokline,\n                 col != null ? col : ctx.tokcol,\n                 pos != null ? pos : ctx.tokpos);\n    };\n\n    function token_error(token, msg) {\n        croak(msg, token.line, token.col);\n    };\n\n    function unexpected(token) {\n        if (token == null)\n            token = S.token;\n        token_error(token, \"Unexpected token: \" + token.type + \" (\" + token.value + \")\");\n    };\n\n    function expect_token(type, val) {\n        if (is(type, val)) {\n            return next();\n        }\n        token_error(S.token, \"Unexpected token \" + S.token.type + \", expected \" + type);\n    };\n\n    function expect(punc) { return expect_token(\"punc\", punc); };\n\n    function can_insert_semicolon() {\n        return !exigent_mode && (\n            S.token.nlb || is(\"eof\") || is(\"punc\", \"}\")\n        );\n    };\n\n    function semicolon() {\n        if (is(\"punc\", \";\")) next();\n        else if (!can_insert_semicolon()) unexpected();\n    };\n\n    function as() {\n        return slice(arguments);\n    };\n\n    function parenthesised() {\n        expect(\"(\");\n        var ex = expression();\n        expect(\")\");\n        return ex;\n    };\n\n    function add_tokens(str, start, end) {\n        return str instanceof NodeWithToken ? str : new NodeWithToken(str, start, end);\n    };\n\n    function maybe_embed_tokens(parser) {\n        if (embed_tokens) return function() {\n            var start = S.token;\n            var ast = parser.apply(this, arguments);\n            ast[0] = add_tokens(ast[0], start, prev());\n            return ast;\n        };\n        else return parser;\n    };\n\n    var statement = maybe_embed_tokens(function() {\n        if (is(\"operator\", \"/\") || is(\"operator\", \"/=\")) {\n            S.peeked = null;\n            S.token = S.input(S.token.value.substr(1)); // force regexp\n        }\n        switch (S.token.type) {\n          case \"string\":\n            var dir = S.in_directives, stat = simple_statement();\n            if (dir && stat[1][0] == \"string\" && !is(\"punc\", \",\"))\n                return as(\"directive\", stat[1][1]);\n            return stat;\n          case \"num\":\n          case \"regexp\":\n          case \"operator\":\n          case \"atom\":\n            return simple_statement();\n\n          case \"name\":\n            return is_token(peek(), \"punc\", \":\")\n                ? labeled_statement(prog1(S.token.value, next, next))\n                : simple_statement();\n\n          case \"punc\":\n            switch (S.token.value) {\n              case \"{\":\n                return as(\"block\", block_());\n              case \"[\":\n              case \"(\":\n                return simple_statement();\n              case \";\":\n                next();\n                return as(\"block\");\n              default:\n                unexpected();\n            }\n\n          case \"keyword\":\n            switch (prog1(S.token.value, next)) {\n              case \"break\":\n                return break_cont(\"break\");\n\n              case \"continue\":\n                return break_cont(\"continue\");\n\n              case \"debugger\":\n                semicolon();\n                return as(\"debugger\");\n\n              case \"do\":\n                return (function(body){\n                    expect_token(\"keyword\", \"while\");\n                    return as(\"do\", prog1(parenthesised, semicolon), body);\n                })(in_loop(statement));\n\n              case \"for\":\n                return for_();\n\n              case \"function\":\n                return function_(true);\n\n              case \"if\":\n                return if_();\n\n              case \"return\":\n                if (S.in_function == 0)\n                    croak(\"'return' outside of function\");\n                return as(\"return\",\n                          is(\"punc\", \";\")\n                          ? (next(), null)\n                          : can_insert_semicolon()\n                          ? null\n                          : prog1(expression, semicolon));\n\n              case \"switch\":\n                return as(\"switch\", parenthesised(), switch_block_());\n\n              case \"throw\":\n                if (S.token.nlb)\n                    croak(\"Illegal newline after 'throw'\");\n                return as(\"throw\", prog1(expression, semicolon));\n\n              case \"try\":\n                return try_();\n\n              case \"var\":\n                return prog1(var_, semicolon);\n\n              case \"const\":\n                return prog1(const_, semicolon);\n\n              case \"while\":\n                return as(\"while\", parenthesised(), in_loop(statement));\n\n              case \"with\":\n                return as(\"with\", parenthesised(), statement());\n\n              default:\n                unexpected();\n            }\n        }\n    });\n\n    function labeled_statement(label) {\n        S.labels.push(label);\n        var start = S.token, stat = statement();\n        if (exigent_mode && !HOP(STATEMENTS_WITH_LABELS, stat[0]))\n            unexpected(start);\n        S.labels.pop();\n        return as(\"label\", label, stat);\n    };\n\n    function simple_statement() {\n        return as(\"stat\", prog1(expression, semicolon));\n    };\n\n    function break_cont(type) {\n        var name;\n        if (!can_insert_semicolon()) {\n            name = is(\"name\") ? S.token.value : null;\n        }\n        if (name != null) {\n            next();\n            if (!member(name, S.labels))\n                croak(\"Label \" + name + \" without matching loop or statement\");\n        }\n        else if (S.in_loop == 0)\n            croak(type + \" not inside a loop or switch\");\n        semicolon();\n        return as(type, name);\n    };\n\n    function for_() {\n        expect(\"(\");\n        var init = null;\n        if (!is(\"punc\", \";\")) {\n            init = is(\"keyword\", \"var\")\n                ? (next(), var_(true))\n                : expression(true, true);\n            if (is(\"operator\", \"in\")) {\n                if (init[0] == \"var\" && init[1].length > 1)\n                    croak(\"Only one variable declaration allowed in for..in loop\");\n                return for_in(init);\n            }\n        }\n        return regular_for(init);\n    };\n\n    function regular_for(init) {\n        expect(\";\");\n        var test = is(\"punc\", \";\") ? null : expression();\n        expect(\";\");\n        var step = is(\"punc\", \")\") ? null : expression();\n        expect(\")\");\n        return as(\"for\", init, test, step, in_loop(statement));\n    };\n\n    function for_in(init) {\n        var lhs = init[0] == \"var\" ? as(\"name\", init[1][0]) : init;\n        next();\n        var obj = expression();\n        expect(\")\");\n        return as(\"for-in\", init, lhs, obj, in_loop(statement));\n    };\n\n    var function_ = function(in_statement) {\n        var name = is(\"name\") ? prog1(S.token.value, next) : null;\n        if (in_statement && !name)\n            unexpected();\n        expect(\"(\");\n        return as(in_statement ? \"defun\" : \"function\",\n                  name,\n                  // arguments\n                  (function(first, a){\n                      while (!is(\"punc\", \")\")) {\n                          if (first) first = false; else expect(\",\");\n                          if (!is(\"name\")) unexpected();\n                          a.push(S.token.value);\n                          next();\n                      }\n                      next();\n                      return a;\n                  })(true, []),\n                  // body\n                  (function(){\n                      ++S.in_function;\n                      var loop = S.in_loop;\n                      S.in_directives = true;\n                      S.in_loop = 0;\n                      var a = block_();\n                      --S.in_function;\n                      S.in_loop = loop;\n                      return a;\n                  })());\n    };\n\n    function if_() {\n        var cond = parenthesised(), body = statement(), belse;\n        if (is(\"keyword\", \"else\")) {\n            next();\n            belse = statement();\n        }\n        return as(\"if\", cond, body, belse);\n    };\n\n    function block_() {\n        expect(\"{\");\n        var a = [];\n        while (!is(\"punc\", \"}\")) {\n            if (is(\"eof\")) unexpected();\n            a.push(statement());\n        }\n        next();\n        return a;\n    };\n\n    var switch_block_ = curry(in_loop, function(){\n        expect(\"{\");\n        var a = [], cur = null;\n        while (!is(\"punc\", \"}\")) {\n            if (is(\"eof\")) unexpected();\n            if (is(\"keyword\", \"case\")) {\n                next();\n                cur = [];\n                a.push([ expression(), cur ]);\n                expect(\":\");\n            }\n            else if (is(\"keyword\", \"default\")) {\n                next();\n                expect(\":\");\n                cur = [];\n                a.push([ null, cur ]);\n            }\n            else {\n                if (!cur) unexpected();\n                cur.push(statement());\n            }\n        }\n        next();\n        return a;\n    });\n\n    function try_() {\n        var body = block_(), bcatch, bfinally;\n        if (is(\"keyword\", \"catch\")) {\n            next();\n            expect(\"(\");\n            if (!is(\"name\"))\n                croak(\"Name expected\");\n            var name = S.token.value;\n            next();\n            expect(\")\");\n            bcatch = [ name, block_() ];\n        }\n        if (is(\"keyword\", \"finally\")) {\n            next();\n            bfinally = block_();\n        }\n        if (!bcatch && !bfinally)\n            croak(\"Missing catch/finally blocks\");\n        return as(\"try\", body, bcatch, bfinally);\n    };\n\n    function vardefs(no_in) {\n        var a = [];\n        for (;;) {\n            if (!is(\"name\"))\n                unexpected();\n            var name = S.token.value;\n            next();\n            if (is(\"operator\", \"=\")) {\n                next();\n                a.push([ name, expression(false, no_in) ]);\n            } else {\n                a.push([ name ]);\n            }\n            if (!is(\"punc\", \",\"))\n                break;\n            next();\n        }\n        return a;\n    };\n\n    function var_(no_in) {\n        return as(\"var\", vardefs(no_in));\n    };\n\n    function const_() {\n        return as(\"const\", vardefs());\n    };\n\n    function new_() {\n        var newexp = expr_atom(false), args;\n        if (is(\"punc\", \"(\")) {\n            next();\n            args = expr_list(\")\");\n        } else {\n            args = [];\n        }\n        return subscripts(as(\"new\", newexp, args), true);\n    };\n\n    var expr_atom = maybe_embed_tokens(function(allow_calls) {\n        if (is(\"operator\", \"new\")) {\n            next();\n            return new_();\n        }\n        if (is(\"punc\")) {\n            switch (S.token.value) {\n              case \"(\":\n                next();\n                return subscripts(prog1(expression, curry(expect, \")\")), allow_calls);\n              case \"[\":\n                next();\n                return subscripts(array_(), allow_calls);\n              case \"{\":\n                next();\n                return subscripts(object_(), allow_calls);\n            }\n            unexpected();\n        }\n        if (is(\"keyword\", \"function\")) {\n            next();\n            return subscripts(function_(false), allow_calls);\n        }\n        if (HOP(ATOMIC_START_TOKEN, S.token.type)) {\n            var atom = S.token.type == \"regexp\"\n                ? as(\"regexp\", S.token.value[0], S.token.value[1])\n                : as(S.token.type, S.token.value);\n            return subscripts(prog1(atom, next), allow_calls);\n        }\n        unexpected();\n    });\n\n    function expr_list(closing, allow_trailing_comma, allow_empty) {\n        var first = true, a = [];\n        while (!is(\"punc\", closing)) {\n            if (first) first = false; else expect(\",\");\n            if (allow_trailing_comma && is(\"punc\", closing)) break;\n            if (is(\"punc\", \",\") && allow_empty) {\n                a.push([ \"atom\", \"undefined\" ]);\n            } else {\n                a.push(expression(false));\n            }\n        }\n        next();\n        return a;\n    };\n\n    function array_() {\n        return as(\"array\", expr_list(\"]\", !exigent_mode, true));\n    };\n\n    function object_() {\n        var first = true, a = [];\n        while (!is(\"punc\", \"}\")) {\n            if (first) first = false; else expect(\",\");\n            if (!exigent_mode && is(\"punc\", \"}\"))\n                // allow trailing comma\n                break;\n            var type = S.token.type;\n            var name = as_property_name();\n            if (type == \"name\" && (name == \"get\" || name == \"set\") && !is(\"punc\", \":\")) {\n                a.push([ as_name(), function_(false), name ]);\n            } else {\n                expect(\":\");\n                a.push([ name, expression(false) ]);\n            }\n        }\n        next();\n        return as(\"object\", a);\n    };\n\n    function as_property_name() {\n        switch (S.token.type) {\n          case \"num\":\n          case \"string\":\n            return prog1(S.token.value, next);\n        }\n        return as_name();\n    };\n\n    function as_name() {\n        switch (S.token.type) {\n          case \"name\":\n          case \"operator\":\n          case \"keyword\":\n          case \"atom\":\n            return prog1(S.token.value, next);\n          default:\n            unexpected();\n        }\n    };\n\n    function subscripts(expr, allow_calls) {\n        if (is(\"punc\", \".\")) {\n            next();\n            return subscripts(as(\"dot\", expr, as_name()), allow_calls);\n        }\n        if (is(\"punc\", \"[\")) {\n            next();\n            return subscripts(as(\"sub\", expr, prog1(expression, curry(expect, \"]\"))), allow_calls);\n        }\n        if (allow_calls && is(\"punc\", \"(\")) {\n            next();\n            return subscripts(as(\"call\", expr, expr_list(\")\")), true);\n        }\n        return expr;\n    };\n\n    function maybe_unary(allow_calls) {\n        if (is(\"operator\") && HOP(UNARY_PREFIX, S.token.value)) {\n            return make_unary(\"unary-prefix\",\n                              prog1(S.token.value, next),\n                              maybe_unary(allow_calls));\n        }\n        var val = expr_atom(allow_calls);\n        while (is(\"operator\") && HOP(UNARY_POSTFIX, S.token.value) && !S.token.nlb) {\n            val = make_unary(\"unary-postfix\", S.token.value, val);\n            next();\n        }\n        return val;\n    };\n\n    function make_unary(tag, op, expr) {\n        if ((op == \"++\" || op == \"--\") && !is_assignable(expr))\n            croak(\"Invalid use of \" + op + \" operator\");\n        return as(tag, op, expr);\n    };\n\n    function expr_op(left, min_prec, no_in) {\n        var op = is(\"operator\") ? S.token.value : null;\n        if (op && op == \"in\" && no_in) op = null;\n        var prec = op != null ? PRECEDENCE[op] : null;\n        if (prec != null && prec > min_prec) {\n            next();\n            var right = expr_op(maybe_unary(true), prec, no_in);\n            return expr_op(as(\"binary\", op, left, right), min_prec, no_in);\n        }\n        return left;\n    };\n\n    function expr_ops(no_in) {\n        return expr_op(maybe_unary(true), 0, no_in);\n    };\n\n    function maybe_conditional(no_in) {\n        var expr = expr_ops(no_in);\n        if (is(\"operator\", \"?\")) {\n            next();\n            var yes = expression(false);\n            expect(\":\");\n            return as(\"conditional\", expr, yes, expression(false, no_in));\n        }\n        return expr;\n    };\n\n    function is_assignable(expr) {\n        if (!exigent_mode) return true;\n        switch (expr[0]+\"\") {\n          case \"dot\":\n          case \"sub\":\n          case \"new\":\n          case \"call\":\n            return true;\n          case \"name\":\n            return expr[1] != \"this\";\n        }\n    };\n\n    function maybe_assign(no_in) {\n        var left = maybe_conditional(no_in), val = S.token.value;\n        if (is(\"operator\") && HOP(ASSIGNMENT, val)) {\n            if (is_assignable(left)) {\n                next();\n                return as(\"assign\", ASSIGNMENT[val], left, maybe_assign(no_in));\n            }\n            croak(\"Invalid assignment\");\n        }\n        return left;\n    };\n\n    var expression = maybe_embed_tokens(function(commas, no_in) {\n        if (arguments.length == 0)\n            commas = true;\n        var expr = maybe_assign(no_in);\n        if (commas && is(\"punc\", \",\")) {\n            next();\n            return as(\"seq\", expr, expression(true, no_in));\n        }\n        return expr;\n    });\n\n    function in_loop(cont) {\n        try {\n            ++S.in_loop;\n            return cont();\n        } finally {\n            --S.in_loop;\n        }\n    };\n\n    return as(\"toplevel\", (function(a){\n        while (!is(\"eof\"))\n            a.push(statement());\n        return a;\n    })([]));\n\n};\n\n/* -----[ Utilities ]----- */\n\nfunction curry(f) {\n    var args = slice(arguments, 1);\n    return function() { return f.apply(this, args.concat(slice(arguments))); };\n};\n\nfunction prog1(ret) {\n    if (ret instanceof Function)\n        ret = ret();\n    for (var i = 1, n = arguments.length; --n > 0; ++i)\n        arguments[i]();\n    return ret;\n};\n\nfunction array_to_hash(a) {\n    var ret = {};\n    for (var i = 0; i < a.length; ++i)\n        ret[a[i]] = true;\n    return ret;\n};\n\nfunction slice(a, start) {\n    return Array.prototype.slice.call(a, start || 0);\n};\n\nfunction characters(str) {\n    return str.split(\"\");\n};\n\nfunction member(name, array) {\n    for (var i = array.length; --i >= 0;)\n        if (array[i] == name)\n            return true;\n    return false;\n};\n\nfunction HOP(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n};\n\nvar warn = function() {};\n\n/* -----[ Exports ]----- */\n\nexports.tokenizer = tokenizer;\nexports.parse = parse;\nexports.slice = slice;\nexports.curry = curry;\nexports.member = member;\nexports.array_to_hash = array_to_hash;\nexports.PRECEDENCE = PRECEDENCE;\nexports.KEYWORDS_ATOM = KEYWORDS_ATOM;\nexports.RESERVED_WORDS = RESERVED_WORDS;\nexports.KEYWORDS = KEYWORDS;\nexports.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;\nexports.OPERATORS = OPERATORS;\nexports.is_alphanumeric_char = is_alphanumeric_char;\nexports.is_identifier_start = is_identifier_start;\nexports.is_identifier_char = is_identifier_char;\nexports.set_logger = function(logger) {\n    warn = logger;\n};\n\n// Local variables:\n// js-indent-level: 4\n// End:\n\n/* @license\n\n  Copyright (c) 2010 Mihai Bazon <mihai.bazon@gmail.com>\n  Copyright (c) 2011 Lauri Paimen <lauri@paimen.info>\n  Copyright (c) 2013 Anton Kreuzkamp <akreuzkamp@web.de>\n  Copyright (c) 2016 qmlweb-parser contributors\n  Based on parse-js (http://marijn.haverbeke.nl/parse-js/).\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n      * Redistributions of source code must retain the above\n        copyright notice, this list of conditions and the following\n        disclaimer.\n\n      * Redistributions in binary form must reproduce the above\n        copyright notice, this list of conditions and the following\n        disclaimer in the documentation and/or other materials\n        provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n  SUCH DAMAGE.\n*/\n\n/*\n * QML parser and parsetree'er.\n *\n * Exports:\n *\n * - qmlweb_parse(src, type) -- parses QML source and returns it as output\n *   tree expected by the QML engine\n */\n\n// Object cloning for debug prints.\nfunction clone(obj) {\n  if (obj == null || typeof obj !== 'object')\n    return obj;\n\n  var temp = {}; // changed\n\n  for (var key in obj)\n    temp[key] = clone(obj[key]);\n  return temp;\n}\n\nfunction QMLParseError(message, line, col, pos, source) {\n  JS_Parse_Error.call(this, message, line, col, pos);\n  var comment = extractLinesForErrorDiag(source, line);\n  this.comment = comment ? comment : \"\";\n  this.message += \" (line: \" + this.line + \", col: \" + col + \", pos: \" + pos + \")\" + \"\\n\" + comment + \"\\n\";\n  this.file = qmlweb_parse.nowParsingFile;\n}\nQMLParseError.prototype = new Error();\n\nfunction extractLinesForErrorDiag(text, line) {\n  var r = \"\";\n  var lines = text.split(\"\\n\");\n\n  for (var i = line - 3; i <= line + 3; i++) {\n    if (i >= 0 && i < lines.length ) {\n      var mark = i === line ? \">>\" : \"  \";\n      r += mark + (i + 1) + \"  \" + lines[i] + \"\\n\";\n    }\n  }\n\n  return r;\n}\n\nfunction qmlweb_tokenizer($TEXT) {\n  // Override UglifyJS methods\n\n  parse_error = function(err) {\n    throw new QMLParseError(err, S.tokline, S.tokcol, S.tokpos, S.text);\n  };\n\n  // WARNING: Here the original tokenizer() code gets embedded\n  \n\n    var S = {\n        text            : $TEXT.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\").replace(/^\\uFEFF/, ''),\n        pos             : 0,\n        tokpos          : 0,\n        line            : 0,\n        tokline         : 0,\n        col             : 0,\n        tokcol          : 0,\n        newline_before  : false,\n        regex_allowed   : false,\n        comments_before : []\n    };\n\n    function peek() { return S.text.charAt(S.pos); };\n\n    function next(signal_eof, in_string) {\n        var ch = S.text.charAt(S.pos++);\n        if (signal_eof && !ch)\n            throw EX_EOF;\n        if (ch == \"\\n\") {\n            S.newline_before = S.newline_before || !in_string;\n            ++S.line;\n            S.col = 0;\n        } else {\n            ++S.col;\n        }\n        return ch;\n    };\n\n    function eof() {\n        return !S.peek();\n    };\n\n    function find(what, signal_eof) {\n        var pos = S.text.indexOf(what, S.pos);\n        if (signal_eof && pos == -1) throw EX_EOF;\n        return pos;\n    };\n\n    function start_token() {\n        S.tokline = S.line;\n        S.tokcol = S.col;\n        S.tokpos = S.pos;\n    };\n\n    function token(type, value, is_comment) {\n        S.regex_allowed = ((type == \"operator\" && !HOP(UNARY_POSTFIX, value)) ||\n                           (type == \"keyword\" && HOP(KEYWORDS_BEFORE_EXPRESSION, value)) ||\n                           (type == \"punc\" && HOP(PUNC_BEFORE_EXPRESSION, value)));\n        var ret = {\n            type   : type,\n            value  : value,\n            line   : S.tokline,\n            col    : S.tokcol,\n            pos    : S.tokpos,\n            endpos : S.pos,\n            nlb    : S.newline_before\n        };\n        if (!is_comment) {\n            ret.comments_before = S.comments_before;\n            S.comments_before = [];\n            // make note of any newlines in the comments that came before\n            for (var i = 0, len = ret.comments_before.length; i < len; i++) {\n                ret.nlb = ret.nlb || ret.comments_before[i].nlb;\n            }\n        }\n        S.newline_before = false;\n        return ret;\n    };\n\n    function skip_whitespace() {\n        while (HOP(WHITESPACE_CHARS, peek()))\n            next();\n    };\n\n    function read_while(pred) {\n        var ret = \"\", ch = peek(), i = 0;\n        while (ch && pred(ch, i++)) {\n            ret += next();\n            ch = peek();\n        }\n        return ret;\n    };\n\n    function parse_error(err) {\n        js_error(err, S.tokline, S.tokcol, S.tokpos);\n    };\n\n    function read_num(prefix) {\n        var has_e = false, after_e = false, has_x = false, has_dot = prefix == \".\";\n        var num = read_while(function(ch, i){\n            if (ch == \"x\" || ch == \"X\") {\n                if (has_x) return false;\n                return has_x = true;\n            }\n            if (!has_x && (ch == \"E\" || ch == \"e\")) {\n                if (has_e) return false;\n                return has_e = after_e = true;\n            }\n            if (ch == \"-\") {\n                if (after_e || (i == 0 && !prefix)) return true;\n                return false;\n            }\n            if (ch == \"+\") return after_e;\n            after_e = false;\n            if (ch == \".\") {\n                if (!has_dot && !has_x && !has_e)\n                    return has_dot = true;\n                return false;\n            }\n            return is_alphanumeric_char(ch);\n        });\n        if (prefix)\n            num = prefix + num;\n        var valid = parse_js_number(num);\n        if (!isNaN(valid)) {\n            return token(\"num\", valid);\n        } else {\n            parse_error(\"Invalid syntax: \" + num);\n        }\n    };\n\n    function read_escaped_char(in_string) {\n        var ch = next(true, in_string);\n        switch (ch) {\n          case \"n\" : return \"\\n\";\n          case \"r\" : return \"\\r\";\n          case \"t\" : return \"\\t\";\n          case \"b\" : return \"\\b\";\n          case \"v\" : return \"\\u000b\";\n          case \"f\" : return \"\\f\";\n          case \"0\" : return \"\\0\";\n          case \"x\" : return String.fromCharCode(hex_bytes(2));\n          case \"u\" : return String.fromCharCode(hex_bytes(4));\n          case \"\\n\": return \"\";\n          default  : return ch;\n        }\n    };\n\n    function hex_bytes(n) {\n        var num = 0;\n        for (; n > 0; --n) {\n            var digit = parseInt(next(true), 16);\n            if (isNaN(digit))\n                parse_error(\"Invalid hex-character pattern in string\");\n            num = (num << 4) | digit;\n        }\n        return num;\n    };\n\n    function read_string() {\n        return with_eof_error(\"Unterminated string constant\", function(){\n            var quote = next(), ret = \"\";\n            for (;;) {\n                var ch = next(true);\n                if (ch == \"\\\\\") {\n                    // read OctalEscapeSequence (XXX: deprecated if \"strict mode\")\n                    // https://github.com/mishoo/UglifyJS/issues/178\n                    var octal_len = 0, first = null;\n                    ch = read_while(function(ch){\n                        if (ch >= \"0\" && ch <= \"7\") {\n                            if (!first) {\n                                first = ch;\n                                return ++octal_len;\n                            }\n                            else if (first <= \"3\" && octal_len <= 2) return ++octal_len;\n                            else if (first >= \"4\" && octal_len <= 1) return ++octal_len;\n                        }\n                        return false;\n                    });\n                    if (octal_len > 0) ch = String.fromCharCode(parseInt(ch, 8));\n                    else ch = read_escaped_char(true);\n                }\n                else if (ch == quote) break;\n                else if (ch == \"\\n\") throw EX_EOF;\n                ret += ch;\n            }\n            return token(\"string\", ret);\n        });\n    };\n\n    function read_line_comment() {\n        next();\n        var i = find(\"\\n\"), ret;\n        if (i == -1) {\n            ret = S.text.substr(S.pos);\n            S.pos = S.text.length;\n        } else {\n            ret = S.text.substring(S.pos, i);\n            S.pos = i;\n        }\n        return token(\"comment1\", ret, true);\n    };\n\n    function read_multiline_comment() {\n        next();\n        return with_eof_error(\"Unterminated multiline comment\", function(){\n            var i = find(\"*/\", true),\n            text = S.text.substring(S.pos, i);\n            S.pos = i + 2;\n            S.line += text.split(\"\\n\").length - 1;\n            S.newline_before = S.newline_before || text.indexOf(\"\\n\") >= 0;\n\n            // https://github.com/mishoo/UglifyJS/issues/#issue/100\n            if (/^@cc_on/i.test(text)) {\n                warn(\"WARNING: at line \" + S.line);\n                warn(\"*** Found \\\"conditional comment\\\": \" + text);\n                warn(\"*** UglifyJS DISCARDS ALL COMMENTS.  This means your code might no longer work properly in Internet Explorer.\");\n            }\n\n            return token(\"comment2\", text, true);\n        });\n    };\n\n    function read_name() {\n        var backslash = false, name = \"\", ch, escaped = false, hex;\n        while ((ch = peek()) != null) {\n            if (!backslash) {\n                if (ch == \"\\\\\") escaped = backslash = true, next();\n                else if (is_identifier_char(ch)) name += next();\n                else break;\n            }\n            else {\n                if (ch != \"u\") parse_error(\"Expecting UnicodeEscapeSequence -- uXXXX\");\n                ch = read_escaped_char();\n                if (!is_identifier_char(ch)) parse_error(\"Unicode char: \" + ch.charCodeAt(0) + \" is not valid in identifier\");\n                name += ch;\n                backslash = false;\n            }\n        }\n        if (HOP(KEYWORDS, name) && escaped) {\n            hex = name.charCodeAt(0).toString(16).toUpperCase();\n            name = \"\\\\u\" + \"0000\".substr(hex.length) + hex + name.slice(1);\n        }\n        return name;\n    };\n\n    function read_regexp(regexp) {\n        return with_eof_error(\"Unterminated regular expression\", function(){\n            var prev_backslash = false, ch, in_class = false;\n            while ((ch = next(true))) if (prev_backslash) {\n                regexp += \"\\\\\" + ch;\n                prev_backslash = false;\n            } else if (ch == \"[\") {\n                in_class = true;\n                regexp += ch;\n            } else if (ch == \"]\" && in_class) {\n                in_class = false;\n                regexp += ch;\n            } else if (ch == \"/\" && !in_class) {\n                break;\n            } else if (ch == \"\\\\\") {\n                prev_backslash = true;\n            } else {\n                regexp += ch;\n            }\n            var mods = read_name();\n            return token(\"regexp\", [ regexp, mods ]);\n        });\n    };\n\n    function read_operator(prefix) {\n        function grow(op) {\n            if (!peek()) return op;\n            var bigger = op + peek();\n            if (HOP(OPERATORS, bigger)) {\n                next();\n                return grow(bigger);\n            } else {\n                return op;\n            }\n        };\n        return token(\"operator\", grow(prefix || next()));\n    };\n\n    function handle_slash() {\n        next();\n        var regex_allowed = S.regex_allowed;\n        switch (peek()) {\n          case \"/\":\n            S.comments_before.push(read_line_comment());\n            S.regex_allowed = regex_allowed;\n            return next_token();\n          case \"*\":\n            S.comments_before.push(read_multiline_comment());\n            S.regex_allowed = regex_allowed;\n            return next_token();\n        }\n        return S.regex_allowed ? read_regexp(\"\") : read_operator(\"/\");\n    };\n\n    function handle_dot() {\n        next();\n        return is_digit(peek())\n            ? read_num(\".\")\n            : token(\"punc\", \".\");\n    };\n\n    function read_word() {\n        var word = read_name();\n        return !HOP(KEYWORDS, word)\n            ? token(\"name\", word)\n            : HOP(OPERATORS, word)\n            ? token(\"operator\", word)\n            : HOP(KEYWORDS_ATOM, word)\n            ? token(\"atom\", word)\n            : token(\"keyword\", word);\n    };\n\n    function with_eof_error(eof_error, cont) {\n        try {\n            return cont();\n        } catch(ex) {\n            if (ex === EX_EOF) parse_error(eof_error);\n            else throw ex;\n        }\n    };\n\n    function next_token(force_regexp) {\n        if (force_regexp != null)\n            return read_regexp(force_regexp);\n        skip_whitespace();\n        start_token();\n        var ch = peek();\n        if (!ch) return token(\"eof\");\n        if (is_digit(ch)) return read_num();\n        if (ch == '\"' || ch == \"'\") return read_string();\n        if (HOP(PUNC_CHARS, ch)) return token(\"punc\", next());\n        if (ch == \".\") return handle_dot();\n        if (ch == \"/\") return handle_slash();\n        if (HOP(OPERATOR_CHARS, ch)) return read_operator();\n        if (ch == \"\\\\\" || is_identifier_start(ch)) return read_word();\n        parse_error(\"Unexpected character '\" + ch + \"'\");\n    };\n\n    next_token.context = function(nc) {\n        if (nc) S = nc;\n        return S;\n    };\n\n    return next_token;\n\n\n}\n\nfunction qmlweb_parse($TEXT, document_type, exigent_mode) {\n  var embed_tokens = false; // embed_tokens option is not supported\n\n  var TEXT = $TEXT.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\").replace(/^\\uFEFF/, '');\n  $TEXT = qmlweb_tokenizer($TEXT, true);\n\n  // WARNING: Here the original parse() code gets embedded\n  \n\n    var S = {\n        input         : typeof $TEXT == \"string\" ? tokenizer($TEXT, true) : $TEXT,\n        token         : null,\n        prev          : null,\n        peeked        : null,\n        in_function   : 0,\n        in_directives : true,\n        in_loop       : 0,\n        labels        : []\n    };\n\n    S.token = next();\n\n    function is(type, value) {\n        return is_token(S.token, type, value);\n    };\n\n    function peek() { return S.peeked || (S.peeked = S.input()); };\n\n    function next() {\n        S.prev = S.token;\n        if (S.peeked) {\n            S.token = S.peeked;\n            S.peeked = null;\n        } else {\n            S.token = S.input();\n        }\n        S.in_directives = S.in_directives && (\n            S.token.type == \"string\" || is(\"punc\", \";\")\n        );\n        return S.token;\n    };\n\n    function prev() {\n        return S.prev;\n    };\n\n    function croak(msg, line, col, pos) {\n        var ctx = S.input.context();\n        js_error(msg,\n                 line != null ? line : ctx.tokline,\n                 col != null ? col : ctx.tokcol,\n                 pos != null ? pos : ctx.tokpos);\n    };\n\n    function token_error(token, msg) {\n        croak(msg, token.line, token.col);\n    };\n\n    function unexpected(token) {\n        if (token == null)\n            token = S.token;\n        token_error(token, \"Unexpected token: \" + token.type + \" (\" + token.value + \")\");\n    };\n\n    function expect_token(type, val) {\n        if (is(type, val)) {\n            return next();\n        }\n        token_error(S.token, \"Unexpected token \" + S.token.type + \", expected \" + type);\n    };\n\n    function expect(punc) { return expect_token(\"punc\", punc); };\n\n    function can_insert_semicolon() {\n        return !exigent_mode && (\n            S.token.nlb || is(\"eof\") || is(\"punc\", \"}\")\n        );\n    };\n\n    function semicolon() {\n        if (is(\"punc\", \";\")) next();\n        else if (!can_insert_semicolon()) unexpected();\n    };\n\n    function as() {\n        return slice(arguments);\n    };\n\n    function parenthesised() {\n        expect(\"(\");\n        var ex = expression();\n        expect(\")\");\n        return ex;\n    };\n\n    function add_tokens(str, start, end) {\n        return str instanceof NodeWithToken ? str : new NodeWithToken(str, start, end);\n    };\n\n    function maybe_embed_tokens(parser) {\n        if (embed_tokens) return function() {\n            var start = S.token;\n            var ast = parser.apply(this, arguments);\n            ast[0] = add_tokens(ast[0], start, prev());\n            return ast;\n        };\n        else return parser;\n    };\n\n    var statement = maybe_embed_tokens(function() {\n        if (is(\"operator\", \"/\") || is(\"operator\", \"/=\")) {\n            S.peeked = null;\n            S.token = S.input(S.token.value.substr(1)); // force regexp\n        }\n        switch (S.token.type) {\n          case \"string\":\n            var dir = S.in_directives, stat = simple_statement();\n            if (dir && stat[1][0] == \"string\" && !is(\"punc\", \",\"))\n                return as(\"directive\", stat[1][1]);\n            return stat;\n          case \"num\":\n          case \"regexp\":\n          case \"operator\":\n          case \"atom\":\n            return simple_statement();\n\n          case \"name\":\n            return is_token(peek(), \"punc\", \":\")\n                ? labeled_statement(prog1(S.token.value, next, next))\n                : simple_statement();\n\n          case \"punc\":\n            switch (S.token.value) {\n              case \"{\":\n                return as(\"block\", block_());\n              case \"[\":\n              case \"(\":\n                return simple_statement();\n              case \";\":\n                next();\n                return as(\"block\");\n              default:\n                unexpected();\n            }\n\n          case \"keyword\":\n            switch (prog1(S.token.value, next)) {\n              case \"break\":\n                return break_cont(\"break\");\n\n              case \"continue\":\n                return break_cont(\"continue\");\n\n              case \"debugger\":\n                semicolon();\n                return as(\"debugger\");\n\n              case \"do\":\n                return (function(body){\n                    expect_token(\"keyword\", \"while\");\n                    return as(\"do\", prog1(parenthesised, semicolon), body);\n                })(in_loop(statement));\n\n              case \"for\":\n                return for_();\n\n              case \"function\":\n                return function_(true);\n\n              case \"if\":\n                return if_();\n\n              case \"return\":\n                if (S.in_function == 0)\n                    croak(\"'return' outside of function\");\n                return as(\"return\",\n                          is(\"punc\", \";\")\n                          ? (next(), null)\n                          : can_insert_semicolon()\n                          ? null\n                          : prog1(expression, semicolon));\n\n              case \"switch\":\n                return as(\"switch\", parenthesised(), switch_block_());\n\n              case \"throw\":\n                if (S.token.nlb)\n                    croak(\"Illegal newline after 'throw'\");\n                return as(\"throw\", prog1(expression, semicolon));\n\n              case \"try\":\n                return try_();\n\n              case \"var\":\n                return prog1(var_, semicolon);\n\n              case \"const\":\n                return prog1(const_, semicolon);\n\n              case \"while\":\n                return as(\"while\", parenthesised(), in_loop(statement));\n\n              case \"with\":\n                return as(\"with\", parenthesised(), statement());\n\n              default:\n                unexpected();\n            }\n        }\n    });\n\n    function labeled_statement(label) {\n        S.labels.push(label);\n        var start = S.token, stat = statement();\n        if (exigent_mode && !HOP(STATEMENTS_WITH_LABELS, stat[0]))\n            unexpected(start);\n        S.labels.pop();\n        return as(\"label\", label, stat);\n    };\n\n    function simple_statement() {\n        return as(\"stat\", prog1(expression, semicolon));\n    };\n\n    function break_cont(type) {\n        var name;\n        if (!can_insert_semicolon()) {\n            name = is(\"name\") ? S.token.value : null;\n        }\n        if (name != null) {\n            next();\n            if (!member(name, S.labels))\n                croak(\"Label \" + name + \" without matching loop or statement\");\n        }\n        else if (S.in_loop == 0)\n            croak(type + \" not inside a loop or switch\");\n        semicolon();\n        return as(type, name);\n    };\n\n    function for_() {\n        expect(\"(\");\n        var init = null;\n        if (!is(\"punc\", \";\")) {\n            init = is(\"keyword\", \"var\")\n                ? (next(), var_(true))\n                : expression(true, true);\n            if (is(\"operator\", \"in\")) {\n                if (init[0] == \"var\" && init[1].length > 1)\n                    croak(\"Only one variable declaration allowed in for..in loop\");\n                return for_in(init);\n            }\n        }\n        return regular_for(init);\n    };\n\n    function regular_for(init) {\n        expect(\";\");\n        var test = is(\"punc\", \";\") ? null : expression();\n        expect(\";\");\n        var step = is(\"punc\", \")\") ? null : expression();\n        expect(\")\");\n        return as(\"for\", init, test, step, in_loop(statement));\n    };\n\n    function for_in(init) {\n        var lhs = init[0] == \"var\" ? as(\"name\", init[1][0]) : init;\n        next();\n        var obj = expression();\n        expect(\")\");\n        return as(\"for-in\", init, lhs, obj, in_loop(statement));\n    };\n\n    var function_ = function(in_statement) {\n        var name = is(\"name\") ? prog1(S.token.value, next) : null;\n        if (in_statement && !name)\n            unexpected();\n        expect(\"(\");\n        return as(in_statement ? \"defun\" : \"function\",\n                  name,\n                  // arguments\n                  (function(first, a){\n                      while (!is(\"punc\", \")\")) {\n                          if (first) first = false; else expect(\",\");\n                          if (!is(\"name\")) unexpected();\n                          a.push(S.token.value);\n                          next();\n                      }\n                      next();\n                      return a;\n                  })(true, []),\n                  // body\n                  (function(){\n                      ++S.in_function;\n                      var loop = S.in_loop;\n                      S.in_directives = true;\n                      S.in_loop = 0;\n                      var a = block_();\n                      --S.in_function;\n                      S.in_loop = loop;\n                      return a;\n                  })());\n    };\n\n    function if_() {\n        var cond = parenthesised(), body = statement(), belse;\n        if (is(\"keyword\", \"else\")) {\n            next();\n            belse = statement();\n        }\n        return as(\"if\", cond, body, belse);\n    };\n\n    function block_() {\n        expect(\"{\");\n        var a = [];\n        while (!is(\"punc\", \"}\")) {\n            if (is(\"eof\")) unexpected();\n            a.push(statement());\n        }\n        next();\n        return a;\n    };\n\n    var switch_block_ = curry(in_loop, function(){\n        expect(\"{\");\n        var a = [], cur = null;\n        while (!is(\"punc\", \"}\")) {\n            if (is(\"eof\")) unexpected();\n            if (is(\"keyword\", \"case\")) {\n                next();\n                cur = [];\n                a.push([ expression(), cur ]);\n                expect(\":\");\n            }\n            else if (is(\"keyword\", \"default\")) {\n                next();\n                expect(\":\");\n                cur = [];\n                a.push([ null, cur ]);\n            }\n            else {\n                if (!cur) unexpected();\n                cur.push(statement());\n            }\n        }\n        next();\n        return a;\n    });\n\n    function try_() {\n        var body = block_(), bcatch, bfinally;\n        if (is(\"keyword\", \"catch\")) {\n            next();\n            expect(\"(\");\n            if (!is(\"name\"))\n                croak(\"Name expected\");\n            var name = S.token.value;\n            next();\n            expect(\")\");\n            bcatch = [ name, block_() ];\n        }\n        if (is(\"keyword\", \"finally\")) {\n            next();\n            bfinally = block_();\n        }\n        if (!bcatch && !bfinally)\n            croak(\"Missing catch/finally blocks\");\n        return as(\"try\", body, bcatch, bfinally);\n    };\n\n    function vardefs(no_in) {\n        var a = [];\n        for (;;) {\n            if (!is(\"name\"))\n                unexpected();\n            var name = S.token.value;\n            next();\n            if (is(\"operator\", \"=\")) {\n                next();\n                a.push([ name, expression(false, no_in) ]);\n            } else {\n                a.push([ name ]);\n            }\n            if (!is(\"punc\", \",\"))\n                break;\n            next();\n        }\n        return a;\n    };\n\n    function var_(no_in) {\n        return as(\"var\", vardefs(no_in));\n    };\n\n    function const_() {\n        return as(\"const\", vardefs());\n    };\n\n    function new_() {\n        var newexp = expr_atom(false), args;\n        if (is(\"punc\", \"(\")) {\n            next();\n            args = expr_list(\")\");\n        } else {\n            args = [];\n        }\n        return subscripts(as(\"new\", newexp, args), true);\n    };\n\n    var expr_atom = maybe_embed_tokens(function(allow_calls) {\n        if (is(\"operator\", \"new\")) {\n            next();\n            return new_();\n        }\n        if (is(\"punc\")) {\n            switch (S.token.value) {\n              case \"(\":\n                next();\n                return subscripts(prog1(expression, curry(expect, \")\")), allow_calls);\n              case \"[\":\n                next();\n                return subscripts(array_(), allow_calls);\n              case \"{\":\n                next();\n                return subscripts(object_(), allow_calls);\n            }\n            unexpected();\n        }\n        if (is(\"keyword\", \"function\")) {\n            next();\n            return subscripts(function_(false), allow_calls);\n        }\n        if (HOP(ATOMIC_START_TOKEN, S.token.type)) {\n            var atom = S.token.type == \"regexp\"\n                ? as(\"regexp\", S.token.value[0], S.token.value[1])\n                : as(S.token.type, S.token.value);\n            return subscripts(prog1(atom, next), allow_calls);\n        }\n        unexpected();\n    });\n\n    function expr_list(closing, allow_trailing_comma, allow_empty) {\n        var first = true, a = [];\n        while (!is(\"punc\", closing)) {\n            if (first) first = false; else expect(\",\");\n            if (allow_trailing_comma && is(\"punc\", closing)) break;\n            if (is(\"punc\", \",\") && allow_empty) {\n                a.push([ \"atom\", \"undefined\" ]);\n            } else {\n                a.push(expression(false));\n            }\n        }\n        next();\n        return a;\n    };\n\n    function array_() {\n        return as(\"array\", expr_list(\"]\", !exigent_mode, true));\n    };\n\n    function object_() {\n        var first = true, a = [];\n        while (!is(\"punc\", \"}\")) {\n            if (first) first = false; else expect(\",\");\n            if (!exigent_mode && is(\"punc\", \"}\"))\n                // allow trailing comma\n                break;\n            var type = S.token.type;\n            var name = as_property_name();\n            if (type == \"name\" && (name == \"get\" || name == \"set\") && !is(\"punc\", \":\")) {\n                a.push([ as_name(), function_(false), name ]);\n            } else {\n                expect(\":\");\n                a.push([ name, expression(false) ]);\n            }\n        }\n        next();\n        return as(\"object\", a);\n    };\n\n    function as_property_name() {\n        switch (S.token.type) {\n          case \"num\":\n          case \"string\":\n            return prog1(S.token.value, next);\n        }\n        return as_name();\n    };\n\n    function as_name() {\n        switch (S.token.type) {\n          case \"name\":\n          case \"operator\":\n          case \"keyword\":\n          case \"atom\":\n            return prog1(S.token.value, next);\n          default:\n            unexpected();\n        }\n    };\n\n    function subscripts(expr, allow_calls) {\n        if (is(\"punc\", \".\")) {\n            next();\n            return subscripts(as(\"dot\", expr, as_name()), allow_calls);\n        }\n        if (is(\"punc\", \"[\")) {\n            next();\n            return subscripts(as(\"sub\", expr, prog1(expression, curry(expect, \"]\"))), allow_calls);\n        }\n        if (allow_calls && is(\"punc\", \"(\")) {\n            next();\n            return subscripts(as(\"call\", expr, expr_list(\")\")), true);\n        }\n        return expr;\n    };\n\n    function maybe_unary(allow_calls) {\n        if (is(\"operator\") && HOP(UNARY_PREFIX, S.token.value)) {\n            return make_unary(\"unary-prefix\",\n                              prog1(S.token.value, next),\n                              maybe_unary(allow_calls));\n        }\n        var val = expr_atom(allow_calls);\n        while (is(\"operator\") && HOP(UNARY_POSTFIX, S.token.value) && !S.token.nlb) {\n            val = make_unary(\"unary-postfix\", S.token.value, val);\n            next();\n        }\n        return val;\n    };\n\n    function make_unary(tag, op, expr) {\n        if ((op == \"++\" || op == \"--\") && !is_assignable(expr))\n            croak(\"Invalid use of \" + op + \" operator\");\n        return as(tag, op, expr);\n    };\n\n    function expr_op(left, min_prec, no_in) {\n        var op = is(\"operator\") ? S.token.value : null;\n        if (op && op == \"in\" && no_in) op = null;\n        var prec = op != null ? PRECEDENCE[op] : null;\n        if (prec != null && prec > min_prec) {\n            next();\n            var right = expr_op(maybe_unary(true), prec, no_in);\n            return expr_op(as(\"binary\", op, left, right), min_prec, no_in);\n        }\n        return left;\n    };\n\n    function expr_ops(no_in) {\n        return expr_op(maybe_unary(true), 0, no_in);\n    };\n\n    function maybe_conditional(no_in) {\n        var expr = expr_ops(no_in);\n        if (is(\"operator\", \"?\")) {\n            next();\n            var yes = expression(false);\n            expect(\":\");\n            return as(\"conditional\", expr, yes, expression(false, no_in));\n        }\n        return expr;\n    };\n\n    function is_assignable(expr) {\n        if (!exigent_mode) return true;\n        switch (expr[0]+\"\") {\n          case \"dot\":\n          case \"sub\":\n          case \"new\":\n          case \"call\":\n            return true;\n          case \"name\":\n            return expr[1] != \"this\";\n        }\n    };\n\n    function maybe_assign(no_in) {\n        var left = maybe_conditional(no_in), val = S.token.value;\n        if (is(\"operator\") && HOP(ASSIGNMENT, val)) {\n            if (is_assignable(left)) {\n                next();\n                return as(\"assign\", ASSIGNMENT[val], left, maybe_assign(no_in));\n            }\n            croak(\"Invalid assignment\");\n        }\n        return left;\n    };\n\n    var expression = maybe_embed_tokens(function(commas, no_in) {\n        if (arguments.length == 0)\n            commas = true;\n        var expr = maybe_assign(no_in);\n        if (commas && is(\"punc\", \",\")) {\n            next();\n            return as(\"seq\", expr, expression(true, no_in));\n        }\n        return expr;\n    });\n\n    function in_loop(cont) {\n        try {\n            ++S.in_loop;\n            return cont();\n        } finally {\n            --S.in_loop;\n        }\n    };\n\n    \n  // NOTE: Don't insert spaces between arguments!\n\n  // Override UglifyJS methods\n\n  croak = function(msg, line, col, pos) {\n    var ctx = S.input.context();\n    throw new QMLParseError(msg,\n      line != null ? line : ctx.tokline,\n      col != null ? col : ctx.tokcol,\n      pos != null ? pos : ctx.tokpos,\n      TEXT\n    );\n  };\n\n  expect_token = function(type, val) {\n    if (is(type, val)) {\n      return next();\n    }\n    token_error(S.token, \"Unexpected token \" + S.token.type + \" \" + S.token.val + \", expected \" + type + \" \" + val);\n  };\n\n  var statement_js = statement;\n  statement = function() {\n    var in_qmlpropdef = !!statement.in_qmlpropdef;\n    statement.in_qmlpropdef = false;\n    switch (S.token.type) {\n    case \"punc\":\n      switch (S.token.value) {\n      case \".\":\n        return is_token(peek(), \"name\", \"pragma\") ? qml_pragma_statement() : unexpected();\n      }\n    case \"keyword\":\n      switch (S.token.value) {\n      case \"function\":\n        if (in_qmlpropdef) {\n          next();\n          return function_(false);\n        }\n      }\n    }\n    return statement_js();\n  };\n\n  array_ = function() {\n    var from = S.token.pos;\n    var stat = expr_list(\"]\", !exigent_mode, true);\n    var to = S.token.pos;\n    return as(\"array\", stat, \"[\" + TEXT.substr(from, to - from));\n  };\n\n  expression = function(commas, no_in) {\n    if (arguments.length == 0)\n      commas = true;\n    var expr = maybe_qmlelem(no_in);\n    if (commas && is(\"punc\", \",\")) {\n      next();\n      return as(\"seq\", expr, expression(true, no_in));\n    }\n    return expr;\n  };\n\n  // QML-specific methods\n\n  function as_statement() {\n    var res = slice(arguments);\n    S.in_function++;\n    var start = S.token.pos;\n    res.push(statement());\n    var end = S.token.pos;\n    S.in_function--;\n    res.push(TEXT.substr(start, end - start));\n    return res;\n  }\n\n  function maybe_qmlelem(no_in) {\n    var expr = maybe_assign(no_in);\n    if (is(\"punc\", \"{\"))\n      return as(\"qmlelem\", expr[1], undefined, qmlblock());\n    return expr;\n  }\n\n  function qml_is_element(str) {\n    return str[0].toUpperCase() == str[0];\n  }\n\n  function qmlblock() {\n    expect(\"{\");\n    var a = [];\n    while (!is(\"punc\", \"}\")) {\n      if (is(\"eof\"))\n        unexpected();\n      a.push(qmlstatement());\n    }\n    expect(\"}\");\n    return a;\n  }\n\n  function qmlpropdef() {\n    var type = S.token.value;\n    next();\n    var name = S.token.value;\n    next();\n    if (type == \"alias\") {\n      expect(\":\");\n      if (!is(\"name\"))\n        unexpected();\n      var objName = S.token.value;\n      next();\n      if (is(\"punc\", \".\")) {\n        next();\n        if (!is(\"name\"))\n          unexpected();\n        var propName = S.token.value;\n        next();\n      }\n      return as(\"qmlaliasdef\", name, objName, propName);\n    }\n    if (is(\"punc\", \":\")) {\n      next();\n      statement.in_qmlpropdef = true;\n      return as_statement(\"qmlpropdef\", name, type);\n    } else if (is(\"punc\", \";\"))\n      next();\n    return as(\"qmlpropdef\", name, type);\n  }\n\n  function qmldefaultprop() {\n    next();\n    expect_token(\"name\", \"property\");\n    return as(\"qmldefaultprop\", qmlpropdef());\n  }\n\n  function qmlsignaldef() {\n    var name = S.token.value;\n    next();\n    var args = [];\n    if (is(\"punc\", \"(\")) {\n      next();\n      var first = true;\n      while (!is(\"punc\", \")\")) {\n        if (first)\n          first = false;\n        else\n          expect(\",\");\n        if (!is(\"name\") && !is('keyword', 'var'))\n          unexpected();\n        var type = S.token.value;\n        next();\n        if (!is(\"name\"))\n          unexpected();\n        args.push({ type: type, name: S.token.value });\n        next();\n      }\n      next();\n    }\n    if (is(\"punc\", \";\"))\n      next();\n    return as(\"qmlsignaldef\", name, args);\n  }\n\n  function qmlstatement() {\n    if (is(\"keyword\", \"function\")) {\n      var from = S.token.pos;\n      next();\n      var stat = function_(true);\n      var to = S.token.pos;\n      var name = stat[1];\n      return as(\"qmlmethod\", name, stat, TEXT.substr(from, to - from));\n    } else if (is(\"name\", \"signal\")) {\n      next();\n      if (is(\"punc\", \":\")) {\n        next();\n        return as_statement(\"qmlprop\", \"signal\");\n      } else {\n        return qmlsignaldef();\n      }\n    } else if (S.token.type == \"name\") {\n      var propname = S.token.value;\n      next();\n      if (propname == \"property\" && (S.token.type == \"name\" || S.token.value == \"var\")) {\n        return qmlpropdef();\n      } else if (qml_is_element(propname) && !is(\"punc\", \".\")) {\n        // Element\n        var onProp;\n        if (is(\"name\", \"on\")) {\n          next();\n          onProp = S.token.value;\n          next();\n        }\n        return as(\"qmlelem\", propname, onProp, qmlblock());\n      } else if (is(\"punc\", \".\")) { // property statement\n        // anchors, fonts etc, a.b: statement;\n        // Can also be Component.onCompleted: ...\n        // Assume only one subproperty\n        next();\n        var subname = S.token.value;\n        next();\n        /* Check for ModuleQualifier.QMLElement */\n        if (qml_is_element(subname)) {\n          return as(\"qmlelem\", propname + \".\" + subname, undefined, qmlblock());\n        }\n        expect(\":\");\n        return as_statement(\"qmlobjdef\", propname, subname);\n      } else if (is(\"punc\", \"{\")) {\n        return as(\"qmlobj\", propname, qmlblock());\n      } else {\n        // Evaluatable item\n        expect(\":\");\n        return as_statement(\"qmlprop\", propname);\n      }\n    } else if (is(\"keyword\", \"default\")) {\n      return qmldefaultprop();\n    } else {\n      todo();\n    }\n  }\n\n  function qml_pragma_statement() {\n    next();\n    next();\n    var pragma = S.token.value;\n    next();\n    return as(\"qmlpragma\", pragma);\n  }\n\n  function qmlimport() {\n    // todo\n    next();\n    var moduleName = S.token.value;\n    var isDottedNotation = S.token.type == \"name\";\n    next();\n\n    while (is(\"punc\", \".\")) {\n      next();\n      moduleName += \".\" + S.token.value;\n      next();\n    }\n    if (is(\"num\")) {\n      var version = S.token.value;\n      next();\n    }\n    var namespace = \"\";\n    if (is(\"name\", \"as\")) {\n      next();\n      namespace = S.token.value;\n      next();\n    }\n    return as(\"qmlimport\", moduleName, version, namespace, isDottedNotation);\n  }\n\n  function qmldocument() {\n    var imports = [];\n    while (is(\"name\", \"import\")) {\n      imports.push(qmlimport());\n    }\n    var root = qmlstatement();\n    if (!is(\"eof\"))\n      unexpected();\n    return as(\"toplevel\", imports, root);\n  }\n\n  function jsdocument() {\n    var statements = [];\n    while (!is(\"eof\")) {\n      statements.push(statement());\n    }\n    return as(\"jsresource\", statements);\n  }\n\n  function amIn(s) {\n    console && console.log(s, clone(S), S.token.type, S.token.value);\n  }\n\n  function todo() {\n    amIn(\"todo parse:\");\n    next();\n  }\n\n  if (document_type === qmlweb_parse.JSResource) {\n    return jsdocument();\n  } else {\n    return qmldocument();\n  }\n}\n\nqmlweb_parse.nowParsingFile = ''; // TODO: make a parameter of qmlweb_parse\nqmlweb_parse.QMLDocument = 1;\nqmlweb_parse.JSResource = 2;\n\nfunction qmlweb_jsparse(source) {\n  var obj = { exports: [], source: source };\n  var AST_Tree = qmlweb_parse(source, qmlweb_parse.JSResource);\n  var main_scope = AST_Tree[1];\n\n  for (var i = 0 ; i < main_scope.length ; ++i) {\n    var item = main_scope[i];\n\n    switch (item[0]) {\n      case \"var\":\n        obj.exports.push(item[1][0][0]);\n        break ;\n      case \"defun\":\n        obj.exports.push(item[1]);\n        break ;\n    }\n  }\n  return obj;\n}\n\nexports.qmlweb_parse = qmlweb_parse;\nexports.qmlweb_jsparse = qmlweb_jsparse;\n}(typeof exports !== 'undefined' ? exports : window));\n\n\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n\n  This version is suitable for Node.js.  With minimal changes (the\n  exports stuff) it should work on any JS platform.\n\n  This file contains the tokenizer/parser.  It is a port to JavaScript\n  of parse-js [1], a JavaScript parser library written in Common Lisp\n  by Marijn Haverbeke.  Thank you Marijn!\n\n  [1] http://marijn.haverbeke.nl/parse-js/\n\n  Exported functions:\n\n    - tokenizer(code) -- returns a function.  Call the returned\n      function to fetch the next token.\n\n    - parse(code) -- returns an AST of the given JavaScript code.\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>\n    Based on parse-js (http://marijn.haverbeke.nl/parse-js/).\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n/* -----[ Tokenizer (constants) ]----- */\n\nvar KEYWORDS = array_to_hash([\n    \"break\",\n    \"case\",\n    \"catch\",\n    \"const\",\n    \"continue\",\n    \"debugger\",\n    \"default\",\n    \"delete\",\n    \"do\",\n    \"else\",\n    \"finally\",\n    \"for\",\n    \"function\",\n    \"if\",\n    \"in\",\n    \"instanceof\",\n    \"new\",\n    \"return\",\n    \"switch\",\n    \"throw\",\n    \"try\",\n    \"typeof\",\n    \"var\",\n    \"void\",\n    \"while\",\n    \"with\"\n]);\n\nvar RESERVED_WORDS = array_to_hash([\n    \"abstract\",\n    \"boolean\",\n    \"byte\",\n    \"char\",\n    \"class\",\n    \"double\",\n    \"enum\",\n    \"export\",\n    \"extends\",\n    \"final\",\n    \"float\",\n    \"goto\",\n    \"implements\",\n    \"import\",\n    \"int\",\n    \"interface\",\n    \"long\",\n    \"native\",\n    \"package\",\n    \"private\",\n    \"protected\",\n    \"public\",\n    \"short\",\n    \"static\",\n    \"super\",\n    \"synchronized\",\n    \"throws\",\n    \"transient\",\n    \"volatile\"\n]);\n\nvar KEYWORDS_BEFORE_EXPRESSION = array_to_hash([\n    \"return\",\n    \"new\",\n    \"delete\",\n    \"throw\",\n    \"else\",\n    \"case\"\n]);\n\nvar KEYWORDS_ATOM = array_to_hash([\n    \"false\",\n    \"null\",\n    \"true\",\n    \"undefined\"\n]);\n\nvar OPERATOR_CHARS = array_to_hash(characters(\"+-*&%=<>!?|~^\"));\n\nvar RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;\nvar RE_OCT_NUMBER = /^0[0-7]+$/;\nvar RE_DEC_NUMBER = /^\\d*\\.?\\d*(?:e[+-]?\\d*(?:\\d\\.?|\\.?\\d)\\d*)?$/i;\n\nvar OPERATORS = array_to_hash([\n    \"in\",\n    \"instanceof\",\n    \"typeof\",\n    \"new\",\n    \"void\",\n    \"delete\",\n    \"++\",\n    \"--\",\n    \"+\",\n    \"-\",\n    \"!\",\n    \"~\",\n    \"&\",\n    \"|\",\n    \"^\",\n    \"*\",\n    \"/\",\n    \"%\",\n    \">>\",\n    \"<<\",\n    \">>>\",\n    \"<\",\n    \">\",\n    \"<=\",\n    \">=\",\n    \"==\",\n    \"===\",\n    \"!=\",\n    \"!==\",\n    \"?\",\n    \"=\",\n    \"+=\",\n    \"-=\",\n    \"/=\",\n    \"*=\",\n    \"%=\",\n    \">>=\",\n    \"<<=\",\n    \">>>=\",\n    \"|=\",\n    \"^=\",\n    \"&=\",\n    \"&&\",\n    \"||\"\n]);\n\nvar WHITESPACE_CHARS = array_to_hash(characters(\" \\u00a0\\n\\r\\t\\f\\u000b\\u200b\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\uFEFF\"));\n\nvar PUNC_BEFORE_EXPRESSION = array_to_hash(characters(\"[{(,.;:\"));\n\nvar PUNC_CHARS = array_to_hash(characters(\"[]{}(),;:\"));\n\nvar REGEXP_MODIFIERS = array_to_hash(characters(\"gmsiy\"));\n\n/* -----[ Tokenizer ]----- */\n\nvar UNICODE = {  // Unicode 6.1\n    letter: new RegExp(\"[\\\\u0041-\\\\u005A\\\\u0061-\\\\u007A\\\\u00AA\\\\u00B5\\\\u00BA\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037A-\\\\u037D\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03F5\\\\u03F7-\\\\u0481\\\\u048A-\\\\u0527\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0620-\\\\u064A\\\\u066E\\\\u066F\\\\u0671-\\\\u06D3\\\\u06D5\\\\u06E5\\\\u06E6\\\\u06EE\\\\u06EF\\\\u06FA-\\\\u06FC\\\\u06FF\\\\u0710\\\\u0712-\\\\u072F\\\\u074D-\\\\u07A5\\\\u07B1\\\\u07CA-\\\\u07EA\\\\u07F4\\\\u07F5\\\\u07FA\\\\u0800-\\\\u0815\\\\u081A\\\\u0824\\\\u0828\\\\u0840-\\\\u0858\\\\u08A0\\\\u08A2-\\\\u08AC\\\\u0904-\\\\u0939\\\\u093D\\\\u0950\\\\u0958-\\\\u0961\\\\u0971-\\\\u0977\\\\u0979-\\\\u097F\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09BD\\\\u09CE\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0\\\\u09F1\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AD0\\\\u0AE0\\\\u0AE1\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B35-\\\\u0B39\\\\u0B3D\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B71\\\\u0B83\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB9\\\\u0BD0\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C33\\\\u0C35-\\\\u0C39\\\\u0C3D\\\\u0C58\\\\u0C59\\\\u0C60\\\\u0C61\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CBD\\\\u0CDE\\\\u0CE0\\\\u0CE1\\\\u0CF1\\\\u0CF2\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D3A\\\\u0D3D\\\\u0D4E\\\\u0D60\\\\u0D61\\\\u0D7A-\\\\u0D7F\\\\u0D85-\\\\u0D96\\\\u0D9A-\\\\u0DB1\\\\u0DB3-\\\\u0DBB\\\\u0DBD\\\\u0DC0-\\\\u0DC6\\\\u0E01-\\\\u0E30\\\\u0E32\\\\u0E33\\\\u0E40-\\\\u0E46\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD-\\\\u0EB0\\\\u0EB2\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0EC6\\\\u0EDC-\\\\u0EDF\\\\u0F00\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F6C\\\\u0F88-\\\\u0F8C\\\\u1000-\\\\u102A\\\\u103F\\\\u1050-\\\\u1055\\\\u105A-\\\\u105D\\\\u1061\\\\u1065\\\\u1066\\\\u106E-\\\\u1070\\\\u1075-\\\\u1081\\\\u108E\\\\u10A0-\\\\u10C5\\\\u10C7\\\\u10CD\\\\u10D0-\\\\u10FA\\\\u10FC-\\\\u1248\\\\u124A-\\\\u124D\\\\u1250-\\\\u1256\\\\u1258\\\\u125A-\\\\u125D\\\\u1260-\\\\u1288\\\\u128A-\\\\u128D\\\\u1290-\\\\u12B0\\\\u12B2-\\\\u12B5\\\\u12B8-\\\\u12BE\\\\u12C0\\\\u12C2-\\\\u12C5\\\\u12C8-\\\\u12D6\\\\u12D8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135A\\\\u1380-\\\\u138F\\\\u13A0-\\\\u13F4\\\\u1401-\\\\u166C\\\\u166F-\\\\u167F\\\\u1681-\\\\u169A\\\\u16A0-\\\\u16EA\\\\u16EE-\\\\u16F0\\\\u1700-\\\\u170C\\\\u170E-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176C\\\\u176E-\\\\u1770\\\\u1780-\\\\u17B3\\\\u17D7\\\\u17DC\\\\u1820-\\\\u1877\\\\u1880-\\\\u18A8\\\\u18AA\\\\u18B0-\\\\u18F5\\\\u1900-\\\\u191C\\\\u1950-\\\\u196D\\\\u1970-\\\\u1974\\\\u1980-\\\\u19AB\\\\u19C1-\\\\u19C7\\\\u1A00-\\\\u1A16\\\\u1A20-\\\\u1A54\\\\u1AA7\\\\u1B05-\\\\u1B33\\\\u1B45-\\\\u1B4B\\\\u1B83-\\\\u1BA0\\\\u1BAE\\\\u1BAF\\\\u1BBA-\\\\u1BE5\\\\u1C00-\\\\u1C23\\\\u1C4D-\\\\u1C4F\\\\u1C5A-\\\\u1C7D\\\\u1CE9-\\\\u1CEC\\\\u1CEE-\\\\u1CF1\\\\u1CF5\\\\u1CF6\\\\u1D00-\\\\u1DBF\\\\u1E00-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u2071\\\\u207F\\\\u2090-\\\\u209C\\\\u2102\\\\u2107\\\\u210A-\\\\u2113\\\\u2115\\\\u2119-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u212D\\\\u212F-\\\\u2139\\\\u213C-\\\\u213F\\\\u2145-\\\\u2149\\\\u214E\\\\u2160-\\\\u2188\\\\u2C00-\\\\u2C2E\\\\u2C30-\\\\u2C5E\\\\u2C60-\\\\u2CE4\\\\u2CEB-\\\\u2CEE\\\\u2CF2\\\\u2CF3\\\\u2D00-\\\\u2D25\\\\u2D27\\\\u2D2D\\\\u2D30-\\\\u2D67\\\\u2D6F\\\\u2D80-\\\\u2D96\\\\u2DA0-\\\\u2DA6\\\\u2DA8-\\\\u2DAE\\\\u2DB0-\\\\u2DB6\\\\u2DB8-\\\\u2DBE\\\\u2DC0-\\\\u2DC6\\\\u2DC8-\\\\u2DCE\\\\u2DD0-\\\\u2DD6\\\\u2DD8-\\\\u2DDE\\\\u2E2F\\\\u3005-\\\\u3007\\\\u3021-\\\\u3029\\\\u3031-\\\\u3035\\\\u3038-\\\\u303C\\\\u3041-\\\\u3096\\\\u309D-\\\\u309F\\\\u30A1-\\\\u30FA\\\\u30FC-\\\\u30FF\\\\u3105-\\\\u312D\\\\u3131-\\\\u318E\\\\u31A0-\\\\u31BA\\\\u31F0-\\\\u31FF\\\\u3400-\\\\u4DB5\\\\u4E00-\\\\u9FCC\\\\uA000-\\\\uA48C\\\\uA4D0-\\\\uA4FD\\\\uA500-\\\\uA60C\\\\uA610-\\\\uA61F\\\\uA62A\\\\uA62B\\\\uA640-\\\\uA66E\\\\uA67F-\\\\uA697\\\\uA6A0-\\\\uA6EF\\\\uA717-\\\\uA71F\\\\uA722-\\\\uA788\\\\uA78B-\\\\uA78E\\\\uA790-\\\\uA793\\\\uA7A0-\\\\uA7AA\\\\uA7F8-\\\\uA801\\\\uA803-\\\\uA805\\\\uA807-\\\\uA80A\\\\uA80C-\\\\uA822\\\\uA840-\\\\uA873\\\\uA882-\\\\uA8B3\\\\uA8F2-\\\\uA8F7\\\\uA8FB\\\\uA90A-\\\\uA925\\\\uA930-\\\\uA946\\\\uA960-\\\\uA97C\\\\uA984-\\\\uA9B2\\\\uA9CF\\\\uAA00-\\\\uAA28\\\\uAA40-\\\\uAA42\\\\uAA44-\\\\uAA4B\\\\uAA60-\\\\uAA76\\\\uAA7A\\\\uAA80-\\\\uAAAF\\\\uAAB1\\\\uAAB5\\\\uAAB6\\\\uAAB9-\\\\uAABD\\\\uAAC0\\\\uAAC2\\\\uAADB-\\\\uAADD\\\\uAAE0-\\\\uAAEA\\\\uAAF2-\\\\uAAF4\\\\uAB01-\\\\uAB06\\\\uAB09-\\\\uAB0E\\\\uAB11-\\\\uAB16\\\\uAB20-\\\\uAB26\\\\uAB28-\\\\uAB2E\\\\uABC0-\\\\uABE2\\\\uAC00-\\\\uD7A3\\\\uD7B0-\\\\uD7C6\\\\uD7CB-\\\\uD7FB\\\\uF900-\\\\uFA6D\\\\uFA70-\\\\uFAD9\\\\uFB00-\\\\uFB06\\\\uFB13-\\\\uFB17\\\\uFB1D\\\\uFB1F-\\\\uFB28\\\\uFB2A-\\\\uFB36\\\\uFB38-\\\\uFB3C\\\\uFB3E\\\\uFB40\\\\uFB41\\\\uFB43\\\\uFB44\\\\uFB46-\\\\uFBB1\\\\uFBD3-\\\\uFD3D\\\\uFD50-\\\\uFD8F\\\\uFD92-\\\\uFDC7\\\\uFDF0-\\\\uFDFB\\\\uFE70-\\\\uFE74\\\\uFE76-\\\\uFEFC\\\\uFF21-\\\\uFF3A\\\\uFF41-\\\\uFF5A\\\\uFF66-\\\\uFFBE\\\\uFFC2-\\\\uFFC7\\\\uFFCA-\\\\uFFCF\\\\uFFD2-\\\\uFFD7\\\\uFFDA-\\\\uFFDC]\"),\n    combining_mark: new RegExp(\"[\\\\u0300-\\\\u036F\\\\u0483-\\\\u0487\\\\u0591-\\\\u05BD\\\\u05BF\\\\u05C1\\\\u05C2\\\\u05C4\\\\u05C5\\\\u05C7\\\\u0610-\\\\u061A\\\\u064B-\\\\u065F\\\\u0670\\\\u06D6-\\\\u06DC\\\\u06DF-\\\\u06E4\\\\u06E7\\\\u06E8\\\\u06EA-\\\\u06ED\\\\u0711\\\\u0730-\\\\u074A\\\\u07A6-\\\\u07B0\\\\u07EB-\\\\u07F3\\\\u0816-\\\\u0819\\\\u081B-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082D\\\\u0859-\\\\u085B\\\\u08E4-\\\\u08FE\\\\u0900-\\\\u0903\\\\u093A-\\\\u093C\\\\u093E-\\\\u094F\\\\u0951-\\\\u0957\\\\u0962\\\\u0963\\\\u0981-\\\\u0983\\\\u09BC\\\\u09BE-\\\\u09C4\\\\u09C7\\\\u09C8\\\\u09CB-\\\\u09CD\\\\u09D7\\\\u09E2\\\\u09E3\\\\u0A01-\\\\u0A03\\\\u0A3C\\\\u0A3E-\\\\u0A42\\\\u0A47\\\\u0A48\\\\u0A4B-\\\\u0A4D\\\\u0A51\\\\u0A70\\\\u0A71\\\\u0A75\\\\u0A81-\\\\u0A83\\\\u0ABC\\\\u0ABE-\\\\u0AC5\\\\u0AC7-\\\\u0AC9\\\\u0ACB-\\\\u0ACD\\\\u0AE2\\\\u0AE3\\\\u0B01-\\\\u0B03\\\\u0B3C\\\\u0B3E-\\\\u0B44\\\\u0B47\\\\u0B48\\\\u0B4B-\\\\u0B4D\\\\u0B56\\\\u0B57\\\\u0B62\\\\u0B63\\\\u0B82\\\\u0BBE-\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCD\\\\u0BD7\\\\u0C01-\\\\u0C03\\\\u0C3E-\\\\u0C44\\\\u0C46-\\\\u0C48\\\\u0C4A-\\\\u0C4D\\\\u0C55\\\\u0C56\\\\u0C62\\\\u0C63\\\\u0C82\\\\u0C83\\\\u0CBC\\\\u0CBE-\\\\u0CC4\\\\u0CC6-\\\\u0CC8\\\\u0CCA-\\\\u0CCD\\\\u0CD5\\\\u0CD6\\\\u0CE2\\\\u0CE3\\\\u0D02\\\\u0D03\\\\u0D3E-\\\\u0D44\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4D\\\\u0D57\\\\u0D62\\\\u0D63\\\\u0D82\\\\u0D83\\\\u0DCA\\\\u0DCF-\\\\u0DD4\\\\u0DD6\\\\u0DD8-\\\\u0DDF\\\\u0DF2\\\\u0DF3\\\\u0E31\\\\u0E34-\\\\u0E3A\\\\u0E47-\\\\u0E4E\\\\u0EB1\\\\u0EB4-\\\\u0EB9\\\\u0EBB\\\\u0EBC\\\\u0EC8-\\\\u0ECD\\\\u0F18\\\\u0F19\\\\u0F35\\\\u0F37\\\\u0F39\\\\u0F3E\\\\u0F3F\\\\u0F71-\\\\u0F84\\\\u0F86\\\\u0F87\\\\u0F8D-\\\\u0F97\\\\u0F99-\\\\u0FBC\\\\u0FC6\\\\u102B-\\\\u103E\\\\u1056-\\\\u1059\\\\u105E-\\\\u1060\\\\u1062-\\\\u1064\\\\u1067-\\\\u106D\\\\u1071-\\\\u1074\\\\u1082-\\\\u108D\\\\u108F\\\\u109A-\\\\u109D\\\\u135D-\\\\u135F\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17B4-\\\\u17D3\\\\u17DD\\\\u180B-\\\\u180D\\\\u18A9\\\\u1920-\\\\u192B\\\\u1930-\\\\u193B\\\\u19B0-\\\\u19C0\\\\u19C8\\\\u19C9\\\\u1A17-\\\\u1A1B\\\\u1A55-\\\\u1A5E\\\\u1A60-\\\\u1A7C\\\\u1A7F\\\\u1B00-\\\\u1B04\\\\u1B34-\\\\u1B44\\\\u1B6B-\\\\u1B73\\\\u1B80-\\\\u1B82\\\\u1BA1-\\\\u1BAD\\\\u1BE6-\\\\u1BF3\\\\u1C24-\\\\u1C37\\\\u1CD0-\\\\u1CD2\\\\u1CD4-\\\\u1CE8\\\\u1CED\\\\u1CF2-\\\\u1CF4\\\\u1DC0-\\\\u1DE6\\\\u1DFC-\\\\u1DFF\\\\u20D0-\\\\u20DC\\\\u20E1\\\\u20E5-\\\\u20F0\\\\u2CEF-\\\\u2CF1\\\\u2D7F\\\\u2DE0-\\\\u2DFF\\\\u302A-\\\\u302F\\\\u3099\\\\u309A\\\\uA66F\\\\uA674-\\\\uA67D\\\\uA69F\\\\uA6F0\\\\uA6F1\\\\uA802\\\\uA806\\\\uA80B\\\\uA823-\\\\uA827\\\\uA880\\\\uA881\\\\uA8B4-\\\\uA8C4\\\\uA8E0-\\\\uA8F1\\\\uA926-\\\\uA92D\\\\uA947-\\\\uA953\\\\uA980-\\\\uA983\\\\uA9B3-\\\\uA9C0\\\\uAA29-\\\\uAA36\\\\uAA43\\\\uAA4C\\\\uAA4D\\\\uAA7B\\\\uAAB0\\\\uAAB2-\\\\uAAB4\\\\uAAB7\\\\uAAB8\\\\uAABE\\\\uAABF\\\\uAAC1\\\\uAAEB-\\\\uAAEF\\\\uAAF5\\\\uAAF6\\\\uABE3-\\\\uABEA\\\\uABEC\\\\uABED\\\\uFB1E\\\\uFE00-\\\\uFE0F\\\\uFE20-\\\\uFE26]\"),\n    connector_punctuation: new RegExp(\"[\\\\u005F\\\\u203F\\\\u2040\\\\u2054\\\\uFE33\\\\uFE34\\\\uFE4D-\\\\uFE4F\\\\uFF3F]\"),\n    digit: new RegExp(\"[\\\\u0030-\\\\u0039\\\\u0660-\\\\u0669\\\\u06F0-\\\\u06F9\\\\u07C0-\\\\u07C9\\\\u0966-\\\\u096F\\\\u09E6-\\\\u09EF\\\\u0A66-\\\\u0A6F\\\\u0AE6-\\\\u0AEF\\\\u0B66-\\\\u0B6F\\\\u0BE6-\\\\u0BEF\\\\u0C66-\\\\u0C6F\\\\u0CE6-\\\\u0CEF\\\\u0D66-\\\\u0D6F\\\\u0E50-\\\\u0E59\\\\u0ED0-\\\\u0ED9\\\\u0F20-\\\\u0F29\\\\u1040-\\\\u1049\\\\u1090-\\\\u1099\\\\u17E0-\\\\u17E9\\\\u1810-\\\\u1819\\\\u1946-\\\\u194F\\\\u19D0-\\\\u19D9\\\\u1A80-\\\\u1A89\\\\u1A90-\\\\u1A99\\\\u1B50-\\\\u1B59\\\\u1BB0-\\\\u1BB9\\\\u1C40-\\\\u1C49\\\\u1C50-\\\\u1C59\\\\uA620-\\\\uA629\\\\uA8D0-\\\\uA8D9\\\\uA900-\\\\uA909\\\\uA9D0-\\\\uA9D9\\\\uAA50-\\\\uAA59\\\\uABF0-\\\\uABF9\\\\uFF10-\\\\uFF19]\")\n};\n\nfunction is_letter(ch) {\n    return UNICODE.letter.test(ch);\n};\n\nfunction is_digit(ch) {\n    ch = ch.charCodeAt(0);\n    return ch >= 48 && ch <= 57;\n};\n\nfunction is_unicode_digit(ch) {\n    return UNICODE.digit.test(ch);\n}\n\nfunction is_alphanumeric_char(ch) {\n    return is_digit(ch) || is_letter(ch);\n};\n\nfunction is_unicode_combining_mark(ch) {\n    return UNICODE.combining_mark.test(ch);\n};\n\nfunction is_unicode_connector_punctuation(ch) {\n    return UNICODE.connector_punctuation.test(ch);\n};\n\nfunction is_identifier_start(ch) {\n    return ch == \"$\" || ch == \"_\" || is_letter(ch);\n};\n\nfunction is_identifier_char(ch) {\n    return is_identifier_start(ch)\n        || is_unicode_combining_mark(ch)\n        || is_unicode_digit(ch)\n        || is_unicode_connector_punctuation(ch)\n        || ch == \"\\u200c\" // zero-width non-joiner <ZWNJ>\n        || ch == \"\\u200d\" // zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)\n    ;\n};\n\nfunction parse_js_number(num) {\n    if (RE_HEX_NUMBER.test(num)) {\n        return parseInt(num.substr(2), 16);\n    } else if (RE_OCT_NUMBER.test(num)) {\n        return parseInt(num.substr(1), 8);\n    } else if (RE_DEC_NUMBER.test(num)) {\n        return parseFloat(num);\n    }\n};\n\nfunction JS_Parse_Error(message, line, col, pos) {\n    this.message = message;\n    this.line = line + 1;\n    this.col = col + 1;\n    this.pos = pos + 1;\n    this.stack = new Error().stack;\n};\n\nJS_Parse_Error.prototype.toString = function() {\n    return this.message + \" (line: \" + this.line + \", col: \" + this.col + \", pos: \" + this.pos + \")\" + \"\\n\\n\" + this.stack;\n};\n\nfunction js_error(message, line, col, pos) {\n    throw new JS_Parse_Error(message, line, col, pos);\n};\n\nfunction is_token(token, type, val) {\n    return token.type == type && (val == null || token.value == val);\n};\n\nvar EX_EOF = {};\n\nfunction tokenizer($TEXT) {\n\n    var S = {\n        text            : $TEXT.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\").replace(/^\\uFEFF/, ''),\n        pos             : 0,\n        tokpos          : 0,\n        line            : 0,\n        tokline         : 0,\n        col             : 0,\n        tokcol          : 0,\n        newline_before  : false,\n        regex_allowed   : false,\n        comments_before : []\n    };\n\n    function peek() { return S.text.charAt(S.pos); };\n\n    function next(signal_eof, in_string) {\n        var ch = S.text.charAt(S.pos++);\n        if (signal_eof && !ch)\n            throw EX_EOF;\n        if (ch == \"\\n\") {\n            S.newline_before = S.newline_before || !in_string;\n            ++S.line;\n            S.col = 0;\n        } else {\n            ++S.col;\n        }\n        return ch;\n    };\n\n    function eof() {\n        return !S.peek();\n    };\n\n    function find(what, signal_eof) {\n        var pos = S.text.indexOf(what, S.pos);\n        if (signal_eof && pos == -1) throw EX_EOF;\n        return pos;\n    };\n\n    function start_token() {\n        S.tokline = S.line;\n        S.tokcol = S.col;\n        S.tokpos = S.pos;\n    };\n\n    function token(type, value, is_comment) {\n        S.regex_allowed = ((type == \"operator\" && !HOP(UNARY_POSTFIX, value)) ||\n                           (type == \"keyword\" && HOP(KEYWORDS_BEFORE_EXPRESSION, value)) ||\n                           (type == \"punc\" && HOP(PUNC_BEFORE_EXPRESSION, value)));\n        var ret = {\n            type   : type,\n            value  : value,\n            line   : S.tokline,\n            col    : S.tokcol,\n            pos    : S.tokpos,\n            endpos : S.pos,\n            nlb    : S.newline_before\n        };\n        if (!is_comment) {\n            ret.comments_before = S.comments_before;\n            S.comments_before = [];\n            // make note of any newlines in the comments that came before\n            for (var i = 0, len = ret.comments_before.length; i < len; i++) {\n                ret.nlb = ret.nlb || ret.comments_before[i].nlb;\n            }\n        }\n        S.newline_before = false;\n        return ret;\n    };\n\n    function skip_whitespace() {\n        while (HOP(WHITESPACE_CHARS, peek()))\n            next();\n    };\n\n    function read_while(pred) {\n        var ret = \"\", ch = peek(), i = 0;\n        while (ch && pred(ch, i++)) {\n            ret += next();\n            ch = peek();\n        }\n        return ret;\n    };\n\n    function parse_error(err) {\n        js_error(err, S.tokline, S.tokcol, S.tokpos);\n    };\n\n    function read_num(prefix) {\n        var has_e = false, after_e = false, has_x = false, has_dot = prefix == \".\";\n        var num = read_while(function(ch, i){\n            if (ch == \"x\" || ch == \"X\") {\n                if (has_x) return false;\n                return has_x = true;\n            }\n            if (!has_x && (ch == \"E\" || ch == \"e\")) {\n                if (has_e) return false;\n                return has_e = after_e = true;\n            }\n            if (ch == \"-\") {\n                if (after_e || (i == 0 && !prefix)) return true;\n                return false;\n            }\n            if (ch == \"+\") return after_e;\n            after_e = false;\n            if (ch == \".\") {\n                if (!has_dot && !has_x && !has_e)\n                    return has_dot = true;\n                return false;\n            }\n            return is_alphanumeric_char(ch);\n        });\n        if (prefix)\n            num = prefix + num;\n        var valid = parse_js_number(num);\n        if (!isNaN(valid)) {\n            return token(\"num\", valid);\n        } else {\n            parse_error(\"Invalid syntax: \" + num);\n        }\n    };\n\n    function read_escaped_char(in_string) {\n        var ch = next(true, in_string);\n        switch (ch) {\n          case \"n\" : return \"\\n\";\n          case \"r\" : return \"\\r\";\n          case \"t\" : return \"\\t\";\n          case \"b\" : return \"\\b\";\n          case \"v\" : return \"\\u000b\";\n          case \"f\" : return \"\\f\";\n          case \"0\" : return \"\\0\";\n          case \"x\" : return String.fromCharCode(hex_bytes(2));\n          case \"u\" : return String.fromCharCode(hex_bytes(4));\n          case \"\\n\": return \"\";\n          default  : return ch;\n        }\n    };\n\n    function hex_bytes(n) {\n        var num = 0;\n        for (; n > 0; --n) {\n            var digit = parseInt(next(true), 16);\n            if (isNaN(digit))\n                parse_error(\"Invalid hex-character pattern in string\");\n            num = (num << 4) | digit;\n        }\n        return num;\n    };\n\n    function read_string() {\n        return with_eof_error(\"Unterminated string constant\", function(){\n            var quote = next(), ret = \"\";\n            for (;;) {\n                var ch = next(true);\n                if (ch == \"\\\\\") {\n                    // read OctalEscapeSequence (XXX: deprecated if \"strict mode\")\n                    // https://github.com/mishoo/UglifyJS/issues/178\n                    var octal_len = 0, first = null;\n                    ch = read_while(function(ch){\n                        if (ch >= \"0\" && ch <= \"7\") {\n                            if (!first) {\n                                first = ch;\n                                return ++octal_len;\n                            }\n                            else if (first <= \"3\" && octal_len <= 2) return ++octal_len;\n                            else if (first >= \"4\" && octal_len <= 1) return ++octal_len;\n                        }\n                        return false;\n                    });\n                    if (octal_len > 0) ch = String.fromCharCode(parseInt(ch, 8));\n                    else ch = read_escaped_char(true);\n                }\n                else if (ch == quote) break;\n                else if (ch == \"\\n\") throw EX_EOF;\n                ret += ch;\n            }\n            return token(\"string\", ret);\n        });\n    };\n\n    function read_line_comment() {\n        next();\n        var i = find(\"\\n\"), ret;\n        if (i == -1) {\n            ret = S.text.substr(S.pos);\n            S.pos = S.text.length;\n        } else {\n            ret = S.text.substring(S.pos, i);\n            S.pos = i;\n        }\n        return token(\"comment1\", ret, true);\n    };\n\n    function read_multiline_comment() {\n        next();\n        return with_eof_error(\"Unterminated multiline comment\", function(){\n            var i = find(\"*/\", true),\n            text = S.text.substring(S.pos, i);\n            S.pos = i + 2;\n            S.line += text.split(\"\\n\").length - 1;\n            S.newline_before = S.newline_before || text.indexOf(\"\\n\") >= 0;\n\n            // https://github.com/mishoo/UglifyJS/issues/#issue/100\n            if (/^@cc_on/i.test(text)) {\n                warn(\"WARNING: at line \" + S.line);\n                warn(\"*** Found \\\"conditional comment\\\": \" + text);\n                warn(\"*** UglifyJS DISCARDS ALL COMMENTS.  This means your code might no longer work properly in Internet Explorer.\");\n            }\n\n            return token(\"comment2\", text, true);\n        });\n    };\n\n    function read_name() {\n        var backslash = false, name = \"\", ch, escaped = false, hex;\n        while ((ch = peek()) != null) {\n            if (!backslash) {\n                if (ch == \"\\\\\") escaped = backslash = true, next();\n                else if (is_identifier_char(ch)) name += next();\n                else break;\n            }\n            else {\n                if (ch != \"u\") parse_error(\"Expecting UnicodeEscapeSequence -- uXXXX\");\n                ch = read_escaped_char();\n                if (!is_identifier_char(ch)) parse_error(\"Unicode char: \" + ch.charCodeAt(0) + \" is not valid in identifier\");\n                name += ch;\n                backslash = false;\n            }\n        }\n        if (HOP(KEYWORDS, name) && escaped) {\n            hex = name.charCodeAt(0).toString(16).toUpperCase();\n            name = \"\\\\u\" + \"0000\".substr(hex.length) + hex + name.slice(1);\n        }\n        return name;\n    };\n\n    function read_regexp(regexp) {\n        return with_eof_error(\"Unterminated regular expression\", function(){\n            var prev_backslash = false, ch, in_class = false;\n            while ((ch = next(true))) if (prev_backslash) {\n                regexp += \"\\\\\" + ch;\n                prev_backslash = false;\n            } else if (ch == \"[\") {\n                in_class = true;\n                regexp += ch;\n            } else if (ch == \"]\" && in_class) {\n                in_class = false;\n                regexp += ch;\n            } else if (ch == \"/\" && !in_class) {\n                break;\n            } else if (ch == \"\\\\\") {\n                prev_backslash = true;\n            } else {\n                regexp += ch;\n            }\n            var mods = read_name();\n            return token(\"regexp\", [ regexp, mods ]);\n        });\n    };\n\n    function read_operator(prefix) {\n        function grow(op) {\n            if (!peek()) return op;\n            var bigger = op + peek();\n            if (HOP(OPERATORS, bigger)) {\n                next();\n                return grow(bigger);\n            } else {\n                return op;\n            }\n        };\n        return token(\"operator\", grow(prefix || next()));\n    };\n\n    function handle_slash() {\n        next();\n        var regex_allowed = S.regex_allowed;\n        switch (peek()) {\n          case \"/\":\n            S.comments_before.push(read_line_comment());\n            S.regex_allowed = regex_allowed;\n            return next_token();\n          case \"*\":\n            S.comments_before.push(read_multiline_comment());\n            S.regex_allowed = regex_allowed;\n            return next_token();\n        }\n        return S.regex_allowed ? read_regexp(\"\") : read_operator(\"/\");\n    };\n\n    function handle_dot() {\n        next();\n        return is_digit(peek())\n            ? read_num(\".\")\n            : token(\"punc\", \".\");\n    };\n\n    function read_word() {\n        var word = read_name();\n        return !HOP(KEYWORDS, word)\n            ? token(\"name\", word)\n            : HOP(OPERATORS, word)\n            ? token(\"operator\", word)\n            : HOP(KEYWORDS_ATOM, word)\n            ? token(\"atom\", word)\n            : token(\"keyword\", word);\n    };\n\n    function with_eof_error(eof_error, cont) {\n        try {\n            return cont();\n        } catch(ex) {\n            if (ex === EX_EOF) parse_error(eof_error);\n            else throw ex;\n        }\n    };\n\n    function next_token(force_regexp) {\n        if (force_regexp != null)\n            return read_regexp(force_regexp);\n        skip_whitespace();\n        start_token();\n        var ch = peek();\n        if (!ch) return token(\"eof\");\n        if (is_digit(ch)) return read_num();\n        if (ch == '\"' || ch == \"'\") return read_string();\n        if (HOP(PUNC_CHARS, ch)) return token(\"punc\", next());\n        if (ch == \".\") return handle_dot();\n        if (ch == \"/\") return handle_slash();\n        if (HOP(OPERATOR_CHARS, ch)) return read_operator();\n        if (ch == \"\\\\\" || is_identifier_start(ch)) return read_word();\n        parse_error(\"Unexpected character '\" + ch + \"'\");\n    };\n\n    next_token.context = function(nc) {\n        if (nc) S = nc;\n        return S;\n    };\n\n    return next_token;\n\n};\n\n/* -----[ Parser (constants) ]----- */\n\nvar UNARY_PREFIX = array_to_hash([\n    \"typeof\",\n    \"void\",\n    \"delete\",\n    \"--\",\n    \"++\",\n    \"!\",\n    \"~\",\n    \"-\",\n    \"+\"\n]);\n\nvar UNARY_POSTFIX = array_to_hash([ \"--\", \"++\" ]);\n\nvar ASSIGNMENT = (function(a, ret, i){\n    while (i < a.length) {\n        ret[a[i]] = a[i].substr(0, a[i].length - 1);\n        i++;\n    }\n    return ret;\n})(\n    [\"+=\", \"-=\", \"/=\", \"*=\", \"%=\", \">>=\", \"<<=\", \">>>=\", \"|=\", \"^=\", \"&=\"],\n    { \"=\": true },\n    0\n);\n\nvar PRECEDENCE = (function(a, ret){\n    for (var i = 0, n = 1; i < a.length; ++i, ++n) {\n        var b = a[i];\n        for (var j = 0; j < b.length; ++j) {\n            ret[b[j]] = n;\n        }\n    }\n    return ret;\n})(\n    [\n        [\"||\"],\n        [\"&&\"],\n        [\"|\"],\n        [\"^\"],\n        [\"&\"],\n        [\"==\", \"===\", \"!=\", \"!==\"],\n        [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n        [\">>\", \"<<\", \">>>\"],\n        [\"+\", \"-\"],\n        [\"*\", \"/\", \"%\"]\n    ],\n    {}\n);\n\nvar STATEMENTS_WITH_LABELS = array_to_hash([ \"for\", \"do\", \"while\", \"switch\" ]);\n\nvar ATOMIC_START_TOKEN = array_to_hash([ \"atom\", \"num\", \"string\", \"regexp\", \"name\" ]);\n\n/* -----[ Parser ]----- */\n\nfunction NodeWithToken(str, start, end) {\n    this.name = str;\n    this.start = start;\n    this.end = end;\n};\n\nNodeWithToken.prototype.toString = function() { return this.name; };\n\nfunction parse($TEXT, exigent_mode, embed_tokens) {\n\n    var S = {\n        input         : typeof $TEXT == \"string\" ? tokenizer($TEXT, true) : $TEXT,\n        token         : null,\n        prev          : null,\n        peeked        : null,\n        in_function   : 0,\n        in_directives : true,\n        in_loop       : 0,\n        labels        : []\n    };\n\n    S.token = next();\n\n    function is(type, value) {\n        return is_token(S.token, type, value);\n    };\n\n    function peek() { return S.peeked || (S.peeked = S.input()); };\n\n    function next() {\n        S.prev = S.token;\n        if (S.peeked) {\n            S.token = S.peeked;\n            S.peeked = null;\n        } else {\n            S.token = S.input();\n        }\n        S.in_directives = S.in_directives && (\n            S.token.type == \"string\" || is(\"punc\", \";\")\n        );\n        return S.token;\n    };\n\n    function prev() {\n        return S.prev;\n    };\n\n    function croak(msg, line, col, pos) {\n        var ctx = S.input.context();\n        js_error(msg,\n                 line != null ? line : ctx.tokline,\n                 col != null ? col : ctx.tokcol,\n                 pos != null ? pos : ctx.tokpos);\n    };\n\n    function token_error(token, msg) {\n        croak(msg, token.line, token.col);\n    };\n\n    function unexpected(token) {\n        if (token == null)\n            token = S.token;\n        token_error(token, \"Unexpected token: \" + token.type + \" (\" + token.value + \")\");\n    };\n\n    function expect_token(type, val) {\n        if (is(type, val)) {\n            return next();\n        }\n        token_error(S.token, \"Unexpected token \" + S.token.type + \", expected \" + type);\n    };\n\n    function expect(punc) { return expect_token(\"punc\", punc); };\n\n    function can_insert_semicolon() {\n        return !exigent_mode && (\n            S.token.nlb || is(\"eof\") || is(\"punc\", \"}\")\n        );\n    };\n\n    function semicolon() {\n        if (is(\"punc\", \";\")) next();\n        else if (!can_insert_semicolon()) unexpected();\n    };\n\n    function as() {\n        return slice(arguments);\n    };\n\n    function parenthesised() {\n        expect(\"(\");\n        var ex = expression();\n        expect(\")\");\n        return ex;\n    };\n\n    function add_tokens(str, start, end) {\n        return str instanceof NodeWithToken ? str : new NodeWithToken(str, start, end);\n    };\n\n    function maybe_embed_tokens(parser) {\n        if (embed_tokens) return function() {\n            var start = S.token;\n            var ast = parser.apply(this, arguments);\n            ast[0] = add_tokens(ast[0], start, prev());\n            return ast;\n        };\n        else return parser;\n    };\n\n    var statement = maybe_embed_tokens(function() {\n        if (is(\"operator\", \"/\") || is(\"operator\", \"/=\")) {\n            S.peeked = null;\n            S.token = S.input(S.token.value.substr(1)); // force regexp\n        }\n        switch (S.token.type) {\n          case \"string\":\n            var dir = S.in_directives, stat = simple_statement();\n            if (dir && stat[1][0] == \"string\" && !is(\"punc\", \",\"))\n                return as(\"directive\", stat[1][1]);\n            return stat;\n          case \"num\":\n          case \"regexp\":\n          case \"operator\":\n          case \"atom\":\n            return simple_statement();\n\n          case \"name\":\n            return is_token(peek(), \"punc\", \":\")\n                ? labeled_statement(prog1(S.token.value, next, next))\n                : simple_statement();\n\n          case \"punc\":\n            switch (S.token.value) {\n              case \"{\":\n                return as(\"block\", block_());\n              case \"[\":\n              case \"(\":\n                return simple_statement();\n              case \";\":\n                next();\n                return as(\"block\");\n              default:\n                unexpected();\n            }\n\n          case \"keyword\":\n            switch (prog1(S.token.value, next)) {\n              case \"break\":\n                return break_cont(\"break\");\n\n              case \"continue\":\n                return break_cont(\"continue\");\n\n              case \"debugger\":\n                semicolon();\n                return as(\"debugger\");\n\n              case \"do\":\n                return (function(body){\n                    expect_token(\"keyword\", \"while\");\n                    return as(\"do\", prog1(parenthesised, semicolon), body);\n                })(in_loop(statement));\n\n              case \"for\":\n                return for_();\n\n              case \"function\":\n                return function_(true);\n\n              case \"if\":\n                return if_();\n\n              case \"return\":\n                if (S.in_function == 0)\n                    croak(\"'return' outside of function\");\n                return as(\"return\",\n                          is(\"punc\", \";\")\n                          ? (next(), null)\n                          : can_insert_semicolon()\n                          ? null\n                          : prog1(expression, semicolon));\n\n              case \"switch\":\n                return as(\"switch\", parenthesised(), switch_block_());\n\n              case \"throw\":\n                if (S.token.nlb)\n                    croak(\"Illegal newline after 'throw'\");\n                return as(\"throw\", prog1(expression, semicolon));\n\n              case \"try\":\n                return try_();\n\n              case \"var\":\n                return prog1(var_, semicolon);\n\n              case \"const\":\n                return prog1(const_, semicolon);\n\n              case \"while\":\n                return as(\"while\", parenthesised(), in_loop(statement));\n\n              case \"with\":\n                return as(\"with\", parenthesised(), statement());\n\n              default:\n                unexpected();\n            }\n        }\n    });\n\n    function labeled_statement(label) {\n        S.labels.push(label);\n        var start = S.token, stat = statement();\n        if (exigent_mode && !HOP(STATEMENTS_WITH_LABELS, stat[0]))\n            unexpected(start);\n        S.labels.pop();\n        return as(\"label\", label, stat);\n    };\n\n    function simple_statement() {\n        return as(\"stat\", prog1(expression, semicolon));\n    };\n\n    function break_cont(type) {\n        var name;\n        if (!can_insert_semicolon()) {\n            name = is(\"name\") ? S.token.value : null;\n        }\n        if (name != null) {\n            next();\n            if (!member(name, S.labels))\n                croak(\"Label \" + name + \" without matching loop or statement\");\n        }\n        else if (S.in_loop == 0)\n            croak(type + \" not inside a loop or switch\");\n        semicolon();\n        return as(type, name);\n    };\n\n    function for_() {\n        expect(\"(\");\n        var init = null;\n        if (!is(\"punc\", \";\")) {\n            init = is(\"keyword\", \"var\")\n                ? (next(), var_(true))\n                : expression(true, true);\n            if (is(\"operator\", \"in\")) {\n                if (init[0] == \"var\" && init[1].length > 1)\n                    croak(\"Only one variable declaration allowed in for..in loop\");\n                return for_in(init);\n            }\n        }\n        return regular_for(init);\n    };\n\n    function regular_for(init) {\n        expect(\";\");\n        var test = is(\"punc\", \";\") ? null : expression();\n        expect(\";\");\n        var step = is(\"punc\", \")\") ? null : expression();\n        expect(\")\");\n        return as(\"for\", init, test, step, in_loop(statement));\n    };\n\n    function for_in(init) {\n        var lhs = init[0] == \"var\" ? as(\"name\", init[1][0]) : init;\n        next();\n        var obj = expression();\n        expect(\")\");\n        return as(\"for-in\", init, lhs, obj, in_loop(statement));\n    };\n\n    var function_ = function(in_statement) {\n        var name = is(\"name\") ? prog1(S.token.value, next) : null;\n        if (in_statement && !name)\n            unexpected();\n        expect(\"(\");\n        return as(in_statement ? \"defun\" : \"function\",\n                  name,\n                  // arguments\n                  (function(first, a){\n                      while (!is(\"punc\", \")\")) {\n                          if (first) first = false; else expect(\",\");\n                          if (!is(\"name\")) unexpected();\n                          a.push(S.token.value);\n                          next();\n                      }\n                      next();\n                      return a;\n                  })(true, []),\n                  // body\n                  (function(){\n                      ++S.in_function;\n                      var loop = S.in_loop;\n                      S.in_directives = true;\n                      S.in_loop = 0;\n                      var a = block_();\n                      --S.in_function;\n                      S.in_loop = loop;\n                      return a;\n                  })());\n    };\n\n    function if_() {\n        var cond = parenthesised(), body = statement(), belse;\n        if (is(\"keyword\", \"else\")) {\n            next();\n            belse = statement();\n        }\n        return as(\"if\", cond, body, belse);\n    };\n\n    function block_() {\n        expect(\"{\");\n        var a = [];\n        while (!is(\"punc\", \"}\")) {\n            if (is(\"eof\")) unexpected();\n            a.push(statement());\n        }\n        next();\n        return a;\n    };\n\n    var switch_block_ = curry(in_loop, function(){\n        expect(\"{\");\n        var a = [], cur = null;\n        while (!is(\"punc\", \"}\")) {\n            if (is(\"eof\")) unexpected();\n            if (is(\"keyword\", \"case\")) {\n                next();\n                cur = [];\n                a.push([ expression(), cur ]);\n                expect(\":\");\n            }\n            else if (is(\"keyword\", \"default\")) {\n                next();\n                expect(\":\");\n                cur = [];\n                a.push([ null, cur ]);\n            }\n            else {\n                if (!cur) unexpected();\n                cur.push(statement());\n            }\n        }\n        next();\n        return a;\n    });\n\n    function try_() {\n        var body = block_(), bcatch, bfinally;\n        if (is(\"keyword\", \"catch\")) {\n            next();\n            expect(\"(\");\n            if (!is(\"name\"))\n                croak(\"Name expected\");\n            var name = S.token.value;\n            next();\n            expect(\")\");\n            bcatch = [ name, block_() ];\n        }\n        if (is(\"keyword\", \"finally\")) {\n            next();\n            bfinally = block_();\n        }\n        if (!bcatch && !bfinally)\n            croak(\"Missing catch/finally blocks\");\n        return as(\"try\", body, bcatch, bfinally);\n    };\n\n    function vardefs(no_in) {\n        var a = [];\n        for (;;) {\n            if (!is(\"name\"))\n                unexpected();\n            var name = S.token.value;\n            next();\n            if (is(\"operator\", \"=\")) {\n                next();\n                a.push([ name, expression(false, no_in) ]);\n            } else {\n                a.push([ name ]);\n            }\n            if (!is(\"punc\", \",\"))\n                break;\n            next();\n        }\n        return a;\n    };\n\n    function var_(no_in) {\n        return as(\"var\", vardefs(no_in));\n    };\n\n    function const_() {\n        return as(\"const\", vardefs());\n    };\n\n    function new_() {\n        var newexp = expr_atom(false), args;\n        if (is(\"punc\", \"(\")) {\n            next();\n            args = expr_list(\")\");\n        } else {\n            args = [];\n        }\n        return subscripts(as(\"new\", newexp, args), true);\n    };\n\n    var expr_atom = maybe_embed_tokens(function(allow_calls) {\n        if (is(\"operator\", \"new\")) {\n            next();\n            return new_();\n        }\n        if (is(\"punc\")) {\n            switch (S.token.value) {\n              case \"(\":\n                next();\n                return subscripts(prog1(expression, curry(expect, \")\")), allow_calls);\n              case \"[\":\n                next();\n                return subscripts(array_(), allow_calls);\n              case \"{\":\n                next();\n                return subscripts(object_(), allow_calls);\n            }\n            unexpected();\n        }\n        if (is(\"keyword\", \"function\")) {\n            next();\n            return subscripts(function_(false), allow_calls);\n        }\n        if (HOP(ATOMIC_START_TOKEN, S.token.type)) {\n            var atom = S.token.type == \"regexp\"\n                ? as(\"regexp\", S.token.value[0], S.token.value[1])\n                : as(S.token.type, S.token.value);\n            return subscripts(prog1(atom, next), allow_calls);\n        }\n        unexpected();\n    });\n\n    function expr_list(closing, allow_trailing_comma, allow_empty) {\n        var first = true, a = [];\n        while (!is(\"punc\", closing)) {\n            if (first) first = false; else expect(\",\");\n            if (allow_trailing_comma && is(\"punc\", closing)) break;\n            if (is(\"punc\", \",\") && allow_empty) {\n                a.push([ \"atom\", \"undefined\" ]);\n            } else {\n                a.push(expression(false));\n            }\n        }\n        next();\n        return a;\n    };\n\n    function array_() {\n        return as(\"array\", expr_list(\"]\", !exigent_mode, true));\n    };\n\n    function object_() {\n        var first = true, a = [];\n        while (!is(\"punc\", \"}\")) {\n            if (first) first = false; else expect(\",\");\n            if (!exigent_mode && is(\"punc\", \"}\"))\n                // allow trailing comma\n                break;\n            var type = S.token.type;\n            var name = as_property_name();\n            if (type == \"name\" && (name == \"get\" || name == \"set\") && !is(\"punc\", \":\")) {\n                a.push([ as_name(), function_(false), name ]);\n            } else {\n                expect(\":\");\n                a.push([ name, expression(false) ]);\n            }\n        }\n        next();\n        return as(\"object\", a);\n    };\n\n    function as_property_name() {\n        switch (S.token.type) {\n          case \"num\":\n          case \"string\":\n            return prog1(S.token.value, next);\n        }\n        return as_name();\n    };\n\n    function as_name() {\n        switch (S.token.type) {\n          case \"name\":\n          case \"operator\":\n          case \"keyword\":\n          case \"atom\":\n            return prog1(S.token.value, next);\n          default:\n            unexpected();\n        }\n    };\n\n    function subscripts(expr, allow_calls) {\n        if (is(\"punc\", \".\")) {\n            next();\n            return subscripts(as(\"dot\", expr, as_name()), allow_calls);\n        }\n        if (is(\"punc\", \"[\")) {\n            next();\n            return subscripts(as(\"sub\", expr, prog1(expression, curry(expect, \"]\"))), allow_calls);\n        }\n        if (allow_calls && is(\"punc\", \"(\")) {\n            next();\n            return subscripts(as(\"call\", expr, expr_list(\")\")), true);\n        }\n        return expr;\n    };\n\n    function maybe_unary(allow_calls) {\n        if (is(\"operator\") && HOP(UNARY_PREFIX, S.token.value)) {\n            return make_unary(\"unary-prefix\",\n                              prog1(S.token.value, next),\n                              maybe_unary(allow_calls));\n        }\n        var val = expr_atom(allow_calls);\n        while (is(\"operator\") && HOP(UNARY_POSTFIX, S.token.value) && !S.token.nlb) {\n            val = make_unary(\"unary-postfix\", S.token.value, val);\n            next();\n        }\n        return val;\n    };\n\n    function make_unary(tag, op, expr) {\n        if ((op == \"++\" || op == \"--\") && !is_assignable(expr))\n            croak(\"Invalid use of \" + op + \" operator\");\n        return as(tag, op, expr);\n    };\n\n    function expr_op(left, min_prec, no_in) {\n        var op = is(\"operator\") ? S.token.value : null;\n        if (op && op == \"in\" && no_in) op = null;\n        var prec = op != null ? PRECEDENCE[op] : null;\n        if (prec != null && prec > min_prec) {\n            next();\n            var right = expr_op(maybe_unary(true), prec, no_in);\n            return expr_op(as(\"binary\", op, left, right), min_prec, no_in);\n        }\n        return left;\n    };\n\n    function expr_ops(no_in) {\n        return expr_op(maybe_unary(true), 0, no_in);\n    };\n\n    function maybe_conditional(no_in) {\n        var expr = expr_ops(no_in);\n        if (is(\"operator\", \"?\")) {\n            next();\n            var yes = expression(false);\n            expect(\":\");\n            return as(\"conditional\", expr, yes, expression(false, no_in));\n        }\n        return expr;\n    };\n\n    function is_assignable(expr) {\n        if (!exigent_mode) return true;\n        switch (expr[0]+\"\") {\n          case \"dot\":\n          case \"sub\":\n          case \"new\":\n          case \"call\":\n            return true;\n          case \"name\":\n            return expr[1] != \"this\";\n        }\n    };\n\n    function maybe_assign(no_in) {\n        var left = maybe_conditional(no_in), val = S.token.value;\n        if (is(\"operator\") && HOP(ASSIGNMENT, val)) {\n            if (is_assignable(left)) {\n                next();\n                return as(\"assign\", ASSIGNMENT[val], left, maybe_assign(no_in));\n            }\n            croak(\"Invalid assignment\");\n        }\n        return left;\n    };\n\n    var expression = maybe_embed_tokens(function(commas, no_in) {\n        if (arguments.length == 0)\n            commas = true;\n        var expr = maybe_assign(no_in);\n        if (commas && is(\"punc\", \",\")) {\n            next();\n            return as(\"seq\", expr, expression(true, no_in));\n        }\n        return expr;\n    });\n\n    function in_loop(cont) {\n        try {\n            ++S.in_loop;\n            return cont();\n        } finally {\n            --S.in_loop;\n        }\n    };\n\n    return as(\"toplevel\", (function(a){\n        while (!is(\"eof\"))\n            a.push(statement());\n        return a;\n    })([]));\n\n};\n\n/* -----[ Utilities ]----- */\n\nfunction curry(f) {\n    var args = slice(arguments, 1);\n    return function() { return f.apply(this, args.concat(slice(arguments))); };\n};\n\nfunction prog1(ret) {\n    if (ret instanceof Function)\n        ret = ret();\n    for (var i = 1, n = arguments.length; --n > 0; ++i)\n        arguments[i]();\n    return ret;\n};\n\nfunction array_to_hash(a) {\n    var ret = {};\n    for (var i = 0; i < a.length; ++i)\n        ret[a[i]] = true;\n    return ret;\n};\n\nfunction slice(a, start) {\n    return Array.prototype.slice.call(a, start || 0);\n};\n\nfunction characters(str) {\n    return str.split(\"\");\n};\n\nfunction member(name, array) {\n    for (var i = array.length; --i >= 0;)\n        if (array[i] == name)\n            return true;\n    return false;\n};\n\nfunction HOP(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n};\n\nvar warn = function() {};\n\n/* -----[ Exports ]----- */\n\nexports.tokenizer = tokenizer;\nexports.parse = parse;\nexports.slice = slice;\nexports.curry = curry;\nexports.member = member;\nexports.array_to_hash = array_to_hash;\nexports.PRECEDENCE = PRECEDENCE;\nexports.KEYWORDS_ATOM = KEYWORDS_ATOM;\nexports.RESERVED_WORDS = RESERVED_WORDS;\nexports.KEYWORDS = KEYWORDS;\nexports.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;\nexports.OPERATORS = OPERATORS;\nexports.is_alphanumeric_char = is_alphanumeric_char;\nexports.is_identifier_start = is_identifier_start;\nexports.is_identifier_char = is_identifier_char;\nexports.set_logger = function(logger) {\n    warn = logger;\n};\n\n// Local variables:\n// js-indent-level: 4\n// End:\n","/* @license\n\n  Copyright (c) 2010 Mihai Bazon <mihai.bazon@gmail.com>\n  Copyright (c) 2011 Lauri Paimen <lauri@paimen.info>\n  Copyright (c) 2013 Anton Kreuzkamp <akreuzkamp@web.de>\n  Copyright (c) 2016 qmlweb-parser contributors\n  Based on parse-js (http://marijn.haverbeke.nl/parse-js/).\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n      * Redistributions of source code must retain the above\n        copyright notice, this list of conditions and the following\n        disclaimer.\n\n      * Redistributions in binary form must reproduce the above\n        copyright notice, this list of conditions and the following\n        disclaimer in the documentation and/or other materials\n        provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n  SUCH DAMAGE.\n*/\n\n/*\n * QML parser and parsetree'er.\n *\n * Exports:\n *\n * - qmlweb_parse(src, type) -- parses QML source and returns it as output\n *   tree expected by the QML engine\n */\n\n// Object cloning for debug prints.\nfunction clone(obj) {\n  if (obj == null || typeof obj !== 'object')\n    return obj;\n\n  var temp = {}; // changed\n\n  for (var key in obj)\n    temp[key] = clone(obj[key]);\n  return temp;\n}\n\nfunction QMLParseError(message, line, col, pos, source) {\n  JS_Parse_Error.call(this, message, line, col, pos);\n  var comment = extractLinesForErrorDiag(source, line);\n  this.comment = comment ? comment : \"\";\n  this.message += \" (line: \" + this.line + \", col: \" + col + \", pos: \" + pos + \")\" + \"\\n\" + comment + \"\\n\";\n  this.file = qmlweb_parse.nowParsingFile;\n}\nQMLParseError.prototype = new Error();\n\nfunction extractLinesForErrorDiag(text, line) {\n  var r = \"\";\n  var lines = text.split(\"\\n\");\n\n  for (var i = line - 3; i <= line + 3; i++) {\n    if (i >= 0 && i < lines.length ) {\n      var mark = i === line ? \">>\" : \"  \";\n      r += mark + (i + 1) + \"  \" + lines[i] + \"\\n\";\n    }\n  }\n\n  return r;\n}\n\nfunction qmlweb_tokenizer($TEXT) {\n  // Override UglifyJS methods\n\n  parse_error = function(err) {\n    throw new QMLParseError(err, S.tokline, S.tokcol, S.tokpos, S.text);\n  };\n\n  // WARNING: Here the original tokenizer() code gets embedded\n  return tokenizer($TEXT);\n}\n\nfunction qmlweb_parse($TEXT, document_type, exigent_mode) {\n  var embed_tokens = false; // embed_tokens option is not supported\n\n  var TEXT = $TEXT.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\").replace(/^\\uFEFF/, '');\n  $TEXT = qmlweb_tokenizer($TEXT, true);\n\n  // WARNING: Here the original parse() code gets embedded\n  parse($TEXT,exigent_mode,false);\n  // NOTE: Don't insert spaces between arguments!\n\n  // Override UglifyJS methods\n\n  croak = function(msg, line, col, pos) {\n    var ctx = S.input.context();\n    throw new QMLParseError(msg,\n      line != null ? line : ctx.tokline,\n      col != null ? col : ctx.tokcol,\n      pos != null ? pos : ctx.tokpos,\n      TEXT\n    );\n  };\n\n  expect_token = function(type, val) {\n    if (is(type, val)) {\n      return next();\n    }\n    token_error(S.token, \"Unexpected token \" + S.token.type + \" \" + S.token.val + \", expected \" + type + \" \" + val);\n  };\n\n  var statement_js = statement;\n  statement = function() {\n    var in_qmlpropdef = !!statement.in_qmlpropdef;\n    statement.in_qmlpropdef = false;\n    switch (S.token.type) {\n    case \"punc\":\n      switch (S.token.value) {\n      case \".\":\n        return is_token(peek(), \"name\", \"pragma\") ? qml_pragma_statement() : unexpected();\n      }\n    case \"keyword\":\n      switch (S.token.value) {\n      case \"function\":\n        if (in_qmlpropdef) {\n          next();\n          return function_(false);\n        }\n      }\n    }\n    return statement_js();\n  };\n\n  array_ = function() {\n    var from = S.token.pos;\n    var stat = expr_list(\"]\", !exigent_mode, true);\n    var to = S.token.pos;\n    return as(\"array\", stat, \"[\" + TEXT.substr(from, to - from));\n  };\n\n  expression = function(commas, no_in) {\n    if (arguments.length == 0)\n      commas = true;\n    var expr = maybe_qmlelem(no_in);\n    if (commas && is(\"punc\", \",\")) {\n      next();\n      return as(\"seq\", expr, expression(true, no_in));\n    }\n    return expr;\n  };\n\n  // QML-specific methods\n\n  function as_statement() {\n    var res = slice(arguments);\n    S.in_function++;\n    var start = S.token.pos;\n    res.push(statement());\n    var end = S.token.pos;\n    S.in_function--;\n    res.push(TEXT.substr(start, end - start));\n    return res;\n  }\n\n  function maybe_qmlelem(no_in) {\n    var expr = maybe_assign(no_in);\n    if (is(\"punc\", \"{\"))\n      return as(\"qmlelem\", expr[1], undefined, qmlblock());\n    return expr;\n  }\n\n  function qml_is_element(str) {\n    return str[0].toUpperCase() == str[0];\n  }\n\n  function qmlblock() {\n    expect(\"{\");\n    var a = [];\n    while (!is(\"punc\", \"}\")) {\n      if (is(\"eof\"))\n        unexpected();\n      a.push(qmlstatement());\n    }\n    expect(\"}\");\n    return a;\n  }\n\n  function qmlpropdef() {\n    var type = S.token.value;\n    next();\n    var name = S.token.value;\n    next();\n    if (type == \"alias\") {\n      expect(\":\");\n      if (!is(\"name\"))\n        unexpected();\n      var objName = S.token.value;\n      next();\n      if (is(\"punc\", \".\")) {\n        next();\n        if (!is(\"name\"))\n          unexpected();\n        var propName = S.token.value;\n        next();\n      }\n      return as(\"qmlaliasdef\", name, objName, propName);\n    }\n    if (is(\"punc\", \":\")) {\n      next();\n      statement.in_qmlpropdef = true;\n      return as_statement(\"qmlpropdef\", name, type);\n    } else if (is(\"punc\", \";\"))\n      next();\n    return as(\"qmlpropdef\", name, type);\n  }\n\n  function qmldefaultprop() {\n    next();\n    expect_token(\"name\", \"property\");\n    return as(\"qmldefaultprop\", qmlpropdef());\n  }\n\n  function qmlsignaldef() {\n    var name = S.token.value;\n    next();\n    var args = [];\n    if (is(\"punc\", \"(\")) {\n      next();\n      var first = true;\n      while (!is(\"punc\", \")\")) {\n        if (first)\n          first = false;\n        else\n          expect(\",\");\n        if (!is(\"name\") && !is('keyword', 'var'))\n          unexpected();\n        var type = S.token.value;\n        next();\n        if (!is(\"name\"))\n          unexpected();\n        args.push({ type: type, name: S.token.value });\n        next();\n      }\n      next();\n    }\n    if (is(\"punc\", \";\"))\n      next();\n    return as(\"qmlsignaldef\", name, args);\n  }\n\n  function qmlstatement() {\n    if (is(\"keyword\", \"function\")) {\n      var from = S.token.pos;\n      next();\n      var stat = function_(true);\n      var to = S.token.pos;\n      var name = stat[1];\n      return as(\"qmlmethod\", name, stat, TEXT.substr(from, to - from));\n    } else if (is(\"name\", \"signal\")) {\n      next();\n      if (is(\"punc\", \":\")) {\n        next();\n        return as_statement(\"qmlprop\", \"signal\");\n      } else {\n        return qmlsignaldef();\n      }\n    } else if (S.token.type == \"name\") {\n      var propname = S.token.value;\n      next();\n      if (propname == \"property\" && (S.token.type == \"name\" || S.token.value == \"var\")) {\n        return qmlpropdef();\n      } else if (qml_is_element(propname) && !is(\"punc\", \".\")) {\n        // Element\n        var onProp;\n        if (is(\"name\", \"on\")) {\n          next();\n          onProp = S.token.value;\n          next();\n        }\n        return as(\"qmlelem\", propname, onProp, qmlblock());\n      } else if (is(\"punc\", \".\")) { // property statement\n        // anchors, fonts etc, a.b: statement;\n        // Can also be Component.onCompleted: ...\n        // Assume only one subproperty\n        next();\n        var subname = S.token.value;\n        next();\n        /* Check for ModuleQualifier.QMLElement */\n        if (qml_is_element(subname)) {\n          return as(\"qmlelem\", propname + \".\" + subname, undefined, qmlblock());\n        }\n        expect(\":\");\n        return as_statement(\"qmlobjdef\", propname, subname);\n      } else if (is(\"punc\", \"{\")) {\n        return as(\"qmlobj\", propname, qmlblock());\n      } else {\n        // Evaluatable item\n        expect(\":\");\n        return as_statement(\"qmlprop\", propname);\n      }\n    } else if (is(\"keyword\", \"default\")) {\n      return qmldefaultprop();\n    } else {\n      todo();\n    }\n  }\n\n  function qml_pragma_statement() {\n    next();\n    next();\n    var pragma = S.token.value;\n    next();\n    return as(\"qmlpragma\", pragma);\n  }\n\n  function qmlimport() {\n    // todo\n    next();\n    var moduleName = S.token.value;\n    var isDottedNotation = S.token.type == \"name\";\n    next();\n\n    while (is(\"punc\", \".\")) {\n      next();\n      moduleName += \".\" + S.token.value;\n      next();\n    }\n    if (is(\"num\")) {\n      var version = S.token.value;\n      next();\n    }\n    var namespace = \"\";\n    if (is(\"name\", \"as\")) {\n      next();\n      namespace = S.token.value;\n      next();\n    }\n    return as(\"qmlimport\", moduleName, version, namespace, isDottedNotation);\n  }\n\n  function qmldocument() {\n    var imports = [];\n    while (is(\"name\", \"import\")) {\n      imports.push(qmlimport());\n    }\n    var root = qmlstatement();\n    if (!is(\"eof\"))\n      unexpected();\n    return as(\"toplevel\", imports, root);\n  }\n\n  function jsdocument() {\n    var statements = [];\n    while (!is(\"eof\")) {\n      statements.push(statement());\n    }\n    return as(\"jsresource\", statements);\n  }\n\n  function amIn(s) {\n    console && console.log(s, clone(S), S.token.type, S.token.value);\n  }\n\n  function todo() {\n    amIn(\"todo parse:\");\n    next();\n  }\n\n  if (document_type === qmlweb_parse.JSResource) {\n    return jsdocument();\n  } else {\n    return qmldocument();\n  }\n}\n\nqmlweb_parse.nowParsingFile = ''; // TODO: make a parameter of qmlweb_parse\nqmlweb_parse.QMLDocument = 1;\nqmlweb_parse.JSResource = 2;\n\nfunction qmlweb_jsparse(source) {\n  var obj = { exports: [], source: source };\n  var AST_Tree = qmlweb_parse(source, qmlweb_parse.JSResource);\n  var main_scope = AST_Tree[1];\n\n  for (var i = 0 ; i < main_scope.length ; ++i) {\n    var item = main_scope[i];\n\n    switch (item[0]) {\n      case \"var\":\n        obj.exports.push(item[1][0][0]);\n        break ;\n      case \"defun\":\n        obj.exports.push(item[1]);\n        break ;\n    }\n  }\n  return obj;\n}\n\nexports.qmlweb_parse = qmlweb_parse;\nexports.qmlweb_jsparse = qmlweb_jsparse;\n"],"sourceRoot":"/source/"}