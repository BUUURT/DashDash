{"version":3,"sources":["qt.js","QmlWeb.js","QObject.js","JSItemModel.js","QColor.js","QSizeF.js","Signal.js","Qt.js","QMLBinding.js","QMLBoolean.js","QMLEngine.js","QMLInteger.js","QMLList.js","QMLNumber.js","QMLOperationState.js","QMLProperty.js","QMLString.js","QMLUrl.js","QMLVariant.js","AutoLoader.js","easing.js","getset.js","helpers.js","import.js","jsparser.js","keyboard.js","modules.js","properties.js","qmlstructure.js","qrc.js","QmlWeb.Dom/DomElement.js","QmlWeb/RestModel.js","Qt.labs.settings/Settings.js","QtGraphicalEffects/FastBlur.js","QtMobility/GeoLocation.js","QtMultimedia/Video.js","QtQml/Binding.js","QtQml/Component.js","QtQml/Connections.js","QtQml/QtObject.js","QtQml/Timer.js","QtQuick.Controls/Button.js","QtQuick.Controls/Checkbox.js","QtQuick.Controls/ComboBox.js","QtQuick.Controls/ScrollView.js","QtQuick.Controls/TextArea.js","QtQuick.Controls/TextField.js","QtQuick.Window/Screen.js","QtQuick/AnimatedImage.js","QtQuick/Animation.js","QtQuick/Behavior.js","QtQuick/BorderImage.js","QtQuick/Canvas.js","QtQuick/Column.js","QtQuick/DoubleValidator.js","QtQuick/Flow.js","QtQuick/Font.js","QtQuick/FontEnum.js","QtQuick/FontLoader.js","QtQuick/Grid.js","QtQuick/Image.js","QtQuick/IntValidator.js","QtQuick/Item.js","QtQuick/ListElement.js","QtQuick/ListModel.js","QtQuick/ListView.js","QtQuick/Loader.js","QtQuick/MouseArea.js","QtQuick/NumberAnimation.js","QtQuick/ParallelAnimation.js","QtQuick/Positioner.js","QtQuick/PropertyAnimation.js","QtQuick/PropertyChanges.js","QtQuick/Rectangle.js","QtQuick/RegExpValidator.js","QtQuick/Repeater.js","QtQuick/Rotation.js","QtQuick/Row.js","QtQuick/Scale.js","QtQuick/SequentialAnimation.js","QtQuick/State.js","QtQuick/SystemPalette.js","QtQuick/Text.js","QtQuick/TextEdit.js","QtQuick/TextInput.js","QtQuick/Transition.js","QtQuick/Translate.js","QtWebSockets/WebSocket.js"],"names":["global","parent","item","prop","QmlWeb","QColor","console","createProperty","args","Signal","type","thisObj","i","desc","rgba","hsla","openUrlExternally","page","createComponent","file","tree","object","context","component","engine","createQmlObject","resolvedUrl","size","LeftButton","RightButton","MiddleButton","NoModifier","ShiftModifier","ControlModifier","AltModifier","MetaModifier","KeypadModifier","LeftToRight","RightToLeft","Vertical","Horizontal","Key_Escape","Key_Tab","Key_Backtab","Key_Backspace","Key_Return","Key_Enter","Key_Insert","Key_Delete","Key_Pause","Key_Print","Key_SysReq","Key_Clear","Key_Home","Key_End","Key_Left","Key_Up","Key_Right","Key_Down","Key_PageUp","Key_PageDown","Key_Shift","Key_Control","Key_Meta","Key_Alt","Key_AltGr","Key_CapsLock","Key_NumLock","Key_ScrollLock","Key_F1","Key_F7","Key_F12","Key_F17","Key_F22","Key_F25","Key_F31","Key_Super_L","Key_Super_R","Key_Menu","Key_Hyper_L","Key_Hyper_R","Key_Help","Key_Direction_L","Key_Direction_R","Key_Space","Key_Any","Key_Exclam","Key_QuoteDbl","Key_NumberSign","Key_Dollar","Key_Percent","Key_Ampersant","Key_Apostrophe","Key_ParenLeft","Key_ParenRight","Key_Asterisk","Key_Plus","Key_Comma","Key_Minus","Key_Period","Key_Slash","Key_0","Key_5","Key_Colon","Key_Semicolon","Key_Less","Key_Equal","Key_Greater","Key_Question","Key_At","Key_A","Key_H","Key_O","Key_V","Key_BracketLeft","Key_Backslash","Key_BracketRight","Key_AsciiCircum","Key_Underscore","Key_QuoteLeft","Key_BraceLeft","Key_Bar","Key_BraceRight","Key_AsciiTilde","Key_Back","Key_Forward","Key_Stop","Key_VolumeDown","Key_VolumeUp","Key_VolumeMute","Key_multiply","Key_add","Key_substract","Key_divide","Key_News","Key_OfficeHome","Key_Option","Key_Paste","Key_Phone","Key_Calendar","Key_Reply","Key_Reload","Key_RotateWindows","Key_RotationPB","Key_RotationKB","Key_Save","Key_Send","Key_Spell","Key_SplitScreen","Key_Support","Key_TaskPane","Key_Terminal","Key_Tools","Key_Travel","Key_Video","Key_Word","Key_Xfer","Key_ZoomIn","Key_ZoomOut","Key_Away","Key_Messenger","Key_WebCam","Key_MailForward","Key_Pictures","Key_Music","Key_Battery","Key_Bluetooth","Key_WLAN","Key_UWB","Key_AudioForward","Key_AudioRepeat","Key_AudioRandomPlay","Key_Subtitle","Key_AudioCycleTrack","Key_Time","Key_Hibernate","Key_View","Key_TopMenu","Key_PowerDown","Key_Suspend","Key_ContrastAdjust","Key_MediaLast","Key_unknown","Key_Call","Key_Camera","Key_CameraFocus","Key_Context1","Key_Context2","Key_Context3","Key_Context4","Key_Flip","Key_Hangup","Key_No","Key_Select","Key_Yes","Key_ToggleCallHangup","Key_VoiceDial","Key_LastNumberRedial","Key_Execute","Key_Printer","Key_Play","Key_Sleep","Key_Zoom","Key_Cancel","AlignLeft","AlignRight","AlignHCenter","AlignJustify","AlignTop","AlignBottom","AlignVCenter","AlignCenter","AlignBaseline","AlignAbsolute","AlignLeading","AlignTrailing","AlignHorizontal_Mask","AlignVertical_Mask","PrimaryOrientation","PortraitOrientation","LandscapeOrientation","InvertedPortraitOrientation","InvertedLandscapeOrientation","ArrowCursor","UpArrowCursor","CrossCursor","WaitCursor","IBeamCursor","SizeVerCursor","SizeHorCursor","SizeBDiagCursor","SizeFDiagCursor","SizeAllCursor","BlankCursor","SplitVCursor","SplitHCursor","PointingHandCursor","ForbiddenCursor","WhatsThisCursor","BusyCursor","OpenHandCursor","ClosedHandCursor","DragCopyCursor","DragMoveCursor","DragLinkCursor","LastCursor","BitmapCursor","CustomCursor","ScrollBarAsNeeded","ScrollBarAlwaysOff","ScrollBarAlwaysOn","src","deps","QMLBoolean","clearInterval","out","leadingSlash","basePath","paths","dependantProperties","value","name","content","width","height","document","focusedElement","e","property","obj","scheme","authority","path","op","handler","QMLInteger","list","QMLList","QMLNumber","Idle","Init","Running","QMLProperty","target","from","to","val","int","real","double","string","bool","enum","url","QMLString","QMLUrl","QMLVariant","window","Linear","InQuad","InCubic","InQuart","InQuint","InSine","InExpo","InCirc","InElastic","InBack","InBounce","Object","get","configurable","enumerable","set","merged","xhr","qmldir","internals","externals","accepted","count","isAutoRepeat","key","modifiers","text","Main","color","variant","var","modules","options","baseModule","baseName","dependants","module","versions","baseClass","enums","signals","defaultProperty","properties","constructor","descriptor","registerGlobalQmlType","inherit","constructors","imports","self","perImportContextConstructors","meta","filePath","setter","componentScope","targetProp","loopWatchdog","applyProperties","params","sub","curr","convertToEngine","toplevel","qmlelem","applyProp","qmlprop","qmlobjdef","qmlobj","qmlmethod","qmlpropdef","qmlaliasdef","qmlsignaldef","qmldefaultprop","num","array","a","isList","hasBinding","loadParser","tagName","isLoading","mimeType","queryMimeType","initialValue","fetched","saved","method","success","body","parts","responseObject","category","emitter","signalName","localStorage","radius","source","transformType","operation","parameters","accuracy","altitude","altitudeAccuracy","heading","latitude","longitude","speed","timestamp","label","navigator","MediaPlayer","NoError","AccessDenied","StoppedState","NoMedia","EndOfMedia","VideoOutput","duration","position","autoPlay","muted","volume","playbackRate","playbackState","fillMode","status","error","paused","playing","stopped","ogg","ogv","ogm","mp4","webm","when","moduleImports","loadImport","$context","newContext","isComponentRoot","ignoreUnknownSignals","old_target","c","interval","repeat","running","triggeredOnStart","triggered","enabled","clicked","button","checked","checkbox","currentIndex","currentText","menu","model","pressed","activated","entries","contentItem","flickableItem","viewport","frameVisible","highlightOnFocus","verticalScrollBarPolicy","horizontalScrollBarPolicy","style","newItem","textarea","TextInput","maximumLength","readOnly","validator","echoMode","input","orientation","orientationUpdateMask","primaryOrientation","pixelDensity","devicePixelRatio","desktopAvailableHeight","desktopAvailableWidth","Animation","Easing","alwaysRunToEnd","loops","animation","newVal","BorderImage","Stretch","Null","smooth","horizontalTileMode","verticalTileMode","progress","bg","available","canvasSize","canvasWindow","contextType","renderStrategy","renderTarget","tileSize","imageLoaded","paint","painted","maxWidth","child","curPos","DoubleValidator","bottom","top","decimals","notation","Flow","flow","layoutDirection","curHPos","curVPos","rowSize","MixedCase","AllUppercase","AllLowercase","SmallCaps","Capitalize","Thin","ExtraLight","Light","Normal","Medium","DemiBold","Bold","ExtraBold","Black","FontLoader","fontsLoaded","fontLoaded","fontLoader","setTimeout","Grid","columns","rows","gridWidth","gridHeight","cols","colWidth","rowHeight","Image","Tile","asynchronous","cache","mirror","acceptable","$opacity","state","states","transitions","data","children","resources","transform","x","y","z","implicitWidth","implicitHeight","left","right","horizontalCenter","verticalCenter","rotation","scale","opacity","visible","clip","focus","updateQmlGeometry","oldParent","newParent","newState","action","curRating","rating","transition","origValue","explicit","actions","element","filter","props","u","leftProp","topProp","maxHeight","minX","minY","$items","dict","roleNames","spacing","$item","active","sourceComponent","loaded","qmlComponent","acceptedButtons","hoverEnabled","mouseX","mouseY","containsMouse","pressedButtons","cursorShape","entered","exited","positionChanged","animations","targets","restoreEntryValues","regExp","delegate","_childrenInserted","removed","angle","xScale","yScale","anim","changes","extend","SystemPalette","Active","alternateBase","base","buttonText","dark","highlight","highlightedText","light","mid","midlight","shadow","windowText","colorGroup","systemPalettes","highlightText","inactive","disabled","Text","NoWrap","WrapAtWordBoundaryOrAnywhere","lineHeight","wrapMode","horizontalAlignment","styleColor","fc","textAlign","activeFocusOnPress","baseUrl","canPaste","canRedo","canUndo","contentHeight","contentWidth","cursorDelegate","cursorPosition","cursorRectangle","cursorVisible","effectiveHorizontalAlignment","hoveredLink","inputMethodComposing","inputMethodHints","length","lineCount","mouseSelectionMode","persistentSelection","renderType","selectByKeyboard","selectByMouse","selectedText","selectedTextColor","selectionColor","selectionEnd","selectionStart","textDocument","textFormat","textMargin","verticalAlignment","linkActivated","linkHovered","reversible","$actions","WebSocket","errorString","textMessageReceived"],"mappings":";AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACfA;ADiBA;ACfAA;ADiBA;AEnBA;AFqBA;AACA;AEnBA;AAAA;AFsBA;AErBA;AACA;AACAC;AACA;AFuBA;AErBA;AACA;AACA;AACA;AFuBA;AErBA;AACA;AFuBA;AACA;AACA;AACA;AEvBA;AACA;AACA;AFyBA;AEvBA;AACA;AACA;AACA;AACAC;AACA;AACA;AACAA;AACA;AACA;AFyBA;AEvBA;AACA;AACA;AACAC;AACA;AACA;AFyBA;AEvBA;AACA;AACA;AACA;AFyBA;AEvBA;AACA;AACA;AACA;AFyBA;AEvBA;AACA;AACA;AACA;AACA;AACA;AFyBA;AEvBA;AACA;AFyBA;AACA;AACA;AACA;AE1BA;AACA;AF4BA;AACA;AACA;AACA;AACA;AE7BAC;AF+BA;AACA;AG/FA;AAAA;AHkGA;AGjGA;AHmGA;AGjGA;AACA;AAIA;AAIA;AAKA;AAIA;AACA;AHsFA;AACA;AACA;AACA;AGtFA;AACA;AHwFA;AACA;AACA;AACA;AACA;AGzFAA;AH2FA;AIzHA;AJ2HA;AACA;AIzHA;AAAA;AJ4HA;AI3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AJ6HA;AACA;AACA;AACA;AI9HA;AACA;AJgIA;AACA;AACA;AIhIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC;AACAA;AACA;AACAC;AAKA;AACA;AACA;AACA;AJ8HA;AACA;AACA;AACA;AACA;AIhIAD;AACAA;AACAA;AACAD;AJkIA;AACA;AACA;AACA;AKhLA;AAAA;ALmLA;AKnLA;ALqLA;AKnLA;AACAG;AACAA;AAJA;AAKA;ALsLA;AACA;AACA;AACA;AKtLAH;ALwLA;AACA;AMjMA;AAAA;ANoMA;AMpMA;AAAA;ANuMA;AMvMA;ANyMA;AMxMA;AACA;AACA;AN0MA;AMxMA;AAAA;AAAA;AACA;AACA;AACA;AACA;AN4MA;AM1MA;AACA;AACA;AACA;AACA;AN4MA;AACA;AACA;AACA;AM7MAA;AN+MA;AMhNA;AAAAI;AAAA;ANoNA;AMlNA;AACA;AACA;AACAC;AACA;AACAA;AACA;AACA;AACAL;AACA;ANoNA;AACA;AACA;AMpNA;ANsNA;AMvNA;AAAAI;AAAA;AN2NA;AMzNA;AACAE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAF;AACA;AACA;AACA;AACA;AACA;AAGAA;AACA;AACA;AACA;ANyNA;AMvNA;AACA;AACA;AACA;AACA;ANyNA;AACA;AACA;AM1NA;AAAAA;AAAA;AN8NA;AM7NA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;ANgOA;AM9NA;AAOA;AACA;AACA;AACAG;AACA;AACA;AACA;AACA;AACA;AACAC;AACA;AACA;AN0NA;AMxNA;AACA;AACA;AACA;AACA;AN0NA;AACA;AACA;AM3NA;AAAAJ;AAAA;AN+NA;AM9NA;AAEA;AAAA;AAAA;AAAA;ANkOA;AMhOA;AAIA;AACA;AACA;AACA;AACA;AN+NA;AACA;AACA;AMhOA;AAAAA;AAAA;ANoOA;AMnOA;AACA;ANqOA;AACA;AACA;AMpOA;AACAK;AACA;AACAP;AAGA;AACA;ANoOA;AACA;AACA;AMnOA;AACA;AACAN;AACA;AACAA;AACA;AACA;AACAS;AACA;ANqOA;AACA;AACA;AMrOA;AACA;AACAA;ANuOA;AMrOAL;AACA;AACAK;AACA;AACAL;AACA;ANuOA;AACA;AACA;AACA;AACA;AMxOAK;AN0OA;AMxOAA;AACAA;AACAA;AACAA;AN0OA;AMxOAL;AN0OA;AOpYA;AACAU;AACA;AACA;AACA;AACA;AACA;AACAC;AACA;AACA;AACA;AACA;AACA;AACAC;AACA;AACAC;AACA;AACA;AACAC;AACA;APsYA;AOpYA;APsYA;AOpYA;AACA;AACA;AACA;APsYA;AOpYA;AACA;AACA;AACA;AACA;AACA;AAEA;AACAC;AACAC;AACA;AACA;AACA;AACA;APqYA;AOnYA;AACA;AACA;APqYA;AOnYA;AACA;AACAC;AACAC;AAFA;AAIAC;AACAA;AACAA;APqYA;AOnYAC;APqYA;AOlYAA;AACA;AACA;APoYA;AOlYAC;AACA;APoYA;AOlYA;APoYA;AOlYA;AACA;AACAJ;AACApB;AACAqB;AAHA;APwYA;AOlYA;AACAE;APoYA;AOlYA;AACAD;AACAA;AACA;AACAA;APoYA;AOlYA;APoYA;AOlYA;AACA;AAEA;AACA;AACAC;APmYA;AOjYAA;AACA;APmYA;AOjYA;AACA;APmYA;AOjYA;AACA;AACAE;AAAA;AAAA;APqYA;AOnYAC;AACA;AACA;APqYA;AOnYA;AACAC;AACAC;AACAC;AACA;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACA;AACAC;AACAC;AACA;AACAC;AACAC;AACA;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACA;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACA;AACAC;AACAC;AACAC;AACAC;AACAC;AACA;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACA;AACAC;AACAC;AACAC;AAlVA;APwtBA;AOnYAtP;APqYA;AACA;AQ1tBA;AR4tBA;AACA;AACA;AACA;AACA;AQ1tBA;AAAA;AR6tBA;AQ5tBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AR6tBA;AACA;AACA;AACA;AQ7tBA;AACAuP;AACAC;AACAxO;AAHA;AAKA;AR+tBA;AACA;AACA;AQ9tBA;AACA;AACA;ARguBA;AQ9tBA;ARguBA;AACA;AACA;AACA;AACA;AACA;AQjuBA;AACA;AACA;AACA;ARmuBA;AACA;AACA;AQluBA;AAUA;AR2tBA;AACA;AACA;AACA;AACA;AQ5tBAhB;AR8tBA;ASrxBA;AACA;AACA;AACAyP;AACAzP;ATuxBA;AU3xBA;AACA;AACAA;AV6xBA;AU3xBA;AV6xBA;AUzxBA;AV2xBA;AACA;AU1xBA;AAAA;AV6xBA;AU5xBA;AV8xBA;AU5xBA;AACA;AACA;AACA;AACA;AV8xBA;AU5xBA;AACA;AV8xBA;AU5xBA;AACA;AV8xBA;AU5xBA;AACA;AV8xBA;AU5xBA;AACA;AV8xBA;AU5xBA;AACA;AV8xBA;AU5xBA;AACA;AV8xBA;AU5xBA;AACA;AV8xBA;AU5xBA;AACA;AV8xBA;AU5xBA;AACA;AV8xBA;AU5xBA;AACA;AV8xBA;AU5xBA;AV8xBA;AU5xBA;AACA;AACA;AV8xBA;AU5xBA;AACA;AACA;AV8xBA;AU5xBA;AACA;AV8xBA;AU5xBA;AV8xBA;AU5xBA;AACA;AACA;AACA;AACA;AACAA;AAEA;AACA;AACA;AV6xBA;AU3xBA;AV6xBA;AU3xBA;AV6xBA;AACA;AACA;AACA;AACA;AU/xBAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AVmyBA;AUjyBA;AVmyBA;AACA;AACA;AACA;AUpyBA;AACA;AACA0P;AACA;AACA;AAAA;AAAA;AACA;AACA;AVwyBA;AUtyBA;AACA;AVwyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AUzyBA;AACA;AACA;AACA;AV2yBA;AUzyBA;AACA;AV2yBA;AUzyBA;AACA;AACAC;AACA;AACA;AACA;AACAA;AACA;AACA;AACAA;AACA;AACA;AACAA;AACAC;AACA;AACA;AV2yBA;AUzyBA;AACA;AV2yBA;AACA;AACA;AU1yBA;AACA;AACAC;AACA;AACA;AV4yBA;AACA;AACA;AU3yBA;AACA;AV6yBA;AU3yBA;AV6yBA;AACA;AACA;AACA;AU/yBA;AVizBA;AUhzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AVkzBA;AUhzBA;AACA;AACA;AVkzBA;AACA;AACA;AACA;AUpzBA;AAAA;AVuzBA;AUtzBA;AACA;AVwzBA;AACA;AACA;AUxzBA;AAAA;AV2zBA;AU1zBA7P;AV4zBA;AU1zBA;AACA;AACA;AACAiB;AACApB;AAFA;AV+zBA;AU1zBA;AACAsB;AACAA;AACAA;AV4zBA;AU1zBA;AACAA;AACA;AV4zBA;AU1zBA;AV4zBA;AU1zBA;AV4zBA;AU1zBA;AACA;AV4zBA;AACA;AACA;AU3zBA;AACA;AV6zBA;AU3zBA;AACA;AV6zBA;AACA;AACA;AACA;AU7zBA;AACA;AV+zBA;AU7zBA;AV+zBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AUh0BA;AACA;AACA;AACA;AACA;AACA;AVk0BA;AUh0BA;AVk0BA;AUh0BA;AACA;AACA2O;AACA;AACAA;AACA;AACA;AACAA;AACA;AACAA;AACA;AACA;AVk0BA;AACA;AACA;AUj0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AVm0BA;AACA;AACA;AUl0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AVo0BA;AACA;AACA;AUn0BA;AACA;AVq0BA;AACA;AACA;AUp0BA;AACA;AVs0BA;AUp0BA;AACA;AACA;AACA;AVs0BA;AACA;AACA;AACA;AUt0BA;AACA;AACA;AACA;AVw0BA;AACA;AACA;AUv0BA;AACA;AVy0BA;AUv0BA;AACA;AACA;AAEAC;AACA;AACA;AACA;AVw0BA;AUt0BA;AACAC;AACA;AACAD;AACA;AACA;AVw0BA;AUt0BA/P;AACA;AVw0BA;AACA;AACA;AUt0BA;AAAA;AVy0BA;AUx0BA;AACA;AV00BA;AUx0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AV00BA;AUx0BA;AACA;AACA;AV00BA;AUx0BA;AACA;AACA;AV00BA;AUx0BA;AACA;AACA;AACA;AV00BA;AACA;AACA;AUz0BA;AV20BA;AUz0BA;AACA;AACA;AACA;AACA;AACA;AV20BA;AUz0BA;AACAiQ;AACA;AACA;AACAA;AACA;AACA;AV20BA;AUz0BA;AACA;AACA;AACA;AACA;AACA;AACAC;AACA;AACA;AACA;AACA;AACAA;AACA;AACA;AACA;AACA;AV20BA;AUz0BA;AACA;AACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AV20BA;AUz0BA;AV20BA;AACA;AACA;AACA;AUz0BA;AACA;AACA;AACA;AV20BA;AACA;AUz0BA;AAEA;AACA;AACA;AACA;AV00BA;AUx0BA;AACA;AACA;AV00BA;AUx0BA;AACA;AACA;AACA;AACA;AV00BA;AUx0BA;AACA;AACA;AV00BA;AACA;AACA;AUz0BA;AACAC;AACAC;AAFA;AAIA;AV20BA;AACA;AACA;AU10BA;AACA;AV40BA;AU10BA;AV40BA;AACA;AACA;AACA;AU70BA;AV+0BA;AU90BAC;AACA;AACA;AACA;AVg1BA;AU90BA;AACA;AACAC;AACAA;AACA;AACAA;AACA;AACAA;AACA;AACAC;AACA;AACAD;AACA;AACA;AACA;AVg1BA;AU90BAD;AACA;AACA;AVg1BA;AU90BA;AACA;AACAC;AACAA;AACAA;AACA;AACAC;AACA;AACAD;AACA;AACA;AACA;AACA;AVg1BA;AACA;AACA;AU/0BA;AACA;AACA;AACA;AAAA;AAAA;AACA;AVm1BA;AUj1BA;AVm1BA;AACA;AACA;AACA;AUp1BA;AACA;AACA;AVs1BA;AUp1BA;AACA;AACA;AACA;AVs1BA;AUp1BA;AACA;AACAtP;AACA;AACA;AACA;AACA;AACA;AACAA;AACA;AACA;AACA;AACAd;AACA;AACA;AVs1BA;AUp1BAA;AACAc;AACA;AVs1BA;AUp1BA;AACA;AACA;AVs1BA;AUp1BA;AACAd;AAEA;AACA;AVq1BA;AUn1BAc;AACA;AACA;AACA;AVq1BA;AUn1BA;AVq1BA;AACA;AACA;AACA;AUt1BA;AACA;AACA;AVw1BA;AUt1BA;AACA;AACA;AACA;AVw1BA;AUt1BA;AACA;AACA;AVw1BA;AUt1BAhB;AACA;AACA;AVw1BA;AACA;AACA;AUv1BA;AACA;AVy1BA;AACA;AACA;AUx1BA;AACA;AV01BA;AACA;AACA;AUz1BA;AACA;AV21BA;AACA;AACA;AU11BA;AACA;AACA;AACA;AACA;AV41BA;AACA;AACA;AU31BA;AACA;AACA;AACA;AACA;AV61BA;AU31BA;AACA;AACA;AACA;AV61BA;AU31BA;AACAwQ;AACA;AACA;AACA;AACA;AACA;AAJA;AAAA;AVm2BA;AU71BA;AAEAC;AACA;AACA;AAEAA;AACA;AACA;AACA;AV61BA;AU31BA;AACA;AV61BA;AU31BA;AV61BA;AACA;AACA;AACA;AU91BA;AACA;AACA;AACAC;AACAC;AACAC;AAHA;AAKA;AACA;AACA;AVg2BA;AU91BA;AVg2BA;AACA;AACA;AACA;AUl2BA;AVo2BA;AUn2BA;AACA;AAEA;AACA;AVo2BA;AUl2BA;AACA;AACA;AACA;AVo2BA;AUl2BA;AACA;AACAA;AACA;AACAA;AACA;AVo2BA;AUl2BA;AACAA;AVo2BA;AUl2BA;AACA;AVo2BA;AUl2BA;AACA;AVo2BA;AACA;AACA;AACA;AUr2BA;AACA;AACA;AACA;AACA;AACA;AACA;AVu2BA;AUr2BA;AACA;AACA;AVu2BA;AACA;AACA;AUt2BA;AACA;AACA;AACA;AACAC;AACA;AACA;AACA;AVw2BA;AACA;AACA;AUv2BA;AACA;AACA;AACA;AACA;AACAC;AACA;AACA;AVy2BA;AACA;AACA;AACA;AACA;AU12BA9Q;AV42BA;AW9/CA;AACA;AACA;AACA+Q;AACA/Q;AXggDA;AYpgDA;AACA;AACA;AACA;AACAgR;AACA/P;AACApB;AACAqB;AAHA;AAKA;AACA;AACA8P;AACA/P;AACApB;AACAqB;AAHA;AAKA;AZsgDA;AYpgDA;AACA;AACA+P;AACAjR;AZsgDA;Aa3hDA;AACA;AACA;AACAkR;AACAlR;Ab6hDA;AcjiDA;AACAmR;AACAC;AACAC;AAHA;AduiDA;AcjiDArR;AdmiDA;AACA;AeziDA;AAAA;Af4iDA;Ae3iDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;Af6iDA;Ae3iDA;AACA;AACA;AACA;AACA;Af6iDA;Ae3iDA;AACA;Af6iDA;AACA;AACA;AACA;AACA;Ae/iDA;AACA;AACA;AACAiB;AACApB;AACAqB;AAHA;AAKA;AACA;AACA;AAEA;AACAD;AACApB;AACAqB;AAHA;AAKA;AfgjDA;AACA;AACA;Ae9iDA;AACA;AACA;AACAD;AACApB;AACAqB;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AfgjDA;Ae9iDA;AACA;AfgjDA;AACA;AACA;AACA;AejjDA;AfmjDA;AejjDA;AACA;AACA;AfmjDA;AejjDA;AfmjDA;AejjDA;AACAoQ;AACA;AACA;AACA;AACA;AAEA;AACApR;AAIA;AACAoR;AACA;Af+iDA;Ae7iDA;AACA;AACAC;AACAf;AACAgB;AACAC;AAJA;AAMA;AACA;Af+iDA;Ae7iDA;AACA;AACA;AACA;Af+iDA;Ae7iDA;Af+iDA;AACA;AACA;AACA;AehjDA;AACA;AAEA;AACA;AfijDA;Ae/iDA;AACA;AACA;AACA;AACA;AAKA;Af6iDA;Ae3iDA;AACA;AACA;Af6iDA;Ae3iDA;AACA;AACA;Af6iDA;AACA;AACA;AACA;Ae9iDA;AfgjDA;Ae9iDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AfgjDA;Ae9iDA;AACA;AACAC;AACA;AACA;AACAJ;AACA;AACAI;AAEA;AACAJ;AACA;AACA;AACAtR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA0R;AACA;AACA;Af+iDA;Ae7iDA;AACA;AACAA;AACA;AACA;Af+iDA;Ae7iDA;Af+iDA;Ae7iDA;AACA;AACA;AACA;AACAH;AACAf;AACAgB;AACAC;AAJA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;Af8iDA;AACA;AACA;Ae7iDAH;AAGAA;AACAA;AACA;AACA;Af6iDA;AACA;AACA;Ae5iDAA;AAEAA;AAIA;Af0iDA;AACA;AACA;AeziDA;AACA;AACA;AACA;AACApR;AAIA;AACAoR;AACAA;AACA;AfwiDA;AACA;AACA;AeviDAA;AACAA;AAGA;AfuiDA;AACA;AACA;AACA;AACA;AexiDA;AACA;AACA;Af0iDA;AACA;Ae1iDAA;AACAA;AACAA;AACAA;Af4iDA;Ae1iDAA;AACAK;AACAC;AACAC;AACAC;AACAC;AACAf;AACAgB;AACAC;AARA;AfqjDA;Ae1iDAX;AACAA;AACAA;Af4iDA;Ae1iDAtR;Af4iDA;AgB7yDA;AACA;AACA;AACAkS;AACAlS;AhB+yDA;AiBnzDA;AACA;AACA;AACAmS;AACAnS;AjBqzDA;AkBzzDA;AACA;AACA;AACAoS;AACApS;AlB2zDA;AmB/zDAqS;AACA;AACA;AACA;AACA;AACA;AACArS;AACAA;AACAA;AACA;AACA;AACA;AACA;AnBi0DA;AoB70DA;AACAsS;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AAXA;ApB21DA;AoB70DA;AACAhT;AACA;AACA;AACA;AACA;ApB+0DA;AoB70DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ApB+0DA;AoB70DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ApB+0DA;AoB70DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ApB+0DA;AoB70DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ApB+0DA;AoB70DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ApB+0DA;AoB70DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ApB+0DA;AoB70DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ApB+0DA;AoB70DA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;ApB00DA;AoBv0DA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ApBo0DA;AoBl0DA;AACA;AACAE;AACA;AAlNA;AAoNA;ApBo0DA;AoBl0DAF;ApBo0DA;AqB1iEA;ArB4iEA;AqB1iEA;AACAiT;AACAC;AACAC;AACAC;AAHA;AAKA;ArB4iEA;AqB1iEA;AACAH;AACAI;AACAF;AACAC;AAHA;AAKA;ArB4iEA;AqB1iEA;AACAH;AACAC;AACAG;AACAF;AACAC;AAJA;AAMA;ArB4iEA;AqB1iEApT;AACAA;AACAA;ArB4iEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AsB/kEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AtBilEA;AACA;AACA;AsBjlEA;AtBmlEA;AsBplEA;AAAAI;AAAA;AtBwlEA;AsBtlEA;AACA;AACA;AACA;AACA;AACA;AACAkT;AACA;AACA;AACA;AACA;AtBwlEA;AACA;AACA;AACA;AACA;AsBzlEAtT;AtB2lEA;AuBvnEA;AvBynEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AuBtnEA;AvBwnEA;AACA;AACA;AACA;AACA;AACA;AACA;AuBtnEA;AACA;AACA;AACAuT;AvBwnEA;AuBtnEA;AACA;AACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA;AACA;AvBwnEA;AuBtnEA;AAAA;AACArT;AACA;AACA;AACAF;AACA;AACA;AACA;AACA;AACAA;AACA;AvBynEA;AuBvnEA;AvBynEA;AACA;AACA;AACA;AACA;AACA;AuBvnEA;AvBynEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AuBvnEA;AACA;AACA;AACA;AvBynEA;AuBvnEA;AvBynEA;AuBvnEA;AACA;AACAwT;AACA;AACAA;AACA;AvBynEA;AuBvnEA;AACA;AvBynEA;AuBvnEA;AACA;AACA;AvBynEA;AuBvnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AvBynEA;AuBvnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAtT;AACA;AACAuT;AACA;AACAC;AACA;AACAA;AACA;AACA;AACAxT;AACA;AACA;AACA;AACA;AvBynEA;AuBvnEAF;AACAA;AvBynEA;AwB9wEA;AACA;AACA;AACA;AACA;AAIA;AAAA;AAEA;AxB6wEA;AwB3wEAA;AxB6wEA;AyBzxEAA;AACA;AACAuQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AzB2xEA;AyBzxEAvQ;AAAA;AACA2T;AACAC;AACAC;AACAC;AACAC;AAKAC;AAVA;AAAA;AzBoyEA;AyBvxEAhU;AACA;AAKA;AACA;AACA;AACAA;AACA;AzBqxEA;A0BxzEAA;A1B0zEA;A0BxzEA;AACAiU;AACAtC;AACAC;AACAC;AACAC;AACAC;AACAf;AACAkD;AACAlC;AACAC;AACAkC;AACAC;AAXA;AADA;A1Bw0EA;A0BxzEA;AACApU;A1B0zEA;A0BxzEA;A1B0zEA;A0BxzEA;AACA;A1B0zEA;A0BxzEA;AACA;AACAA;AACAA;AACAqU;AACA;A1B0zEA;A0BxzEA;AACA;AACA;AACAC;AACA;A1B0zEA;A0BxzEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACAC;AACAC;AACA;AACAD;AACAC;AACA;AACA;AACA;AAAA;AACA;AACA;AACAF;AACA;AACA;AACA;AACA;AACAG;AACA;AACAA;AACA;AAAA;AAAA;AACA;AAzBA;A1Bw1EA;A0Bx1EA;AA0BA;A1Bi0EA;A0B/zEA;AACAC;AACAzE;AACA0E;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AATA;A1B20EA;A0B/zEAC;AACAL;AACAC;AACAC;AACAC;AAJA;A1Bs0EA;A0B/zEA;AACAG;AACA;A1Bi0EA;A0B/zEA;AACAlF;AACA0E;AACAM;AAHA;A1Bq0EA;A0B/zEA;AACAZ;AACA;AACAA;A1Bi0EA;A0B9zEA;AACAe;AACA;A1Bg0EA;A0B9zEA;AACA;AACAX;AAAA;AAAA;AACAA;AACA;AACA;A1Bk0EA;A0Bh0EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A1Bk0EA;A0Bh0EA;AACA;AACA;AACAvU;AACA;AACA;AACA;AACA;AACA;AACAmV;AACA;AACA;AACA;AACA;A1Bk0EA;A0Bh0EA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACAC;AACA;AACA;AAAA;AAAA;AAAA;AAAA;A1By0EA;A0Bv0EA;A1By0EA;A0Bv0EA;AACAD;AAIA;AACAA;AACA;AACA;AACAE;AACAC;AACAxV;AACA;A1Bs0EA;A0Bp0EA;AACA;AACAiV;AACAhC;AACAgC;AACA;AACAA;AACA;A1Bs0EA;A0Bp0EA;AACA;AACAQ;AACAA;A1Bs0EA;A0Bp0EA;AACA;AACAxC;AACAsC;A1Bs0EA;A0Bp0EA;AACA3V;AACA;AACA;AACA;AACA;AACAqT;AACA;AACA;AACAxS;AACA;AACAT;AACA;AACA;AACA;AACAiT;AACA;AACAsC;AACA;AACA;AACA;AACAA;AACA;AACA;A1Bs0EA;A0Bp0EA;A1Bs0EA;AACA;AACA;AACA;AACA;A0Bp0EA;AACA;A1Bs0EA;A0Bp0EA;A1Bs0EA;A0Bp0EA;AACA;AACA;AACAF;AACA;AACA;AACA;AACA;A1Bs0EA;A0Bp0EA;AACA;AACAI;AACA3V;AACA2V;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A1Bs0EA;A0Bp0EA;A1Bs0EA;A0Bp0EAzV;A1Bs0EA;A0Bp0EA;AACA;AACA0V;AACA;AACA;AAGAA;AACA;AACAA;AACA;A1Bo0EA;A0Bl0EA;A1Bo0EA;A0Bl0EA;AACA;AACA;A1Bo0EA;A0Bl0EA5V;AACA;AACAA;AACA;AACAA;AACA;AACA;AACA;AACA;A1Bo0EA;A0Bl0EA;AACA;AACAE;AAEA;AAAA;AAGA;A1Bk0EA;A0Bh0EA;AACAF;A1Bk0EA;A0Bh0EA;AACAA;A1Bk0EA;A0Bh0EA;AACAE;A1Bk0EA;A0Bh0EA;AACA;A1Bk0EA;A0Bh0EAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;A1Bk0EA;A2BpnFA;A3BsnFA;AACA;AACA;AACA;AACA;A2BpnFA;AAAA;A3BunFA;A2BtnFA;AACA;AACAyQ;AACAA;AACAA;A3BwnFA;A2BtnFA;AAAA;AAAA;AACA;AACA;AACAkF;AACA;AACA;AACA;AACAlF;AACA;AACA;AACAkF;AACAlF;AACA;AACA;AACAzQ;AACA;AACAA;AACA;AACA;A3B0nFA;A2BxnFA;A3B0nFA;AACA;AACA;AACA;AACA;AACA;AACA;A2BxnFA;AACA;AACA;AACAA;A3B0nFA;A2BxnFA;AACA;AACAF;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA;AACA;A3BunFA;A2BrnFA;AACA;AACA;AAAA;AACAA;AACA;AACA;A3BwnFA;A2BtnFA;AACA;AAAA;AACA;AACA;A3BynFA;A2BvnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA;AACA;AACA;AACA;A3BynFA;A2BvnFA;AACA;AACA;AACA;AACA;A3BynFA;A2BvnFA;AACAA;AAEA;AACAA;AACA;AACAA;AACA;AACAI;AAGA;AACA;AACA;A3BsnFA;A2BpnFA;AACA;A3BsnFA;A2BpnFA;AACAJ;AACA;AACA8V;AACA;AACA;AACA;A3BsnFA;A2BpnFA;AACA5F;AACAlQ;AAEA;AACA8V;AACA;AACA;AACA;A3BqnFA;A2BnnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzV;AACAL;AACAA;AACAA;AACAA;AACA;AACA;AACA;AACA;AACAA;AAEA;AACA;AACA;AACA;AACA;AACAC;AACA;A3BonFA;A2BlnFA;AACA;AACA;AACA;AACAG;AAEA;AAAA;AACA;AACA;AACAA;AAIA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA2V;AAAA;AAAAzV;AAAA;A3BqnFA;A2BpnFA;AACA0V;AACA/V;AACA+V;AACA;AACA/V;AAAA;AAAAK;AAAA;A3BynFA;A2BxnFA;AACA0V;AACAD;AACAC;AACA;AApBA;AAqBA;AA5BA;AA6BA;AACA;AACA9V;AACA;AACA;AACA;A3B4nFA;A2B1nFA;AACAG;AACAL;AAEA;AACA;A3B2nFA;A2BznFA;AACA;AACAiW;AACA;AACA;A3B2nFA;A2BznFA;AACA;A3B2nFA;A2BznFA;AACA;AACA7V;AACA;AACA;AACAA;AACA;AACA;A3B2nFA;A2BznFA;AACA;AACA;AACA8V;AACA;AACA;AACAhG;AAcAA;AACAA;AACA;AACA;AACA;AACA;AACAlQ;AACA;AACA;A3B8mFA;A2B5mFAE;AACAA;AACAA;A3B8mFA;A4B72FA;A5B+2FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A4Bt3FA;A5Bw3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A4Bx3FA;A5B03FA;A4Bz3FA;AACA;AACA;A5B23FA;AACA;A4Bx3FA;A5B03FA;A4Bz3FA;AACA;AACA;A5B23FA;A4Bx3FA;A5B03FA;AACA;AACA;AACA;AACA;AACA;AACA;A4B13FA;A5B43FA;A4B33FA;AACA;A5B63FA;A4B13FA;A5B43FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A4B73FA;A5B+3FA;AACA;AACA;AACA;AACA;AACA;AACA;A4B/3FA;A5Bi4FA;A4Bh4FA;AACA;AACA;AACA;A5Bk4FA;A4B/3FA;A5Bi4FA;AACA;A4Bj4FA;AACA;AACA;A5Bm4FA;A4Bj4FA;AACA;AACA;AACA;AACA4Q;AACAqF;AACA;AACArF;AACA;AACA;A5Bm4FA;A4Bj4FA;AACA;AACA;AACA;AACA;AACAsF;AACA;AACAA;AACAD;AACA;AACAC;AACA;A5Bm4FA;A4Bj4FAC;AACAC;AACA;AACAtW;AACAA;AACA;AACA;AACAuW;AACA;A5Bm4FA;A4Bj4FA;AACA;AACA;AACA;AACA;AACA;AACAvW;AACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACAwW;AACA;AACA;AACAxW;AACA;AACA;AACA;AAGA;AACA;AACAA;AACA;AACAA;AACA;AACA;AACA;AACAI;AA3BA;AA6BA;AACA;AACA;AACAJ;AACA;A5Bi4FA;A4B/3FA;AACA;AACAyW;AACA;AACA;AACA;AACA;AACA;AACA;AACAC;AAAA;AAAA;AAEAC;AACA;AACA;AACA;AACA;AACA;AACA;AACAH;AACA;AACA;AACA;AACA;AACAI;AAAA;AAAA;AAEAC;AAAA;AAAA;AAKAC;AAAA;AAAA;AAEAC;AAAA;AAAA;AAEAC;AAAA;AAAA;AACA7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA8G;AAAA;AAAA;AACAjF;AAAA;AAAA;AACAkF;AACA;AACA;AACA;AACA;AACA;AACAC;A5By4FA;A4Bv4FA;AACAC;AACA;AACAC;AACA;AACA;A5By4FA;A4Bv4FA;AACA;AACA;AAGA;AACA;AACA;A5Bu4FA;A4Br4FA;AACA;AAxHA;A5BggGA;A4Br4FAhB;AACA;AACA;AACA;AACAjW;AACA;AACA;AACA;AACA;A5Bu4FA;A4Br4FA;AACAiW;AACA;AACA;AACA;A5Bu4FA;A4Br4FA;AACA;AACA;AACA;AACA;AACA;AACA;A5Bu4FA;A4Br4FA;AACAA;AACAjW;AACA;AACA;A5Bu4FA;A4Br4FA;AACA;AACA;AACA;A5Bu4FA;A4Br4FAA;AACA;AACA;AACA;AACA;AACA;AACA;AACAqT;AACAA;AACA;AACA;AACA;AACA;AACA;AACAvT;AACAA;AACA;AACA;AACA;AACA;A5Bu4FA;A4Br4FA;AACA;AACAoX;AACApX;AACA;AACA;AACA;A5Bu4FA;A4Br4FAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;A5Bu4FA;A6BvrGA;A7ByrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A6BvrGAA;A7ByrGA;A8BttGAA;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAqC;AADA;AALA;AASA;AAAA;A9BytGA;A8BxtGArX;A9B0tGA;A8BxtGA;AACA;A9B0tGA;A8BxtGA;AACA;A9B0tGA;A8B1uGA;AAAA;A9B6uGA;A+B7uGAA;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACA/C;AACAqF;AACAC;AACAC;AACAlX;AACAmX;AAFA;AAJA;AASA3C;AACA4C;AACAC;AAFA;AAdA;AAmBA;AAAA;A/BgvGA;A+B/uGA3X;A/BivGA;A+B/uGA;AACA;AACA;A/BivGA;A+BzwGA;AAAA;AAAA;AAyBA;A/BqvGA;A+BpvGA;AACA4X;AACAL;AACAM;AACA;AACA;AACA;AANA;AAQA;AAlCA;AAAA;AAAA;AAmCA;A/ByvGA;A+BxvGA;AACAD;AACAC;AACA;AACA;AAJA;AAMA;AA1CA;AAAA;AAAA;AA4CA;AACA;AA7CA;AAAA;AAAA;AA+CA;AACA;AAhDA;AAAA;AAAA;AAiDA;A/BiwGA;A+BhwGA;AACAD;AACAL;AACAO;AACAD;AACA;AACA;AACA;AAPA;AASA;AA3DA;AAAA;AAAA;AA6DA;AACA;AACA5W;AACA;AACAf;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AA1EA;AAAA;AAAA;AA4EA;AACA;AACA;AACA;AACA;AACA4T;AACA;AACA;AACAiE;AACA;AACA;AACA;AACAA;AACA;AACA;AACA;AACA;AACA;AA7FA;AAAA;AAAA;AA+FA;AAAA;AAAA;AAGA;AAlGA;AAAA;AAAA;AAmGA;A/B2wGA;A+B1wGA;AACAxE;AACAA;AACA;AACA;AACAe;AACA;AACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAf;AACA;AACAA;AACAA;AACA;AACAA;AACA;AACA;AACA;AACA;AA5HA;AAAA;AAAA;AA8HA;AACA;AACAyE;AACA;AACA;AACA;AAnIA;AAAA;AAAA;AAqIA;AACA;AACA;AACA;AACA;AACA;AACA;AA3IA;AAAA;AAAA;AA6IA;AACA;AA9IA;A/Bi6GA;A+Bj6GA;AAAA;A/Bo6GA;AgCp6GAhY;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAiD;AADA;AALA;AASA;AAAA;AhCu6GA;AgCt6GAjY;AhCw6GA;AgCt6GA;AACA;AACA;AhCw6GA;AgCt6GA;AACA;AhCw6GA;AgCz7GA;AAAA;AAAA;AAmBA;AACA;AACA;AArBA;AAAA;AAAA;AAuBA;AACA;AAxBA;AAAA;AAAA;AAyBA;AhCg7GA;AgC/6GA;AACA;AhCi7GA;AgC/6GA;AACA;AACA;AACA;AAhCA;AAAA;AAAA;AAiCA;AhCo7GA;AgCn7GA;AACA;AhCq7GA;AgCn7GA;AACA;AhCq7GA;AgCn7GA;AACAkY;AACAC;AACA;AhCq7GA;AgCn7GAD;AACAE;AACA;AACA;AACA;AAjDA;AhCu+GA;AgCv+GA;AAAA;AhC0+GA;AiC1+GApY;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAqD;AACAC;AAFA;AALA;AAUA;AAAA;AjC6+GA;AiC5+GAtY;AjC8+GA;AiC5+GA;AACA;AjC8+GA;AiC5+GA;AACA;AACA;AjC8+GA;AiChgHA;AAAA;AAAA;AAoBA;AACA;AArBA;AAAA;AAAA;AAuBA;AACA;AAxBA;AAAA;AAAA;AA0BA;AACAuY;AACAC;AACAC;AAHA;AAKA;AA/BA;AAAA;AAAA;AAiCAvY;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA;AACAoY;AACAA;AACA;AACA;AACA;AACA;AACA;AAhDA;AjCwiHA;AiCxiHA;AAAA;AjC2iHA;AkC3iHAtY;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACA0D;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AATA;AALA;AAiBA;AAAA;AlC8iHA;AkC9iHA;AlCgjHA;AkC/iHAlZ;AlCijHA;AkC/iHA;AACA;AACA;AlCijHA;AkC/iHAmZ;AAAA;AAAA;AACAA;AAAA;AAAA;AACA;AlCqjHA;AkC/kHA;AAAA;AAAA;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApCA;AlC6lHA;AkC7lHA;AAAA;AlCgmHA;AmChmHAnZ;AACA0U;AACAzE;AACA0E;AACAC;AACAC;AACAuE;AACAC;AACAC;AnCkmHA;AmChmHAC;AnCkmHA;AmChmHAC;AACAC;AAPA;AASAC;AAVA;AAYA1E;AACAsD;AACAqB;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AAXA;AAaAtF;AACAuF;AACAC;AACAC;AAHA;AA9BA;AAoCA;AAAA;AnCmmHA;AmCnmHA;AnCqmHA;AmCpmHAva;AnCsmHA;AmCpmHA;AnCsmHA;AmCpmHA;AACA;AACA;AACA;AnCsmHA;AmCpmHA;AACA;AnCsmHA;AmCpmHA;AACA;AACA;AACA;AnCsmHA;AmCpmHA;AACA;AACA;AACA;AnCsmHA;AmCpmHA;AACA;AACA;AACA;AACA;AnCsmHA;AmCpmHA;AACA;AACA;AACA;AnCsmHA;AmCpmHA;AACA;AACA;AACA;AAGA;AACA;AnComHA;AmClmHA;AACA;AACA;AnComHA;AmClmHA;AACA;AACA;AnComHA;AmClmHA;AACA;AACA;AnComHA;AmClmHA;AACA;AACA;AnComHA;AmClmHA;AACA;AACA;AACA;AACA;AnComHA;AmClmHA;AACA;AACA;AnComHA;AmClmHA;AACA;AACA;AnComHA;AmClmHA;AACA;AACA;AACA;AACA;AnComHA;AmClmHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AnComHA;AmC9tHA;AAAA;AAAA;AA4HA;AACA;AA7HA;AAAA;AAAA;AA+HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtIA;AAAA;AAAA;AAwIA;AACA;AACA;AA1IA;AAAA;AAAA;AA4IA;AACA;AACA;AA9IA;AAAA;AAAA;AAgJA;AACA;AACA;AAlJA;AAAA;AAAA;AAoJA;AACA;AACA;AACA;AACA;AACA;AACA;AA1JA;AAAA;AAAA;AA4JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AAvKA;AAAA;AAAA;AAyKA;AACA;AA1KA;AAAA;AAAA;AA4KA;AACA;AA7KA;AAAA;AAAA;AA+KA;AACA;AAhLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoLA;AACAwa;AACAC;AACAC;AACAC;AACAC;AALA;AAOA;AACA;AA5LA;AnCyzHA;AmCzzHA;AAAA;AnC4zHA;AoC5zHA5a;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAzD;AACAf;AACAR;AACA6K;AAJA;AALA;AAYA;AAAA;ApC+zHA;AoC9zHA7a;ApCg0HA;AoC9zHA;ApCg0HA;AoC9zHA;AACA;AACA;AACA;AACA;ApCg0HA;AoCr1HA;AAAA;AAAA;AAwBA;AAIA;AACA;AACA;AACA;AACA;AACA;AAjCA;AAAA;AAAA;AAoCA;AACA;AACA;AACA;AAvCA;ApCw2HA;AoCx2HA;AAAA;ApC22HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AqCj3HA;AACA;AACA;AACA;AACA;AACA;AACA;ArCm3HA;AACA;AACA;AACA;AACA;AACA;AqCp3HA;AAAA;ArCu3HA;AqCv3HA;ArCy3HA;AqCx3HA;AACA;AACA;AACA;AACA;AACA;ArC03HA;AqCx3HA;ArC03HA;AqCx3HA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA8a;AACA;AACA;ArC23HA;AqCz3HA;AACAC;AACA;AACA/a;AACA;AACA;AACA;AAhBA;AAiBA;ArC43HA;AqC13HA;ArC43HA;AACA;AqC13HA;AACA;AACA;AACA;ArC43HA;AACA;AACA;AACA;AqC73HA;AACA;AACA;AACA;ArC+3HA;AqC73HA;AACAE;AAEA;AACA;ArC83HA;AqC53HA;AACA8a;AACAhb;AACA;AACAA;AACA;AACA;AACA;ArC83HA;AACA;AACA;AqC/3HA;AAAA;ArCk4HA;AqCj4HA;AACA;AACAoB;AACA;AACA;AACAA;ArCm4HA;AqCj4HA;ArCm4HA;AqCj4HA;AACA6Z;AACA;ArCm4HA;AqCj4HA;AACAha;AACApB;AACAqB;AACAga;AAJA;ArCw4HA;AqCj4HAjI;AACAnT;AACA;ArCm4HA;AqCj4HA;AACA;AACAsB;ArCm4HA;AqCj4HAA;AACA;AACA;ArCm4HA;AACA;AACA;AqCp4HA;ArCs4HA;AqCr4HA;AACA;ArCu4HA;AqCr4HA;AACAtB;AACA;ArCu4HA;AqCr4HA;AACA;ArCu4HA;AACA;AACA;AqCv4HA;AACA;AACA;AACAE;ArCy4HA;AqCv4HA;AACA;AACA;AACA;ArCy4HA;AACA;AACA;AACA;AACA;AqC14HAA;AACAJ;AACA8U;AACAzE;AACA0E;AACAC;AACAK;AANA;ArCm5HA;AsC7gIAjV;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAzD;AACA4J;AAFA;AALA;AAUA;AAAA;AtCghIA;AsC/gIAnb;AACA;AACA;AtCihIA;AsC/gIA;AACA;AACA;AACA;AtCihIA;AsCniIA;AAAA;AAAA;AAoBA;AACA;AArBA;AAAA;AAAA;AAuBA;AACA;AAxBA;AAAA;AAAA;AA0BA;AACA;AACA;AACA;AAEAob;AACA;AACA;AACAC;AAEA;AACA;AACA;AACA;AAvCA;AAAA;AAAA;AAyCA;AACA;AA1CA;AtCmkIA;AsCnkIA;AAAA;AtCskIA;AuCtkIA;AvCwkIA;AuCtkIArb;AACA0U;AACAzE;AACA0E;AAHA;AAAA;AvC6kIA;AuCxkIA;AAAA;AvC2kIA;AuC3kIA;AvC6kIA;AuC1kIA;AACA;AvC4kIA;AuC1kIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AvC4kIA;AuC1kIA;AvC4kIA;AuC1kIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9CA;AA+CA;AvC6kIA;AuCjoIA;AAAA;AAAA;AAsDA;AACA;AAvDA;AvCwoIA;AuCxoIA;AAAA;AvC2oIA;AwC7oIA3U;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAsG;AACAzb;AACA0b;AACAC;AACAC;AALA;AAOA3G;AACA4G;AADA;AAZA;AAgBA;AAAA;AxCgpIA;AwChpIA;AxCkpIA;AwCjpIA1b;AxCmpIA;AwCjpIA;AxCmpIA;AwCjpIA;AxCmpIA;AwCjpIA;AxCmpIA;AwCjpIAA;AAAA;AAAA;AxCqpIA;AwCnpIAA;AACA;AACA;AACA;AACA;AxCqpIA;AwCnpIAA;AAAA;AAAA;AACA;AxCupIA;AwCzrIA;AAAA;AAAA;AAoCA;AACA;AArCA;AAAA;AAAA;AAuCA;AACA;AAxCA;AAAA;AAAA;AA0CA;AACA;AACA;AA5CA;AAAA;AAAA;AA8CA;AACA;AACA;AACA;AACA;AACA;AAnDA;AAAA;AAAA;AAqDA;AACA;AACA;AACA;AACA;AACA;AACA;AA3DA;AAAA;AAAA;AA6DA;AACA;AACA;AACA;AACA;AxCoqIA;AwClqIA;AACA;AxCoqIA;AwClqIA;AACA;AACA;AACA;AACA;AA1EA;AxC+uIA;AwC/uIA;AAAA;AxCkvIA;AyClvIAA;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAhB;AACA2H;AAFA;AAIA7G;AACA8G;AADA;AATA;AAaA;AAAA;AzCqvIA;AyCrvIA;AzCuvIA;AyCtvIA5b;AzCwvIA;AyCtvIA;AACA;AACA;AzCwvIA;AyCtvIA;AACA6b;AACA;AzCwvIA;AyCtvIAA;AACA;AACA;AACA;AzCwvIA;AyCnxIA;AAAA;AAAA;AA6BA;AACA;AACA;AA/BA;AAAA;AAAA;AAiCA;AACA;AACA;AACA;AACA;AArCA;AAAA;AAAA;AAuCA;AACA;AAxCA;AzCwyIA;AyCxyIA;AAAA;AzC2yIA;A0C3yIA7b;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAhB;AACA8H;AACA5H;AAHA;AALA;AAWA;AAAA;A1C8yIA;A0C9yIA;A1CgzIA;A0C/yIAlU;A1CizIA;A0C/yIA;AACA;A1CizIA;A0C/yIA;AACA+b;AACAA;AACAA;AACA;AACA;AACA;A1CizIA;A0C/yIA;AACA;A1CizIA;A0C/yIA;A1CizIA;A0C/yIA;AACA;A1CizIA;A0C/yIA;AACA;AACA;AACA;AACA;A1CizIA;A0Ct1IA;AAAA;AAAA;AAuCA;AACA;AACA;AAGA;AA5CA;AAAA;AAAA;AA8CA;AACA;AA/CA;AAAA;AAAA;AAiDA;AACA;AAlDA;AAAA;AAAA;AAoDA;AACA;AAGA;AAxDA;A1C+2IA;A0C/2IA;AAAA;A1Ck3IA;A2Cl3IA/b;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACApB;AACAoI;AACAC;AACAC;AACAC;AACAC;AANA;AAQAtH;AACAnB;AACA0I;AAFA;AAbA;AAkBA;AAAA;A3Cq3IA;A2Cr3IA;A3Cu3IA;A2Ct3IArc;A3Cw3IA;A2Ct3IA;AACA;A3Cw3IA;A2Ct3IA;AACA;A3Cw3IA;A2Ct3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A3Cw3IA;A2C15IA;AAAA;AAAA;AAoCA;AACA;AArCA;AAAA;AAAA;AAuCA;AACA;AAxCA;AAAA;AAAA;AA0CA;AACA;AA3CA;AAAA;AAAA;AA6CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAsc;AACA;AACA;AACA;AACA;AACA;AA7DA;AAAA;AAAA;AA+DA;AACA;AACA;AACA;AAlEA;AAAA;AAAA;AAoEA;AACA;AArEA;A3C28IA;A2C38IA;AAAA;A3C88IA;A4C98IAtc;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAuH;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AARA;AAUA/H;AAfA;AAiBA;AAAA;A5Ci9IA;A4Ch9IA/U;A5Ck9IA;A4Ch9IA;AACA;A5Ck9IA;A4Ch9IA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;A5Cg9IA;A4C98IA;AACA;AACA;AACA;A5Cg9IA;A4C98IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A5Cg9IA;A4ClgJA;AAAA;AAAA;AAoDA;AACA+c;AACA;AACA;AAvDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+DA;AAGA;AAlEA;AAAA;AAAA;AAoEA;AACA;AArEA;AAAA;AAAA;AAuEA;AACA;AAxEA;AAAA;AAAA;AA0EA;AACA;AA3EA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+EA;AACA;AACA;AACA;AAlFA;AAAA;AAAA;AAoFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AA9FA;A5CgkJA;A4ChkJA;AAAA;A5CmkJA;A6CnkJA/c;AACA0U;AACAzE;AACA0E;AACAC;AAJA;AAMA;AAAA;A7CskJA;A6CrkJA5U;AACA;AACAgd;AACAA;AACAA;AACA;A7CukJA;A6CnlJA;AAAA;A7CslJA;A8CtlJA;A9CwlJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A8CtlJAhd;AACA0U;AACAzE;AACA0E;AACAC;AACAC;AACAoI;AADA;AAGAjI;AACAhB;AACAkJ;AACAC;AACAC;AACAC;AALA;AAOAvI;AACAnB;AADA;AAfA;AAmBA;AAAA;A9CylJA;A8CzlJA;A9C2lJA;A8C1lJA3T;A9C4lJA;A8C1lJA;AACA;A9C4lJA;A8C1lJA;AACAsd;AACAA;AACAA;AACAA;AACAA;AACA;AACA;AACAA;A9C4lJA;A8C1lJA;AACA;AACA;AACA;AACA;AACA;A9C4lJA;A8C1lJA;AAAA;AAAA;AACA;A9C8lJA;A8CzoJA;AAAA;AAAA;AA6CA;AACA;AACA;AA/CA;AAAA;AAAA;AAiDA;AACA;AACA;AACA;AACA;AArDA;AAAA;AAAA;AAuDA;AACA;AACA;AACA;AACAA;AACA;AACA;AACAA;AACA;AACA;AACA;AACAA;AACA;AACA;AACA;AACAA;AACA;AAdA;AAgBA;AAzEA;AAAA;AAAA;AA2EA;AACA;AA5EA;AAAA;AAAA;AA8EA;AACA;AA/EA;AAAA;AAAA;AAiFA;AACA;AACA;AACA;AACA/M;AACA;AACA;AAvFA;AAAA;AAAA;AAyFA;AACA;AACA;AACA;AACA;AA7FA;AAAA;AAAA;AA+FA;AACA;AACA;AACA;AACA;AACA;AApGA;A9CotJA;A8CptJA;AAAA;A9CutJA;A+CnuJAvQ;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACA/E;AACAsN;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAzN;AACAD;AAVA;AALA;AAkBA;AAAA;A/CsuJA;A+CruJAnQ;A/CuuJA;A+CruJA;AACA;AACA;A/CuuJA;A+C9vJA;AAAA;AAAA;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApCA;A/C+wJA;A+C/wJA;AAAA;A/CkxJA;AgDlxJAA;AACA0U;AACAzE;AACA0E;AACAC;AAJA;AAMA;AAAA;AhDqxJA;AgDpxJA5U;AACA;AhDsxJA;AgD9xJA;AAAA;AhDiyJA;AiDjyJAA;AACA0U;AACAzE;AACA0E;AACAC;AACAC;AACAiJ;AACAC;AAFA;AAIA/I;AACAgJ;AACAC;AACA5D;AACAmB;AAJA;AATA;AAgBA;AAAA;AjDoyJA;AiDnyJAxb;AACA;AjDqyJA;AiDvzJA;AAAA;AAAA;AAoBA;AACA;AACA;AAtBA;AAAA;AAAA;AAwBA;AACA;AAzBA;AAAA;AAAA;AA2BA;AACA;AA5BA;AAAA;AAAA;AA8BA;AACA;AA/BA;AAAA;AAAA;AAiCA;AACA;AAlCA;AAAA;AAAA;AAoCA;AACAE;AACA;AAtCA;AjDy1JA;AiDz1JA;AAAA;AjD41JA;AkD51JAF;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAkJ;AACAvC;AAFA;AAIA5G;AATA;AAWA;AAAA;AlD+1JA;AkD91JA/U;AACA;AlDg2JA;AkD91JA;AACA;AACA;AlDg2JA;AkDj3JA;AAAA;AAAA;AAmBAme;AACAA;AACA;AACA;AAtBA;AAAA;AAAA;AAwBA;AAGA;AA3BA;AlD+3JA;AkD/3JA;AAAA;AlDk4JA;AmDl4JAne;AACA0U;AACAzE;AACA0E;AACAC;AACAC;AACAuJ;AACAC;AACAC;AAFA;AADA;AAMAtJ;AACAsD;AACAiG;AACA;AACAC;AACA;AACAC;AACAC;AACAvE;AARA;AAXA;AAsBA;AAAA;AnDq4JA;AmDr4JA;AnDu4JA;AmDt4JAna;AnDw4JA;AmDt4JA;AACA;AACAG;AACAA;AACAA;AACAA;AnDw4JA;AmDt4JA;AACAwe;AACAA;AACAA;AACA;AnDw4JA;AmDt4JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AnDw4JA;AmDt4JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AnDw4JA;AmD/7JA;AAAA;AAAA;AAyDA;AACA;AACA;AACA;AACA7B;AACAA;AACA;AACA;AACA;AACA;AACA;AACA;AApEA;AAAA;AAAA;AAsEA;AADA;AAAA;AAAA;AAAA;AAAA;AnDm5JA;AmDh5JA;AACA;AACA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACA;AAjFA;AAAA;AAAA;AAmFA;AACA;AACAA;AACA;AACAA;AACAA;AACAA;AACAA;AACA;AACA;AA5FA;AnDi/JA;AmDj/JA;AAAA;AnDo/JA;AoDp/JA;AACA;ApDs/JA;AoDp/JA9c;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACA4J;AACAC;AACAC;AACA5d;AACA6d;AACAC;AACAC;AACAC;AARA;AAUApK;AACAqK;AACAC;AACAC;AAHA;AAfA;AAqBA;AAAA;ApDu/JA;AoDt/JArf;AACA;ApDw/JA;AoD/gKA;AAAA;AAAA;AAyBA;AACA;AA1BA;AAAA;AAAA;AA4BA;AACA;AA7BA;AAAA;AAAA;AA+BA;AACA;AAhCA;AAAA;AAAA;AAkCA;AACA;AAnCA;AAAA;AAAA;AAqCA;AACA;AAtCA;AAAA;AAAA;AAwCA;AACA;AACA;AACA;AACA;AA5CA;AAAA;AAAA;AA8CA;AACA;AACA;AAhDA;AAAA;AAAA;AAkDA;AACA;AAnDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAuDA;AACA;AAxDA;AAAA;AAAA;AA0DA;AACA;AA3DA;AAAA;AAAA;AAAA;ApD6kKA;AoD7kKA;AAAA;ApDglKA;AqDnlKAA;AACA0U;AACAzE;AACA0E;AACAC;AAJA;AAMA;AAAA;ArDslKA;AqDrlKA5U;AACA;ArDulKA;AqD/lKA;AAAA;AAAA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACAsf;AACAC;AACAC;AACA;AACA;AACA;AACA;AACA;AAxBA;ArDmnKA;AqDnnKA;AAAA;ArDsnKA;AsDtnKAxf;AACA0U;AACAzE;AACA0E;AACAC;AACAC;AACA4K;AADA;AAGAzK;AACA0K;AACAC;AACAC;AACA;AACAC;AALA;AARA;AAgBA;AAAA;AtDynKA;AsDxnKA7f;AACA;AACA;AACA;AtD0nKA;AsD9oKA;AAAA;AAAA;AAsBA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AA7BA;AAAA;AAAA;AA+BA;AACA;AACA;AACA;AACA;AAAA;AACA;AApCA;AAAA;AAAA;AAsCA;AACA;AACA;AACA;AACA;AACA;AAEA;AA7CA;AtD+qKA;AsD/qKA;AAAA;AtDkrKA;AuDlrKAA;AACA0U;AACAzE;AACA0E;AACAC;AACAC;AACAiL;AADA;AAGA9K;AACA+K;AACAC;AAFA;AARA;AAaA;AAAA;AvDqrKA;AuDprKAhgB;AvDsrKA;AuDprKA;AACA;AACA;AACA;AACA;AACA;AvDsrKA;AuD3sKA;AAAA;AAAA;AAwBA;AACA;AACA;AACA;AvDwrKA;AuDtrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AvDwrKA;AuDtrKA;AACA;AACAigB;AACAC;AACAC;AACA;AACAA;AACAZ;AAEAA;AACAU;AACA;AAAA;AACA;AAGAC;AACAD;AACAE;AACA;AACAA;AACAZ;AAEAA;AACAW;AACA;AACA;AvDqrKA;AuDnrKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAxEA;AvD+vKA;AuD/vKA;AAAA;AvDkwKA;AwDlwKAlgB;AACA0U;AACAzE;AACA0E;AACAC;AAJA;AAAA;AxD0wKA;AwDpwKA;AAAA;AxDuwKA;AwDtwKA;AADA;AxD0wKA;AwDxwKA;AxD0wKA;AwDxwKA;AACA;AxD0wKA;AwDxwKAzU;AACAA;AAEAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AxDywKA;AwDvwKA;AxDywKA;AwDvwKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhCA;AAiCA;AxD0wKA;AwDjzKA;AAAA;AAAA;AAyCA;AACA;AACA;AA3CA;AAAA;AAAA;AA6CA;AACA2c;AACAA;AACA;AAhDA;AAAA;AAAA;AAkDA;AACAA;AACA;AApDA;AAAA;AAAA;AAsDA;AACAA;AACA;AAxDA;AAAA;AAAA;AA0DA;AACAA;AACA;AA5DA;AAAA;AAAA;AA8DA;AACA;AACA;AACA;AACA;AACA;AACA;AApEA;AAAA;AAAA;AAsEA;AACA;AACA;AACA;AAzEA;AAAA;AAAA;AA2EA;AACAA;AAKA;AAjFA;AAAA;AAAA;AAmFA;AACAA;AAKA;AAzFA;AAAA;AAAA;AA2FA;AACAA;AACA;AA7FA;AAAA;AAAA;AA+FA;AACAA;AACA;AAjGA;AAAA;AAAA;AAoGA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AATA;AAWA;AACA;AAjHA;AAAA;AAAA;AAmHA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAHA;AAKA;AACA;AA1HA;AxDm6KA;AwDn6KA;AAAA;AxDs6KA;AyDt6KAld;AACA;AACAwgB;AACAC;AACAC;AACAC;AACAC;AACA;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AAhBA;AzDy7KA;A0Dz7KAjhB;AACA0U;AACAzE;AACA0E;AACAC;AACAC;AACAqM;AADA;AAGAlM;AACA/E;AACAqI;AACA6B;AAHA;AARA;AAcA;AAAA;A1D47KA;A0D37KAna;A1D67KA;A0D37KA;AACA;AACA;A1D67KA;A0D37KA;A1D67KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A0Dz7KA;AACA;A1D27KA;A0Dz7KA;AACA;AACA;A1D27KA;A0Dt+KA;AAAA;AAAA;AA4CA;A1D+7KA;A0D97KA;AACA;AACA;AACA;AACA;A1Dg8KA;A0D97KA;AACA;AACA;AACA;AACA;AACA;AACA;AACAmhB;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACAC;AACA;AACA;AACA;AACA;AACA;AAhBA;AAkBA;AACAF;AACAG;AACA;AACAnhB;AAGA;AACA;AACA;AACA;AACA;AACA;AAvFA;AAAA;AAAA;AAwFA;A1Dg8KA;A0D/7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAohB;AACA;AACA;AACA;AACA;AA1GA;AAAA;AAAA;AA4GA;AACA;AACA;AAIAjR;AACA;AACA;AApHA;AAAA;AAAA;AAsHA;AACA;AAvHA;A1D0jLA;A0D1jLA;AAAA;A1D6jLA;A2D7jLArQ;AACA0U;AACAzE;AACA0E;AACAC;AACAC;AACA0M;AADA;AAGAvM;AACAwM;AACAC;AACA1B;AACAC;AAJA;AARA;AAeA;AAAA;A3DgkLA;A2D/jLAhgB;A3DikLA;A2D/jLA;AACA;AACA;AACA;AACA;AACA;A3DikLA;A2DxlLA;AAAA;AAAA;AAyBA;AACA;A3DokLA;A2DlkLA;A3DokLA;A2DxkLA;AAAA;AAAA;AAAA;A3D6kLA;A2DtkLA;A3DwkLA;AACA;A2DhlLA;AAAA;AAAA;AAAA;A3DqlLA;A2D3kLA;AACA;A3D6kLA;AACA;A2D7kLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAF;AACAA;A3D+kLA;A2D7kLAmgB;AACA;AACAC;AACAD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAngB;AACAA;A3D+kLA;A2D7kLAogB;AACA;AACAD;AACAC;AACA;AACA;A3D+kLA;A2D7kLA;AACA;AACA;AACA;AACAwB;AACA;AACA;AACAC;AACA;AACA;AACA;AACA;AApFA;AAAA;AAAA;AAsFA;AAAA;AAAA;AAGA;AAzFA;AAAA;AAAA;AA2FA;AACA;AACA;AACAC;AACAH;AACA;AACAA;AACAG;AACA;AACAA;AACAH;AACA;AACA;AACA;AAxGA;AAAA;AAAA;AA0GA;AACA;A3DqlLA;A2DnlLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAI;AACA;AACA;AACAC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA;AACA;AACA;AACAD;AACA;AACA;AACA;AACA;A3DqlLA;A2DnlLA;AACA;AA9IA;A3DouLA;A2DpuLA;AAAA;A3DuuLA;A4DvuLA7hB;AACA0U;AACAzE;AACA0E;AACAC;AACAC;AACAkN;AACA1D;AACA2D;A5DyuLA;A4DvuLA1D;AAJA;AADA;AAQAtJ;AACAiN;AACAC;AACA3D;AACArE;AACAiI;AACAzD;AACApG;AACA6B;AARA;AAbA;AAwBA;AAAA;A5D0uLA;A4D1uLA;A5D4uLA;A4D3uLAna;A5D6uLA;A4D3uLA;A5D6uLA;A4D3uLA;AACAG;AACAA;A5D6uLA;A4D3uLA;AACAwe;AACAA;AACA;A5D6uLA;A4D3uLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A5D6uLA;A4D3uLA;AACA;AACA;AACA;AACA;A5D6uLA;A4DtyLA;AAAA;AAAA;AA0DA;A5DivLA;A4DhvLA;AACA;AACA;AACA;AACA7B;AACAA;AACAA;AACA;AACA;AACAA;AACAA;AACAA;AACA;AACA;AACAA;AACAA;AACAA;AACA;AACA;AACAA;AACAA;AACAA;AACA;AACA;AACAA;AACAA;AACAA;AACA;AACA;AACAA;AACAA;AACAA;AACA;AA/BA;AAiCA;AA7FA;AAAA;AAAA;AA+FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzGA;AAAA;AAAA;AA2GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArHA;AAAA;AAAA;AAuHA;AACA;AAxHA;AAAA;AAAA;AA0HA;AACA;AACAA;AACA;AACAA;AACAA;AACAA;AACAA;AACA;AACA;AAnIA;A5D83LA;A4D93LA;AAAA;A5Di4LA;A6Dj4LA9c;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACA0K;AACAC;AAFA;AALA;AAUA;AAAA;A7Do4LA;A6Dn4LA3f;AACA;A7Dq4LA;A6Dj5LA;AAAA;AAAA;AAcA;AACA;A7Dw4LA;A6Dt4LA;AACA;AACAoiB;AACA;AACA;AACA;AAtBA;A7D+5LA;A6D/5LA;AAAA;A7Dk6LA;A8Dl6LApiB;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAqN;AACAxiB;AACAyiB;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACA5S;AACAC;AACA4S;AACAC;AACAC;AACAC;AACAxD;AACAD;AACA0D;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AA5BA;AA8BA5O;AAnCA;AAqCA;AAAA;A9Dq6LA;A8Dr6LA;A9Du6LA;A8Dt6LA/U;A9Dw6LA;A8Dt6LA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A9D06LA;A8Dx6LA;A9D06LA;A8Dx6LA;A9D06LA;A8Dx6LA;AACAG;AACA;A9D06LA;A8Dx6LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A9D06LA;A8Dx6LA;AACA;AACA;AACA;A9D06LA;A8Dx6LA;AACA;A9D06LA;A8Dx6LA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A9D06LA;A8Dx6LA;AACA;AACAA;AACAA;AACAA;AACAA;A9D06LA;A8Dx6LA;AACA;AACA;A9D06LA;A8Dx6LA;AACA;AACA;AACA;AACA;A9D06LA;A8Dx6LA;AACA;AACA;AACA;A9D06LA;A8Dx6LA;AACA;AACA;AACA;A9D06LA;A8Dx6LA;AACA;AACA;AACA;AACA;AACA;AACAkS;AACAuR;AACA;AACA;A9D06LA;A8Dx6LA;AACA;AACA;A9D06LA;A8Dx6LA;AACA;AACA;AACA;AACA;AACA;AACA;AACAvR;AACA;AACA;AACA;AACA;A9D06LA;A8DzlMA;AAAA;AAAA;AAiLA;AACAwR;AACAA;AACAA;AACA;AACA;AACAC;AACAA;AACA;AACA;AACAA;AACA;AACA;AACA;AACA;AA/LA;AAAA;AAAA;AAiMA;AACA;AACA;AACA;AACAvE;AACA;AACA;AACA;AACA;AACA;AA1MA;AAAA;AAAA;AA4MA;AACA;AACA;AACA;AACAwE;AACA;AACA;A9Di7LA;AACA;AACA;AACA;A8D/6LA;A9Di7LA;A8D/6LA;A9Di7LA;A8D/6LA;AACA;AACA;AACAC;AACA;AACA;AACA;A9Di7LA;A8D/6LA;AACA;AACA;AACA;AACA;A9Di7LA;A8D/6LA;AACA;AACA;AACA;AACA;AACAA;AAIA;AACA;AACA;AACAA;AACA;AACA;AACAA;AACAA;AACA;AACA;A9D86LA;A8D56LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEAC;AACA;AACAA;AACA;AACA;AACA;AACA;AAEAA;AACA;AACAA;AACA;AACA;AACA;AACA;AACAC;AACAC;AACA;AACA;AACA;AACAA;AACA;AACA;AA9RA;AAAA;AAAA;AA+RA;A9D+6LA;A8D96LA;A9Dg7LA;A8Dj7LA;AAGA;A9Di7LA;A8D/6LA;AACA5S;AACAf;AACA4T;AAEApU;AACAwB;AACAC;AACA4S;AARA;A9Dy7LA;A8D96LA;AAAA;AAAA;AAIA;AACAC;AACA;AACAA;AACA;A9D+6LA;A8D76LA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA/S;AACAf;AACAR;AAEAwB;AACAC;AANA;AAQA;AA3CA;A9Dy9LA;A8Dv9LA;AAAA;AA0CA;AACA;AA5UA;AAAA;AAAA;AA8UA;AACA;AA/UA;AAAA;AAAA;AAiVA;AACA;AAlVA;AAAA;AAAA;AAoVA;AACA;AArVA;AAAA;AAAA;AAuVA;AACA;AACA;AAzVA;AAAA;AAAA;AA2VA;AACA;AACA;AA7VA;AAAA;AAAA;AA+VA;AACA;AAhWA;AAAA;AAAA;AAkWA;AACA;AAnWA;AAAA;AAAA;AAqWA;AACA;AACA;AACA;AACApB;AACA;AACA;AACAA;AACAA;AACA;AACA;AACA;AAhXA;AAAA;AAAA;AAiXA;A9Do8LA;A8Dn8LA;AACA;AAEA;AACA;AACA;AACA;AACAkU;AACAA;AACA;AA3XA;AAAA;AAAA;AA6XA;AACA;AACA;AACA;AACA;AACA;A9Ds8LA;A8Dp8LA;AACA;AACA;AACA;AACA3B;AACA;AACAA;AACA;AACAA;AACA;AACA;AACA4B;AACA;AACA;AACA5B;AACA;AACA;AACA;AACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/ZA;AAAA;AAAA;AAiaA;AACA;AAlaA;AAAA;AAAA;AAoaA;AACA;A9D08LA;AACA;AACA;AACA;A8Dx8LA;AACA;AACA;AACA;AACA;AACA;AA/aA;AAAA;AAAA;AAibA;AACA;AACA;AACA;AACA;AArbA;AAAA;AAAA;AAubA;AACA;AACA;AACA;AACA;AA3bA;AAAA;AAAA;AA6bA;AACA;AACA;AACA;AACA;A9Dg9LA;A8D98LA;AACA;AACA;AACA;AACA;A9Dg9LA;A8D98LA;AACA;AACA;AACA;A9Dg9LA;A8D98LA;A9Dg9LA;A8D98LA;A9Dg9LA;A8D98LA;AACA;AACA;AACA6B;AACAA;AACAA;A9Dg9LA;A8D98LA;AACAC;AACAA;AACAA;AACAA;AACAA;AACA;AACA;AACAtB;A9Dg9LA;A8D98LAsB;AACAA;AACAA;AACAA;AACA;AACAA;AACA;AACAA;AACA;AACAA;AACAA;AACAA;AACA;AACAA;AACA;AACAA;AACAA;AACAA;AACA;AACAA;AACAA;AACAA;AACA;AACA;AACAA;AACA;AACAA;AACA;AACAA;AACAA;AACAA;AACA;AACAA;AACAA;AACAA;AACA;AACA;AACAA;AACAA;AACAA;AACAA;AACA;AACA;AACA;AACAC;AACA;A9Dg9LA;A8D98LAD;AACAA;AACAA;AACA;A9Dg9LA;A8D98LA;AACA;AACA;A9Dg9LA;A8D98LA;A9Dg9LA;A8D98LA;AACA;AA9hBA;AAAA;AAAA;AAgiBA;AACA;AACA;AACA;AACA;A9Dk9LA;A8Dh9LA;AACA;AACA;AACA;AACA;A9Dk9LA;A8Dh9LA;AACA;AACA;AACA;A9Dk9LA;A8Dh9LA;A9Dk9LA;A8Dh9LA;A9Dk9LA;A8Dh9LA;AACA;AACA;AACAD;AACAA;AACAA;A9Dk9LA;A8Dh9LA;AACAC;AACAA;AACAA;AACAA;AACAA;AACA;AACA;AACArB;A9Dk9LA;A8Dh9LAqB;AACAA;AACAA;AACAA;AACA;AACAA;AACA;AACAA;AACA;AACAA;AACAA;AACAA;AACA;AACA;AACAA;AACAA;AACAA;AACA;AACAA;AACAA;AACAA;AACA;AACA;AACAA;AACA;AACA;AACAA;AACAA;AACAA;AACA;AACAA;AACAA;AACAA;AACA;AACA;AACAA;AACAA;AACAA;AACAA;AACA;AACA;AACA;AACAE;AACA;A9Dk9LA;A8Dh9LAF;AACAA;AACAA;AACA;A9Dk9LA;A8Dh9LA;AACA;AACA;A9Dk9LA;A8Dh9LA;A9Dk9LA;A8Dh9LA;AACA;AA/nBA;AAAA;AAAA;AAioBA;AACA;AACA;AACA;A9Do9LA;A8Dl9LA;AACA;AACA;AACA;A9Do9LA;A8Dl9LA;AACA;AACApF;AACAuF;AACAC;AACAC;AACA;A9Do9LA;A8Dl9LA5jB;AACAA;AACAA;AACAA;AACA;AAvpBA;A9D4mNA;A8D5mNA;AAAA;A9D+mNA;A+D/mNAnB;AACA0U;AACAzE;AACA0E;AACAC;AAJA;AAMA;AAAA;A/DknNA;A+DjnNA5U;A/DmnNA;A+DjnNA;AACA;AACA;AACAG;AACA;AACA;AACAH;AACA;A/DmnNA;A+DnoNA;AAAA;A/DsoNA;AgEtoNAA;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACApB;AACAoR;AAFA;AAIAjQ;AATA;AAWA;AAAA;AhEyoNA;AgEzoNA;AhE2oNA;AgE1oNA/U;AhE4oNA;AgE1oNA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AhEgpNA;AgEnqNA;AAAA;AAAA;AAqBA;AACA;AACA;AAGA;AACA;AACA;AACA;AACAilB;AACA;AACA;AACA;AACAC;AACA;AACA;AACA;AACA;AACA;AAvCA;AAAA;AAAA;AAyCA;AACA;AhEmpNA;AgEjpNA;AACA;AACA;AACA7J;AACA;AACA;AACA;AACAA;AACA;AhEmpNA;AgEjpNA;AACA;AACA;AAxDA;AAAA;AAAA;AA0DA;AACA;AACA;AACA;AA7DA;AAAA;AAAA;AA+DA;AACA;AAhEA;AAAA;AAAA;AAkEA;AACA;AACA;AACA;AArEA;AAAA;AAAA;AAuEA;AACA;AACA;AACA;AACA;AACA;AA5EA;AAAA;AAAA;AA8EA;AACA;AACA;AACA;AAjFA;AAAA;AAAA;AAmFA;AACA;AACA;AArFA;AAAA;AAAA;AAuFA;AACA;AACA;AAzFA;AhE2vNA;AgE3vNA;AAAA;AhE8vNA;AiE9vNArb;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAuI;AACA4H;AAFA;AALA;AAUA;AAAA;AjEiwNA;AiEhwNAnlB;AACA;AACA;AACA;AACA;AACA;AACA;AjEkwNA;AiEnxNA;AAAA;AAAA;AAmBA;AACA;AApBA;AAAA;AAAA;AAsBA;AACAolB;AACA;AACAA;AACA;AACAA;AACA;AACA;AACAA;AACA;AACAA;AACA;AACA;AACA;AAnCA;AAAA;AAAA;AAqCA;AACA;AACA;AACA;AAxCA;AjEkzNA;AiElzNA;AAAA;AjEqzNA;AkErzNAplB;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAqQ;AACApD;AACAniB;AACA4e;AACApG;AACAgN;AACAnL;AAPA;AASArF;AACAyQ;AADA;AAdA;AAkBA;AAAA;AlEwzNA;AkEvzNAvlB;AlEyzNA;AkEvzNA;AlEyzNA;AkEvzNA;AACA;AACA;AACA;AACA;AACA;AlEyzNA;AkEr1NA;AAAA;AAAA;AA8BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvCA;AAAA;AAAA;AAyCA;AACA;AACA;AACA;AlE8zNA;AkE5zNA;AACA;AACA;AACA;AACA;AlE8zNA;AkE5zNA;AACA;AACA;AACA;AACAwlB;AACAA;AACAA;AACAxlB;AAEA;AACA;AACA;AACA;AAhEA;AAAA;AAAA;AAkEA;AACA;AlE+zNA;AkE7zNA;AACA;AACA;AACA;AlE+zNA;AkE7zNA;AACA;AACA;AACAwlB;AACA;AACAA;AACA;AACA;AACA;AACA;AACA;AACA;AArFA;AAAA;AAAA;AAuFA;AACA;AACA;AACA;AA1FA;AAAA;AAAA;AA4FA;AACA;AACA;AACA;AACA;AAhGA;AAAA;AAAA;AAkGAjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzGA;AAAA;AAAA;AA2GA;AACAiG;AACA;AACA;AACA;AACAxlB;AACA;AACA;AACA;AACA;AApHA;AAAA;AAAA;AAsHA;AACA;AACA;AACA;AACA;AACA;AACA;AlEy0NA;AkEv0NA;AACA;AACA;AACA;AACA;AACA;AACA;AApIA;AlE88NA;AkE98NA;AAAA;AlEi9NA;AmEj9NAA;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAyQ;AACA9J;AACA+J;AACAC;AACAC;AACAxJ;AACAyJ;AACAC;AACAC;AATA;AAWAjR;AACA8G;AACAoK;AACAC;AACAC;AAJA;AAhBA;AAuBA;AAAA;AnEo9NA;AmEp9NA;AnEs9NA;AmEr9NAlmB;AnEu9NA;AmEr9NA;AnEu9NA;AmEr9NA;AACA;AACA;AACA;AACA;AnEu9NA;AmEr9NA;AnEu9NA;AmEr9NA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACAqQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AnE29NA;AmE9hOA;AAAA;AAAA;AAqEA;AACA;AAtEA;AAAA;AAAA;AAwEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/EA;AAAA;AAAA;AAiFA;AACA;AACAsD;AACAkI;AAIA9H;AAIA8O;AACAC;AAXA;AAaA;AnE49NA;AmE19NA;AnE49NA;AmE7jOA;AAAA;AAAA;AAmGA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAxBA;AA0BA;AACA;AA/HA;AnEqnOA;AmErnOA;AAAA;AnEwnOA;AoExnOA9iB;AACA0U;AACAzE;AACA0E;AACAC;AAJA;AAMA;AAAA;ApE2nOA;AoE3nOA;ApE6nOA;AoE5nOA5U;ApE8nOA;AoE5nOA;AACA;ApE8nOA;AoE5nOAA;AAAA;AAAA;AACA;AACA;ApEgoOA;AoE9oOA;AAAA;AAAA;AAgBA;AACA;AACAgkB;AAGA;AACA;AACA;AAvBA;AAAA;AAAA;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACAxT;AACA;AACA;AA5CA;AAAA;AAAA;AA8CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvDA;AAAA;AAAA;AAyDA;AACA;AACA;AACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtEA;ApE6sOA;AoE7sOA;AAAA;ApEgtOA;AqEhtOAxQ;AACA0U;AACAzE;AACA0E;AACAC;AACAC;AACAiJ;AADA;AAGA9I;AACAmR;AADA;AAGApR;AAXA;AAaA;AAAA;ArEmtOA;AqEntOA;ArEqtOA;AqEptOA/U;ArEstOA;AqEptOA;ArEstOA;AqEptOA;ArEstOA;AqEptOAA;AACA;AACAuV;AACAA;AACA;AACAvV;AAAA;AAAA;AACA;ArEwtOA;AqElvOA;AAAA;AAAA;AA4BA;AACA;AACA;AACAke;AACA;AACA;AAjCA;AAAA;AAAA;AAmCA;AACA;AACA;AACA;AACA;AAvCA;AAAA;AAAA;AAyCA;AACA;AACA;AACA;AACA;AACA;AA9CA;AAAA;AAAA;AAgDA;AACA;AACA;AACA;AACA;AACA;AArDA;AAAA;AAAA;AAuDA;AACA;AAxDA;ArE4xOA;AqE5xOA;AAAA;ArE+xOA;AsE/xOAle;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAmQ;AADA;AALA;AASA;AAAA;AtEkyOA;AsEjyOAnlB;AtEmyOA;AsEjyOA;AACA;AACA;AACA;AACA;AtEmyOA;AsEnzOA;AAAA;AAAA;AAkBA;AACA;AACA;AACAuf;AACAA;AACAA;AACA;AACA;AAzBA;AtEg0OA;AsEh0OA;AAAA;AtEm0OA;AuEn0OAvf;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACA2E;AACAnI;AACAC;AACAuD;AACAxE;AACAe;AACA6U;AAPA;AALA;AAeA;AAAA;AvEs0OA;AuEr0OApmB;AvEu0OA;AuEr0OA;AACA;AACAG;AAEAA;AACAA;AACAA;AvEs0OA;AuEp0OA;AACA;AAGA;AvEo0OA;AuEl0OA;AACA;AACA;AvEo0OA;AuEl0OA;AACA;AACA;AACA;AvEo0OA;AuEl0OA;AACA;AACA;AACA;AACA;AvEo0OA;AuEj3OA;AAAA;AAAA;AA+CA;AACA;AACA;AACA;AACAoR;AACAf;AACAgB;AACAC;AAJA;AAMA;AACA;AACA;AA1DA;AAAA;AAAA;AA4DA;AvEy0OA;AuEv0OA;AACA;AACA;AACA;AACA;AACA;AACA;AACAjR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5EA;AAAA;AAAA;AA8EA;AACA;AACA;AACA;AACA;AAlFA;AvE85OA;AuE95OA;AAAA;AvEi6OA;AwEj6OAR;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAzD;AACA8S;AACAgC;AAHA;AALA;AAWA;AAAA;AxEo6OA;AwEn6OArmB;AxEq6OA;AwEn6OA;AACA;AxEq6OA;AwEp7OA;AAAA;AAAA;AAiBA;AACA;AAlBA;AxE27OA;AwE37OA;AAAA;AxE87OA;AyE97OAA;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAd;AACAmE;AAFA;AALA;AAUA;AAAA;AzEi8OA;AyEh8OArY;AzEk8OA;AyEh8OA;AACA;AACAG;AACAA;AACA;AzEk8OA;AyEh8OA;AACAwe;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACA;AzEk8OA;AyEh8OA;AACA;AACA;AACA;AACA;AACA;AACA;AzEk8OA;AyEr+OA;AAAA;AAAA;AAqCA;AACA;AAtCA;AAAA;AAAA;AAwCA;AACA;AACA;AACA;AA3CA;AAAA;AAAA;AA6CA;AACA;AACA;AA/CA;AAAA;AAAA;AAiDA;AACA;AAlDA;AAAA;AAAA;AAoDA;AACA;AACA;AACA;AACA7B;AACAA;AACA;AACAA;AACA;AACA;AA7DA;AzE2gPA;AyE3gPA;AAAA;AzE8gPA;A0E9gPA9c;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAsR;AADA;AALA;AASA;AAAA;A1EihPA;A0EhhPAtmB;AACA;A1EkhPA;A0E7hPA;AAAA;AAAA;AAaA;AACA;AACA;AAfA;A1EqiPA;A0EriPA;AAAA;A1EwiPA;A2ExiPAA;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAuR;AACApK;AACAvI;AAHA;AAKAkB;AACA0R;AADA;AAGAzR;AAbA;AAeA;AAAA;A3E2iPA;A2E1iPA/U;A3E4iPA;A2E1iPA;AACA;AACA;A3E4iPA;A2E1iPA;AACA;A3E4iPA;A2E1iPA;AACA;AACA;AACA;A3E4iPA;A2ExkPA;AAAA;AAAA;AA8BA;AACA;AA/BA;AAAA;AAAA;AAiCA;AACA;AAlCA;AAAA;AAAA;AAoCA;AACA;AArCA;AAAA;AAAA;AAuCA;AACA;AAxCA;AAAA;AAAA;AA0CA;AACA;AA3CA;AAAA;AAAA;AA6CA;AACA;AAGA;AAjDA;AAAA;AAAA;AAmDA;AACA;AACA;AACA;AACA;AACA;AACAmc;AACAA;AACAA;AACAA;AACAA;A3EyjPA;A2EvjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9EA;AAAA;AAAA;AAgFAoD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvFA;AAAA;AAAA;AAyFA;AACA;AACA;AACA;AACA;AACAzf;AAMA;AACA;AACA;AAtGA;AAAA;AAAA;AAwGA;AACA;AACA;AA1GA;AAAA;AAAA;AA4GA;AAIA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAzHA;AAAA;AAAA;AA2HA;AACA;AACA;AACA;AACA;AACA;AAhIA;AAAA;AAAA;AAkIA;AACA;AAnIA;AAAA;AAAA;AAqIA;AACA;AACA;AACA;A3E6jPA;A2E3jPA;AACA;AACA;AACA;AACA;AACA;AACAK;A3E6jPA;A2E3jPA;AACA;A3E6jPA;A2E3jPA;AACA;AACAA;AACA;AACA;AAGA4c;AAEA;AACA;AACA;AACA;AACA5c;AACA;AACA4c;AAIA;AACA;A3EujPA;A2ErjPA;A3EujPA;A2ErjPA;AACA;AACA;AACAA;A3EujPA;A2ErjPA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA/c;AACA;A3EsjPA;A2EpjPA;AACA;AACA;A3EsjPA;A2EpjPA;AACA;AACA;AACA;AAxMA;AAAA;AAAA;AA0MA;AACA;AACAymB;AACA;AACA;AACA;AA/MA;AAAA;AAAA;AAiNA;AACA3R;AACA;AACA;AACA;AACA;AAtNA;A3EixPA;A2EjxPA;AAAA;A3EoxPA;A4EpxPA9U;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACA0R;AADA;AALA;AASA;AAAA;A5EuxPA;A4EtxPA1mB;A5EwxPA;A4EtxPA;A5EwxPA;A4EtxPA;AACAG;AACAA;AACAA;A5EwxPA;A4EtxPA;AACAA;AACAA;A5EwxPA;A4EtxPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A5EwxPA;A4EtzPA;AAAA;AAAA;AAgCA;AACA2c;AACAA;AACA;AAnCA;A5E+zPA;A4E/zPA;AAAA;A5Ek0PA;A6El0PA9c;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAgL;AADA;AALA;AASA;AAAA;A7Eq0PA;A6Ep0PAhgB;A7Es0PA;A6Ep0PA;AACA;AACA;A7Es0PA;A6Ep1PA;AAAA;AAAA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA6kB;A7Ey0PA;A6Ev0PAtF;AACAC;AACA;AACA;AACA;AACA;AACA;AAnCA;A7E62PA;A6E72PA;AAAA;A7Eg3PA;A8Eh3PAxf;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACA2R;AACAC;AAFA;AALA;AAUA;AAAA;A9Em3PA;A8El3PA5mB;A9Eo3PA;A8El3PA;AACA;AACAG;AACAA;A9Eo3PA;A8El3PA;AACA;AACA;AACA;A9Eo3PA;A8El3PA;A9Eo3PA;A8El3PA;AACA;A9Eo3PA;A8E94PA;AAAA;AAAA;AA4BA;AACA2c;AACAA;AACA;AA/BA;A9Eu5PA;A8Ev5PA;AAAA;A9E05PA;A+E15PA9c;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAmR;AADA;AAGApR;AARA;AAUA;AAAA;A/E65PA;A+E75PA;A/E+5PA;A+E95PA/U;A/Eg6PA;A+E95PA;A/Eg6PA;A+E95PAA;AACA;AACA;AACA;AACA;AACAA;AAAA;AAAA;AACA;A/Ek6PA;A+Ev7PA;AAAA;AAAA;AAuBA;AACA;AACA;AACAke;AACA;AACA;AA5BA;AAAA;AAAA;AA8BA;AACA;AACA;AACA;AACAhe;AACA2mB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9CA;AAAA;AAAA;AAgDA;AACA;AACA;AACA;AACA;AACA;AArDA;AAAA;AAAA;AAuDA;AACA;AACA;AACA;AACA;AACA;AA5DA;AAAA;AAAA;AA8DA;AACA;AACA;AACA;AACA;AACA;AACA;AApEA;A/Ek/PA;A+El/PA;AAAA;A/Eq/PA;AgFr/PA7mB;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACA/E;AACA6W;AACAC;AACAlM;AAJA;AAMA9F;AAXA;AAaA;AAAA;AhFw/PA;AgFv/PA/U;AhFy/PA;AgFv/PA;AhFy/PA;AgFv/PA;AACA;AhFy/PA;AgF5gQA;AAAA;AAAA;AAoBA;AhF6/PA;AgF5/PA;AACA;AhF8/PA;AACA;AgF5/PA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACAE;AACA;AACA;AACA;AAjCA;AAAA;AAAA;AAmCA;AACA;AACA;AACA;AACA;AACA;AAxCA;AhF2iQA;AgF3iQA;AAAA;AhF8iQA;AiF9iQA;AACA;AACA;AACA;AACA;AjFgjQA;AiF7iQA;AjF+iQA;AiF7iQAF;AACA0U;AACAzE;AACA0E;AACAC;AACAC;AACAmS;AACAC;AADA;AADA;AAKAjS;AACAkS;AACAC;AACAtL;AACAuL;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACA3T;AACA3B;AACAuV;AjF+iQA;AiF7iQAC;AAhBA;AAVA;AA6BA;AAAA;AjFgjQA;AiF/iQA7nB;AjFijQA;AiF/iQA;AjFijQA;AiF/iQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AjFijQA;AiF3lQA;AAAA;AAAA;AA2CA;AjFqjQA;AiFpjQA;AACA;AACAiT;AACA;AACA;AACA;AACA;AAlDA;AjFymQA;AiFzmQA;AAAA;AjF4mQA;AiFvjQA6U;AACAzC;AACA6B;AACAC;AACAtL;AACAuL;AACAC;AACAC;AACAS;AACAP;AACAC;AACAC;AACAC;AACA3T;AACA3B;AACAuV;AAdA;AAgBAI;AACAd;AACAC;AACAtL;AACAuL;AACAC;AACAC;AACAS;AACAP;AACAC;AACAC;AACAC;AACA3T;AACA3B;AACAuV;AAdA;AAgBAK;AACAf;AACAC;AACAtL;AACAuL;AACAC;AACAC;AACAS;AACAP;AACAC;AACAC;AACAC;AACA3T;AACA3B;AACAuV;AAdA;AAjCA;AjF0mQA;AiFvjQA5nB;AACAA;AjFyjQA;AkF3qQAA;AACA0U;AACAzE;AACA0E;AACAC;AACAC;AACAqT;AACAC;AACAC;AACA5b;AACAI;AACAgU;AALA;AADA;AASA5L;AACAd;AACAF;AACAqU;AACAC;AACAC;AACAzL;AACA0L;AAPA;AAdA;AAwBA;AAAA;AlF8qQA;AkF7qQAxoB;AlF+qQA;AkF7qQA;AACAyoB;AACAA;AACAA;AACAA;AACA;AACA;AlF+qQA;AkF7qQA;AACA;AlF+qQA;AkF7qQA;AACA;AACA;AACA;AACA;AAEA;AACA;AlF8qQA;AkF5qQA;AACA;AlF8qQA;AkF5qQA;AlF8qQA;AkF5qQA;AACA;AACA;AACA;AACA;AACA;AACA;AlF8qQA;AkF5qQA;AACA;AlF8qQA;AkF3uQA;AAAA;AAAA;AA+DA;AACA;AAhEA;AAAA;AAAA;AAkEA;AACA;AACA;AApEA;AAAA;AAAA;AAsEA;AACA;AAvEA;AAAA;AAAA;AAyEA;AACA;AACA;AA3EA;AAAA;AAAA;AA6EA;AACA;AA9EA;AAAA;AAAA;AAgFA;AACA;AAjFA;AAAA;AAAA;AAmFA;AACA;AACA;AACA3L;AACA;AACA;AACAA;AACAA;AACA;AACA;AACAA;AACAA;AACA;AACA;AACA;AACAA;AACAA;AAfA;AAiBA;AACA;AAtGA;AAAA;AAAA;AAwGA;AACA;AACA;AACA4L;AACA;AACA;AACAA;AACA;AACA;AACAA;AACA;AACA;AACAA;AACA;AAZA;AAcA;AACA;AACA;AAzHA;AAAA;AAAA;AA2HA;AACA;AA5HA;AAAA;AAAA;AA8HA;AACA;AA/HA;AAAA;AAAA;AAiIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACArY;AACA;AACA;AACA;AACA;AACA;AACA;AlFqsQA;AkFnsQA;AACA;AACA;AAnJA;AAAA;AAAA;AAqJA;AACA;AACA;AACAyM;AACA;AACA;AACAA;AAMA;AACA;AACAA;AACA;AACA;AACAA;AACA;AAjBA;AAmBA;AAzKA;AAAA;AAAA;AA2KA;AACA;AACA;AACA;AACAA;AACA;AACA;AACA;AAlLA;AlFu3QA;AkFv3QA;AAAA;AlF03QA;AmF13QA9c;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACA2T;AACAC;AACAC;AACAC;AACAC;AACA7U;AACA8U;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAf;AACAgB;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACA1M;AACA2M;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACArW;AACAsW;AACAC;AACAC;AACAC;AACAnC;AApCA;AAsCAxT;AACA4V;AACAC;AAFA;AA3CA;AAgDA;AAAA;AnF63QA;AmF73QA;AnF+3QA;AmF93QA3qB;AnFg4QA;AmF93QA;AACA;AnFg4QA;AmF93QA;AACA;AACA;AACA;AACA;AnFg4QA;AmF93QA;AACAgd;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACA;AACA;AACAA;AACAA;AACA;AnFg4QA;AmF93QA;AACA;AACA;AnFg4QA;AmF93QA;AAAA;AAAA;AACA;AnFk4QA;AmFn9QA;AAAA;AAAA;AAmFA;AACA;AApFA;AAAA;AAAA;AAsFA;AACA;AAvFA;AAAA;AAAA;AAyFA;AAEA;AACA;AA5FA;AAAA;AAAA;AA8FA;AACA;AACA;AACA;AACA;AAlGA;AAAA;AAAA;AAoGA;AACA;AACA;AACA;AACA;AAxGA;AAAA;AAAA;AA0GA;AACA;AA3GA;AAAA;AAAA;AA6GA;AACA;AA9GA;AAAA;AAAA;AAgHA;AACA;AAjHA;AAAA;AAAA;AAmHA;AACA;AApHA;AAAA;AAAA;AAsHA;AACA;AAvHA;AAAA;AAAA;AAyHA;AACA;AA1HA;AAAA;AAAA;AA4HA;AACA;AA7HA;AAAA;AAAA;AA+HA;AACA;AAhIA;AAAA;AAAA;AAkIA;AACA;AAnIA;AAAA;AAAA;AAqIA;AACA;AAtIA;AAAA;AAAA;AAwIA;AACA;AAzIA;AAAA;AAAA;AA2IA;AACA;AA5IA;AAAA;AAAA;AA8IA;AACA;AA/IA;AAAA;AAAA;AAiJA;AACA;AAlJA;AAAA;AAAA;AAoJA;AACA;AACA;AACA;AACA;AAxJA;AAAA;AAAA;AA0JA;AACA;AA3JA;AAAA;AAAA;AA6JA;AACA;AA9JA;AAAA;AAAA;AAgKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AnFg7QA;AmFxlRA;AAAA;AAAA;AA0KA;AAOA;AACA;AACA;AACA;AACA;AACAF;AACA;AACA;AACA;AACA;AA1LA;AAAA;AAAA;AA4LA;AACA;AA7LA;AnF6mRA;AmF7mRA;AAAA;AnFgnRA;AoFhnRA9c;AACA0U;AACAzE;AACA0E;AACAC;AACAC;AACAoI;AADA;AAGAjI;AACAhB;AACAkJ;AACAC;AACAC;AACAC;AALA;AAOAvI;AACAnB;AADA;AAfA;AAmBA;AAAA;ApFmnRA;AoFnnRA;ApFqnRA;AoFpnRA3T;ApFsnRA;AoFpnRA;AACA;ApFsnRA;AoFpnRA;AACAsd;AACAA;AACAA;AACA;AACA;AACAA;AACAA;AACAA;AACAA;AACA;AACA;AACAA;ApFsnRA;AoFpnRA;AACA;AACA;AACA;AACA;AACA;ApFsnRA;AoFpnRA;AAAA;AAAA;AACA;ApFwnRA;AoFvqRA;AAAA;AAAA;AAiDA;AACA;AACA;AAnDA;AAAA;AAAA;AAqDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7DA;AAAA;AAAA;AA+DA;AACA;AACA;AACA;AACAA;AACA;AACA;AACAA;AACA;AACA;AACA;AACAA;AACA;AACA;AACA;AACAA;AACA;AAdA;AAgBA;AAjFA;AAAA;AAAA;AAmFA;AACA;AApFA;AAAA;AAAA;AAsFA;AACA;AAvFA;AAAA;AAAA;AAyFA;AACA;AACA;AACA;AACA/M;AACA;AACA;AA/FA;AAAA;AAAA;AAiGA;AACA;AACA;AACA;AACA;AArGA;AAAA;AAAA;AAuGA;AACA;AACA;AACA;AACA;AACA;AA5GA;ApFsvRA;AoFtvRA;AAAA;ApFyvRA;AqFzvRAvQ;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACAmR;AACA3U;AACAC;AACAmZ;AAJA;AAMA7V;AAXA;AAaA;AAAA;ArF4vRA;AqF3vRA/U;ArF6vRA;AqF3vRA;AACA;ArF6vRA;AqF9wRA;AAAA;AAAA;AAmBA;AACA;AACAke;AAFA;AAAA;AAAA;ArFqwRA;AqFjwRA;AACA;AACA;AAEA2M;AACA;AACA;AACA3M;AACA;AACA;AAhCA;AAAA;AAAA;AAkCA;AACA;AACA;AACA;AArCA;ArF0yRA;AqF1yRA;AAAA;ArF6yRA;AsF7yRAle;AACA0U;AACAzE;AACA0E;AACAC;AACAI;AACA6N;AACAC;AAFA;AALA;AAUA;AAAA;AtFgzRA;AsF/yRA9iB;AtFizRA;AsF/yRA;AACA;AACA;AtFizRA;AsFh0RA;AAAA;AtFm0RA;AuFn0RA;AACA;AACA;AvFq0RA;AuFn0RAA;AACA0U;AACAzE;AACA0E;AACAC;AACAC;AACAiW;AADA;AAGA9V;AACAqQ;AACAlL;AACA4Q;AACA9Y;AAJA;AAMA6C;AACAkW;AADA;AAdA;AAkBA;AAAA;AvFs0RA;AuFr0RAhrB;AvFu0RA;AuFr0RA;AACA;AvFu0RA;AuFr0RA;AACA;AACA;AACA;AvFu0RA;AuFl2RA;AAAA;AAAA;AA6BA;AACA;AACA;AACA;AAhCA;AAAA;AAAA;AAiCA;AvF60RA;AuF50RA;AvF80RA;AuF50RA;AACA;AACA;AvF80RA;AuF50RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1DA;AAAA;AAAA;AA4DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnEA;AAAA;AAAA;AAqEA;AACA;AACA;AACA;AAxEA;AvF25RA;AuF35RA;AAAA","file":"qt.js","sourcesContent":[null,"const QmlWeb = {};\n\nglobal.QmlWeb = QmlWeb;\n","let objectIds = 0;\n\nclass QObject {\n  constructor(parent) {\n    this.$parent = parent;\n    if (parent && parent.$tidyupList) {\n      parent.$tidyupList.push(this);\n    }\n\n    // List of things to tidy up when deleting this object.\n    this.$tidyupList = [];\n    this.$properties = {};\n    this.$signals = [];\n\n    this.objectId = objectIds++;\n  }\n\n  $delete() {\n    if (this.$Component) {\n      this.$Component.destruction();\n    }\n\n    while (this.$tidyupList.length > 0) {\n      const item = this.$tidyupList[0];\n      if (item.$delete) {\n        // It's a QObject\n        item.$delete();\n      } else {\n        // It must be a signal\n        item.disconnect(this);\n      }\n    }\n\n    for (const i in this.$properties) {\n      const prop = this.$properties[i];\n      while (prop.$tidyupList.length > 0) {\n        prop.$tidyupList[0].disconnect(prop);\n      }\n    }\n\n    if (this.$parent && this.$parent.$tidyupList) {\n      const index = this.$parent.$tidyupList.indexOf(this);\n      this.$parent.$tidyupList.splice(index, 1);\n    }\n\n    // must do this:\n    // 1) parent will be notified and erase object from it's children.\n    // 2) DOM node will be removed.\n    this.parent = undefined;\n\n    // Disconnect any slots connected to any of our signals. Do this after\n    // clearing the parent, as that relies on parentChanged being handled.\n    for (const i in this.$signals) {\n      this.$signals[i].disconnect();\n    }\n  }\n\n  // must have a `destroy` method\n  // http://doc.qt.io/qt-5/qtqml-javascript-dynamicobjectcreation.html\n  destroy() {\n    this.$delete();\n  }\n}\n\nQmlWeb.QObject = QObject;\n","class JSItemModel {\n  constructor() {\n    this.roleNames = [];\n\n    const Signal = QmlWeb.Signal;\n    this.dataChanged = Signal.signal([\n      { type: \"int\", name: \"startIndex\" },\n      { type: \"int\", name: \"endIndex\" }\n    ]);\n    this.rowsInserted = Signal.signal([\n      { type: \"int\", name: \"startIndex\" },\n      { type: \"int\", name: \"endIndex\" }\n    ]);\n    this.rowsMoved = Signal.signal([\n      { type: \"int\", name: \"sourceStartIndex\" },\n      { type: \"int\", name: \"sourceEndIndex\" },\n      { type: \"int\", name: \"destinationIndex\" }\n    ]);\n    this.rowsRemoved = Signal.signal([\n      { type: \"int\", name: \"startIndex\" },\n      { type: \"int\", name: \"endIndex\" }\n    ]);\n    this.modelReset = Signal.signal();\n  }\n\n  setRoleNames(names) {\n    this.roleNames = names;\n  }\n}\n\nQmlWeb.JSItemModel = JSItemModel;\n","// TODO complete implementation (with attributes `r`,`g` and `b`).\n\nclass QColor {\n  constructor(val) {\n    this.$value = \"black\";\n    if (val instanceof QColor) {\n      // Copy constructor\n      this.$value = val.$value;\n    } else if (typeof val === \"string\") {\n      this.$value = val.toLowerCase();\n    } else if (typeof val === \"number\") {\n      // we assume it is int value and must be converted to css hex with padding\n      const rgb = (Math.round(val) + 0x1000000).toString(16).substr(-6);\n      this.$value = `#${rgb}`;\n    }\n  }\n  toString() {\n    return this.$value;\n  }\n  $get() {\n    // Returns the same instance for all equivalent colors.\n    // NOTE: the returned value should not be changed using method calls, if\n    // those would be added in the future, the returned value should be wrapped.\n    if (!QColor.$colors[this.$value]) {\n      if (QColor.$colorsCount >= QColor.comparableColorsLimit) {\n        // Too many colors created, bail out to avoid memory hit\n        return this;\n      }\n      QColor.$colors[this.$value] = this;\n      QColor.$colorsCount++;\n      if (QColor.$colorsCount === QColor.comparableColorsLimit) {\n        console.warn(\n          \"QmlWeb: the number of QColor instances reached the limit set in\",\n          \"QmlWeb.QColor.comparableColorsLimit. Further created colors would\",\n          \"not be comparable to avoid memory hit.\"\n        );\n      }\n    }\n    return QColor.$colors[this.$value];\n  }\n}\nQColor.$colors = {};\nQColor.$colorsCount = 0;\nQColor.comparableColorsLimit = 10000;\nQmlWeb.QColor = QColor;\n","class QSizeF extends QmlWeb.QObject {\n  constructor(width, height) {\n    super();\n    const createProperty = QmlWeb.createProperty;\n    createProperty(\"real\", this, \"width\", { initialValue: width });\n    createProperty(\"real\", this, \"height\", { initialValue: height });\n  }\n}\n\nQmlWeb.QSizeF = QSizeF;\n","class Signal {\n  constructor(params = [], options = {}) {\n    this.connectedSlots = [];\n    this.obj = options.obj;\n    this.options = options;\n\n    this.signal = (...args) => this.execute(...args);\n    this.signal.parameters = params;\n    this.signal.connect = this.connect.bind(this);\n    this.signal.disconnect = this.disconnect.bind(this);\n    this.signal.isConnected = this.isConnected.bind(this);\n\n    // TODO Fix Keys that don't have an obj for the signal\n    if (this.obj && this.obj.$signals !== undefined) {\n      this.obj.$signals.push(this.signal);\n    }\n  }\n  execute(...args) {\n    QmlWeb.QMLProperty.pushEvalStack();\n    for (const i in this.connectedSlots) {\n      const desc = this.connectedSlots[i];\n      if (desc.type & Signal.QueuedConnection) {\n        Signal.$addQueued(desc, args);\n      } else {\n        Signal.$execute(desc, args);\n      }\n    }\n    QmlWeb.QMLProperty.popEvalStack();\n  }\n  connect(...args) {\n    let type = Signal.AutoConnection;\n    if (typeof args[args.length - 1] === \"number\") {\n      type = args.pop();\n    }\n    if (type & Signal.UniqueConnection) {\n      if (this.isConnected(...args)) {\n        return;\n      }\n    }\n    if (args.length === 1) {\n      this.connectedSlots.push({ thisObj: global, slot: args[0], type });\n    } else if (typeof args[1] === \"string\" || args[1] instanceof String) {\n      if (args[0].$tidyupList && args[0] !== this.obj) {\n        args[0].$tidyupList.push(this.signal);\n      }\n      const slot = args[0][args[1]];\n      this.connectedSlots.push({ thisObj: args[0], slot, type });\n    } else {\n      if (args[0].$tidyupList &&\n        (!this.obj || args[0] !== this.obj && args[0] !== this.obj.$parent)\n      ) {\n        args[0].$tidyupList.push(this.signal);\n      }\n      this.connectedSlots.push({ thisObj: args[0], slot: args[1], type });\n    }\n\n    // Notify object of connect\n    if (this.options.obj && this.options.obj.$connectNotify) {\n      this.options.obj.$connectNotify(this.options);\n    }\n  }\n  disconnect(...args) {\n    // type meaning:\n    //  1 = function, 2 = string\n    //  3 = object with string method,  4 = object with function\n    // No args means disconnect everything connected to this signal\n    const callType = args.length === 1\n      ? args[0] instanceof Function ? 1 : 2\n      : typeof args[1] === \"string\" || args[1] instanceof String ? 3 : 4;\n    for (let i = 0; i < this.connectedSlots.length; i++) {\n      const { slot, thisObj } = this.connectedSlots[i];\n      if (\n        args.length === 0 ||\n        callType === 1 && slot === args[0] ||\n        callType === 2 && thisObj === args[0] ||\n        callType === 3 && thisObj === args[0] && slot === args[0][args[1]] ||\n        thisObj === args[0] && slot === args[1]\n      ) {\n        if (thisObj) {\n          const index = thisObj.$tidyupList.indexOf(this.signal);\n          if (index >= 0) {\n            thisObj.$tidyupList.splice(index, 1);\n          }\n        }\n        this.connectedSlots.splice(i, 1);\n        // We have removed an item from the list so the indexes shifted one\n        // backwards\n        i--;\n      }\n    }\n\n    // Notify object of disconnect\n    if (this.options.obj && this.options.obj.$disconnectNotify) {\n      this.options.obj.$disconnectNotify(this.options);\n    }\n  }\n  isConnected(...args) {\n    const callType = args.length === 1 ? 1\n      : typeof args[1] === \"string\" || args[1] instanceof String ? 2 : 3;\n    for (const i in this.connectedSlots) {\n      const { slot, thisObj } = this.connectedSlots[i];\n      if (callType === 1 && slot === args[0] ||\n          callType === 2 && thisObj === args[0] && slot === args[0][args[1]] ||\n          thisObj === args[0] && slot === args[1]\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static signal(...args) {\n    return (new Signal(...args)).signal;\n  }\n\n  static $execute(desc, args) {\n    try {\n      desc.slot.apply(desc.thisObj, args);\n    } catch (err) {\n      console.error(\"Signal slot error:\", err.message, err,\n        Function.prototype.toString.call(desc.slot)\n      );\n    }\n  }\n\n  static $addQueued(desc, args) {\n    if (Signal.$queued.length === 0) {\n      if (global.setImmediate) {\n        global.setImmediate(Signal.$executeQueued);\n      } else {\n        global.setTimeout(Signal.$executeQueued, 0);\n      }\n    }\n    Signal.$queued.push([desc, args]);\n  }\n  static $executeQueued() {\n    // New queued signals should be executed on next tick of the event loop\n    const queued = Signal.$queued;\n    Signal.$queued = [];\n\n    QmlWeb.QMLProperty.pushEvalStack();\n    for (const i in queued) {\n      Signal.$execute(...queued[i]);\n    }\n    QmlWeb.QMLProperty.popEvalStack();\n  }\n}\n\nSignal.$queued = [];\n\nSignal.AutoConnection = 0;\nSignal.DirectConnection = 1;\nSignal.QueuedConnection = 2;\nSignal.UniqueConnection = 128;\n\nQmlWeb.Signal = Signal;\n","const Qt = {\n  rgba: (r, g, b, a) => {\n    const intr = Math.round(r * 255);\n    const intg = Math.round(g * 255);\n    const intb = Math.round(b * 255);\n    return `rgba(${intr},${intg},${intb},${a})`;\n  },\n  hsla: (h, s, l, a) => {\n    const inth = Math.round(h * 360);\n    const ints = Math.round(s * 100);\n    const intl = Math.round(l * 100);\n    return `hsla(${inth},${ints}%,${intl}%,${a})`;\n  },\n  openUrlExternally: url => {\n    const page = window.open(url, \"_blank\");\n    page.focus();\n  },\n  // Load file, parse and construct as Component (.qml)\n  createComponent: name => {\n    const engine = QmlWeb.engine;\n\n    let file = engine.$resolvePath(name);\n\n    // If \"name\" was a full URL, \"file\" will be equivalent to name and this\n    // will try and load the Component from the full URL, otherwise, this\n    // doubles as checking for the file in the current directory.\n    let tree = engine.loadComponent(file);\n\n    // If the Component is not found, and it is not a URL, look for \"name\" in\n    // this context's importSearchPaths\n    if (!tree) {\n      const nameIsUrl = engine.$parseURI(name) !== undefined;\n      if (!nameIsUrl) {\n        const moreDirs = engine.importSearchPaths(\n          QmlWeb.executionContext.importContextId);\n        for (let i = 0; i < moreDirs.length; i++) {\n          file = `${moreDirs[i]}${name}`;\n          tree = engine.loadComponent(file);\n          if (tree) break;\n        }\n      }\n    }\n\n    if (!tree) {\n      return undefined;\n    }\n\n    const QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\n    const component = new QMLComponent({\n      object: tree,\n      context: QmlWeb.executionContext\n    });\n    component.$basePath = engine.extractBasePath(file);\n    component.$imports = tree.$imports;\n    component.$file = file; // just for debugging\n\n    engine.loadImports(tree.$imports, component.$basePath,\n      component.importContextId);\n\n    engine.components[name] = component;\n    return component;\n  },\n\n  createQmlObject: (src, parent, file) => {\n    const tree = QmlWeb.parseQML(src, file);\n\n    // Create and initialize objects\n\n    const QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\n    const component = new QMLComponent({\n      object: tree,\n      parent,\n      context: QmlWeb.executionContext\n    });\n\n    const engine = QmlWeb.engine;\n    engine.loadImports(tree.$imports, undefined, component.importContextId);\n\n    const resolvedFile = file || Qt.resolvedUrl(\"createQmlObject_function\");\n    component.$basePath = engine.extractBasePath(resolvedFile);\n    component.$imports = tree.$imports; // for later use\n    // not just for debugging, but for basepath too, see above\n    component.$file = resolvedFile;\n\n    const obj = component.createObject(parent);\n\n    const QMLOperationState = QmlWeb.QMLOperationState;\n    if (engine.operationState !== QMLOperationState.Init &&\n        engine.operationState !== QMLOperationState.Idle) {\n      // We don't call those on first creation, as they will be called\n      // by the regular creation-procedures at the right time.\n      engine.$initializePropertyBindings();\n\n      engine.callCompletedSignals();\n    }\n\n    return obj;\n  },\n\n  // Returns url resolved relative to the URL of the caller.\n  // http://doc.qt.io/qt-5/qml-qtqml-qt.html#resolvedUrl-method\n  resolvedUrl: url => QmlWeb.qmlUrl(url),\n\n  size: function size(width, height) {\n    return new QmlWeb.QSizeF(width, height);\n  },\n\n  // Buttons masks\n  LeftButton: 1,\n  RightButton: 2,\n  MiddleButton: 4,\n  // Modifiers masks\n  NoModifier: 0,\n  ShiftModifier: 1,\n  ControlModifier: 2,\n  AltModifier: 4,\n  MetaModifier: 8,\n  KeypadModifier: 16, // Note: Not available in web\n  // Layout directions\n  LeftToRight: 0,\n  RightToLeft: 1,\n  // Orientations\n  Vertical: 0,\n  Horizontal: 1,\n  // Keys\n  Key_Escape: 27,\n  Key_Tab: 9,\n  Key_Backtab: 245,\n  Key_Backspace: 8,\n  Key_Return: 13,\n  Key_Enter: 13,\n  Key_Insert: 45,\n  Key_Delete: 46,\n  Key_Pause: 19,\n  Key_Print: 42,\n  Key_SysReq: 0,\n  Key_Clear: 12,\n  Key_Home: 36,\n  Key_End: 35,\n  Key_Left: 37,\n  Key_Up: 38,\n  Key_Right: 39,\n  Key_Down: 40,\n  Key_PageUp: 33,\n  Key_PageDown: 34,\n  Key_Shift: 16,\n  Key_Control: 17,\n  Key_Meta: 91,\n  Key_Alt: 18,\n  Key_AltGr: 0,\n  Key_CapsLock: 20,\n  Key_NumLock: 144,\n  Key_ScrollLock: 145,\n  Key_F1: 112, Key_F2: 113, Key_F3: 114, Key_F4: 115, Key_F5: 116, Key_F6: 117,\n  Key_F7: 118, Key_F8: 119, Key_F9: 120, Key_F10: 121, Key_F11: 122,\n  Key_F12: 123, Key_F13: 124, Key_F14: 125, Key_F15: 126, Key_F16: 127,\n  Key_F17: 128, Key_F18: 129, Key_F19: 130, Key_F20: 131, Key_F21: 132,\n  Key_F22: 133, Key_F23: 134, Key_F24: 135,\n  Key_F25: 0, Key_F26: 0, Key_F27: 0, Key_F28: 0, Key_F29: 0, Key_F30: 0,\n  Key_F31: 0, Key_F32: 0, Key_F33: 0, Key_F34: 0, Key_F35: 0,\n  Key_Super_L: 0,\n  Key_Super_R: 0,\n  Key_Menu: 0,\n  Key_Hyper_L: 0,\n  Key_Hyper_R: 0,\n  Key_Help: 6,\n  Key_Direction_L: 0,\n  Key_Direction_R: 0,\n  Key_Space: 32,\n  Key_Any: 32,\n  Key_Exclam: 161,\n  Key_QuoteDbl: 162,\n  Key_NumberSign: 163,\n  Key_Dollar: 164,\n  Key_Percent: 165,\n  Key_Ampersant: 166,\n  Key_Apostrophe: 222,\n  Key_ParenLeft: 168,\n  Key_ParenRight: 169,\n  Key_Asterisk: 170,\n  Key_Plus: 171,\n  Key_Comma: 188,\n  Key_Minus: 173,\n  Key_Period: 190,\n  Key_Slash: 191,\n  Key_0: 48, Key_1: 49, Key_2: 50, Key_3: 51, Key_4: 52,\n  Key_5: 53, Key_6: 54, Key_7: 55, Key_8: 56, Key_9: 57,\n  Key_Colon: 58,\n  Key_Semicolon: 59,\n  Key_Less: 60,\n  Key_Equal: 61,\n  Key_Greater: 62,\n  Key_Question: 63,\n  Key_At: 64,\n  Key_A: 65, Key_B: 66, Key_C: 67, Key_D: 68, Key_E: 69, Key_F: 70, Key_G: 71,\n  Key_H: 72, Key_I: 73, Key_J: 74, Key_K: 75, Key_L: 76, Key_M: 77, Key_N: 78,\n  Key_O: 79, Key_P: 80, Key_Q: 81, Key_R: 82, Key_S: 83, Key_T: 84, Key_U: 85,\n  Key_V: 86, Key_W: 87, Key_X: 88, Key_Y: 89, Key_Z: 90,\n  Key_BracketLeft: 219,\n  Key_Backslash: 220,\n  Key_BracketRight: 221,\n  Key_AsciiCircum: 160,\n  Key_Underscore: 167,\n  Key_QuoteLeft: 0,\n  Key_BraceLeft: 174,\n  Key_Bar: 172,\n  Key_BraceRight: 175,\n  Key_AsciiTilde: 176,\n  Key_Back: 0,\n  Key_Forward: 0,\n  Key_Stop: 0,\n  Key_VolumeDown: 182,\n  Key_VolumeUp: 183,\n  Key_VolumeMute: 181,\n  Key_multiply: 106,\n  Key_add: 107,\n  Key_substract: 109,\n  Key_divide: 111,\n  Key_News: 0,\n  Key_OfficeHome: 0,\n  Key_Option: 0,\n  Key_Paste: 0,\n  Key_Phone: 0,\n  Key_Calendar: 0,\n  Key_Reply: 0,\n  Key_Reload: 0,\n  Key_RotateWindows: 0,\n  Key_RotationPB: 0,\n  Key_RotationKB: 0,\n  Key_Save: 0,\n  Key_Send: 0,\n  Key_Spell: 0,\n  Key_SplitScreen: 0,\n  Key_Support: 0,\n  Key_TaskPane: 0,\n  Key_Terminal: 0,\n  Key_Tools: 0,\n  Key_Travel: 0,\n  Key_Video: 0,\n  Key_Word: 0,\n  Key_Xfer: 0,\n  Key_ZoomIn: 0,\n  Key_ZoomOut: 0,\n  Key_Away: 0,\n  Key_Messenger: 0,\n  Key_WebCam: 0,\n  Key_MailForward: 0,\n  Key_Pictures: 0,\n  Key_Music: 0,\n  Key_Battery: 0,\n  Key_Bluetooth: 0,\n  Key_WLAN: 0,\n  Key_UWB: 0,\n  Key_AudioForward: 0,\n  Key_AudioRepeat: 0,\n  Key_AudioRandomPlay: 0,\n  Key_Subtitle: 0,\n  Key_AudioCycleTrack: 0,\n  Key_Time: 0,\n  Key_Hibernate: 0,\n  Key_View: 0,\n  Key_TopMenu: 0,\n  Key_PowerDown: 0,\n  Key_Suspend: 0,\n  Key_ContrastAdjust: 0,\n  Key_MediaLast: 0,\n  Key_unknown: -1,\n  Key_Call: 0,\n  Key_Camera: 0,\n  Key_CameraFocus: 0,\n  Key_Context1: 0,\n  Key_Context2: 0,\n  Key_Context3: 0,\n  Key_Context4: 0,\n  Key_Flip: 0,\n  Key_Hangup: 0,\n  Key_No: 0,\n  Key_Select: 93,\n  Key_Yes: 0,\n  Key_ToggleCallHangup: 0,\n  Key_VoiceDial: 0,\n  Key_LastNumberRedial: 0,\n  Key_Execute: 43,\n  Key_Printer: 42,\n  Key_Play: 250,\n  Key_Sleep: 95,\n  Key_Zoom: 251,\n  Key_Cancel: 3,\n  // Align\n  AlignLeft: 0x0001,\n  AlignRight: 0x0002,\n  AlignHCenter: 0x0004,\n  AlignJustify: 0x0008,\n  AlignTop: 0x0020,\n  AlignBottom: 0x0040,\n  AlignVCenter: 0x0080,\n  AlignCenter: 0x0084,\n  AlignBaseline: 0x0100,\n  AlignAbsolute: 0x0010,\n  AlignLeading: 0x0001,\n  AlignTrailing: 0x0002,\n  AlignHorizontal_Mask: 0x001f,\n  AlignVertical_Mask: 0x01e0,\n  // Screen\n  PrimaryOrientation: 0,\n  PortraitOrientation: 1,\n  LandscapeOrientation: 2,\n  InvertedPortraitOrientation: 4,\n  InvertedLandscapeOrientation: 8,\n  // CursorShape\n  ArrowCursor: 0,\n  UpArrowCursor: 1,\n  CrossCursor: 2,\n  WaitCursor: 3,\n  IBeamCursor: 4,\n  SizeVerCursor: 5,\n  SizeHorCursor: 6,\n  SizeBDiagCursor: 7,\n  SizeFDiagCursor: 8,\n  SizeAllCursor: 9,\n  BlankCursor: 10,\n  SplitVCursor: 11,\n  SplitHCursor: 12,\n  PointingHandCursor: 13,\n  ForbiddenCursor: 14,\n  WhatsThisCursor: 15,\n  BusyCursor: 16,\n  OpenHandCursor: 17,\n  ClosedHandCursor: 18,\n  DragCopyCursor: 19,\n  DragMoveCursor: 20,\n  DragLinkCursor: 21,\n  LastCursor: 21, //DragLinkCursor,\n  BitmapCursor: 24,\n  CustomCursor: 25,\n  // ScrollBar Policy\n  ScrollBarAsNeeded: 0,\n  ScrollBarAlwaysOff: 1,\n  ScrollBarAlwaysOn: 2\n};\n\nQmlWeb.Qt = Qt;\n","class QMLBinding {\n/**\n * Create QML binding.\n * @param {Variant} val Sourcecode or function representing the binding\n * @param {Array} tree Parser tree of the binding\n * @return {Object} Object representing the binding\n */\n  constructor(val, tree) {\n    // this.isFunction states whether the binding is a simple js statement or a\n    // function containing a return statement. We decide this on whether it is a\n    // code block or not. If it is, we require a return statement. If it is a\n    // code block it could though also be a object definition, so we need to\n    // check that as well (it is, if the content is labels).\n    this.isFunction = tree && tree[0] === \"block\" &&\n                      tree[1][0] && tree[1][0][0] !== \"label\";\n    this.src = val;\n    this.compiled = false;\n  }\n\n  toJSON() {\n    return {\n      src: this.src,\n      deps: JSON.stringify(this.deps),\n      tree: JSON.stringify(this.tree)\n    };\n  }\n\n  eval(object, context, basePath) {\n    // .call is needed for `this` support\n    return this.impl.call(object, object, context, basePath);\n  }\n\n/**\n * Compile binding. Afterwards you may call binding.eval to evaluate.\n */\n  compile() {\n    this.src = this.src.trim();\n    this.impl = QMLBinding.bindSrc(this.src, this.isFunction);\n    this.compiled = true;\n  }\n\n  static bindSrc(src, isFunction) {\n    return new Function(\"__executionObject\", \"__executionContext\",\n      \"__basePath\", `\n      QmlWeb.executionContext = __executionContext;\n      if (__basePath) {\n        QmlWeb.engine.$basePath = __basePath;\n      }\n      with(QmlWeb) with(__executionContext) with(__executionObject) {\n        ${isFunction ? \"\" : \"return\"} ${src}\n      }\n    `);\n  }\n}\n\nQmlWeb.QMLBinding = QMLBinding;\n","function QMLBoolean(val) {\n  return !!val;\n}\nQMLBoolean.plainType = true;\nQmlWeb.qmlBoolean = QMLBoolean;\n","// There can only be one running QMLEngine.\n// This variable points to the currently running engine.\nQmlWeb.engine = null;\n\nconst geometryProperties = [\n  \"width\", \"height\", \"fill\", \"x\", \"y\", \"left\", \"right\", \"top\", \"bottom\"\n];\n\n// QML engine. EXPORTED.\nclass QMLEngine {\n  constructor(element) {\n    //----------Public Members----------\n\n    this.fps = 60;\n    // Math.floor, causes bugs to timing?\n    this.$interval = Math.floor(1000 / this.fps);\n    this.running = false;\n    this.rootElement = element;\n\n    // Cached component trees (post-QmlWeb.convertToEngine)\n    this.components = {};\n\n    // Cached parsed JS files (post-QmlWeb.jsparse)\n    this.js = {};\n\n    // List of Component.completed signals\n    this.completedSignals = [];\n\n    // Current operation state of the engine (Idle, init, etc.)\n    this.operationState = 1;\n\n    // List of properties whose values are bindings. For internal use only.\n    this.bindedProperties = [];\n\n    // List of operations to perform later after init. For internal use only.\n    this.pendingOperations = [];\n\n    // Root object of the engine\n    this.rootObject = null;\n\n    // Base path of qml engine (used for resource loading)\n    this.$basePath = \"\";\n\n    // Module import paths overrides\n    this.userAddedModulePaths = {};\n\n    // Stores data for setImportPathList(), importPathList(), and addImportPath\n    this.userAddedImportPaths = [];\n\n    //----------Private Members---------\n\n    // Ticker resource id and ticker callbacks\n    this._tickers = [];\n    this._lastTick = Date.now();\n\n    // Callbacks for stopping or starting the engine\n    this._whenStop = [];\n    this._whenStart = [];\n\n    // Keyboard management\n    this.$initKeyboard();\n\n    //----------Construct----------\n\n    // TODO: Move to module initialization\n    const QMLBaseObject = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"QtObject\");\n    const constructors = QmlWeb.constructors;\n    for (const i in constructors) {\n      if (constructors[i].getAttachedObject) {\n        QmlWeb.setupGetter(QMLBaseObject.prototype, i,\n                    constructors[i].getAttachedObject);\n      }\n    }\n  }\n\n  //---------- Public Methods ----------\n\n  // Start the engine\n  start() {\n    QmlWeb.engine = this;\n    const QMLOperationState = QmlWeb.QMLOperationState;\n    if (this.operationState !== QMLOperationState.Running) {\n      this.operationState = QMLOperationState.Running;\n      this._tickerId = setInterval(this._tick.bind(this), this.$interval);\n      this._whenStart.forEach(callback => callback());\n    }\n  }\n\n  // Stop the engine\n  stop() {\n    const QMLOperationState = QmlWeb.QMLOperationState;\n    if (this.operationState === QMLOperationState.Running) {\n      clearInterval(this._tickerId);\n      this.operationState = QMLOperationState.Idle;\n      this._whenStop.forEach(callback => callback());\n    }\n  }\n\n  // eslint-disable-next-line max-len\n  /** from http://docs.closure-library.googlecode.com/git/local_closure_goog_uri_uri.js.source.html\n   *\n   * Removes dot segments in given path component, as described in\n   * RFC 3986, section 5.2.4.\n   *\n   * @param {string} path A non-empty path component.\n   * @return {string} Path component with removed dot segments.\n   */\n  removeDotSegments(path) {\n    // path.startsWith(\"/\") is not supported in some browsers\n    let leadingSlash = path && path[0] === \"/\";\n    const segments = path.split(\"/\");\n    const out = [];\n\n    for (let pos = 0; pos < segments.length;) {\n      const segment = segments[pos++];\n\n      if (segment === \".\") {\n        if (leadingSlash && pos === segments.length) {\n          out.push(\"\");\n        }\n      } else if (segment === \"..\") {\n        if (out.length > 1 || out.length === 1 && out[0] !== \"\") {\n          out.pop();\n        }\n        if (leadingSlash && pos === segments.length) {\n          out.push(\"\");\n        }\n      } else {\n        out.push(segment);\n        leadingSlash = true;\n      }\n    }\n\n    return out.join(\"/\");\n  }\n\n  extractBasePath(file) {\n    // work both in url (\"/\") and windows (\"\\\", from file://d:\\test\\) notation\n    const basePath = file.split(/[/\\\\]/);\n    basePath[basePath.length - 1] = \"\";\n    return basePath.join(\"/\");\n  }\n\n  extractFileName(file) {\n    return file.split(/[/\\\\]/).pop();\n  }\n\n  // Load file, parse and construct (.qml or .qml.js)\n  loadFile(file, parentComponent = null) {\n    // Create an anchor element to get the absolute path from the DOM\n    if (!this.$basePathA) {\n      this.$basePathA = document.createElement(\"a\");\n    }\n    this.$basePathA.href = this.extractBasePath(file);\n    this.$basePath = this.$basePathA.href;\n    const fileName = this.extractFileName(file);\n    const tree = this.loadComponent(this.$resolvePath(fileName));\n    return this.loadQMLTree(tree, parentComponent, file);\n  }\n\n  // parse and construct qml\n  // file is not required; only for debug purposes\n  // This function is only used by the QmlWeb tests\n  loadQML(src, parentComponent = null, file = undefined) {\n    return this.loadQMLTree(QmlWeb.parseQML(src, file), parentComponent, file);\n  }\n\n  loadQMLTree(tree, parentComponent = null, file = undefined) {\n    QmlWeb.engine = this;\n\n    // Create and initialize objects\n    const QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\n    const component = new QMLComponent({\n      object: tree,\n      parent: parentComponent\n    });\n\n    this.loadImports(tree.$imports, undefined, component.importContextId);\n    component.$basePath = this.$basePath;\n    component.$imports = tree.$imports; // for later use\n    component.$file = file; // just for debugging\n\n    this.rootObject = component.$createObject(parentComponent);\n    component.finalizeImports(this.rootContext());\n    this.$initializePropertyBindings();\n\n    this.start();\n\n    this.callCompletedSignals();\n\n    return component;\n  }\n\n  rootContext() {\n    return this.rootObject.$context;\n  }\n\n  // next 3 methods used in Qt.createComponent for qml files lookup\n  // http://doc.qt.io/qt-5/qqmlengine.html#addImportPath\n\n  addImportPath(dirpath) {\n    this.userAddedImportPaths.push(dirpath);\n  }\n\n  /* Add this dirpath to be checked for components. This is the result of\n   * something like:\n   *\n   * import \"SomeDir/AnotherDirectory\"\n   *\n   * The importContextId ensures it is only accessible from the file in which\n   * it was imported. */\n  addComponentImportPath(importContextId, dirpath, qualifier) {\n    if (!this.componentImportPaths) {\n      this.componentImportPaths = {};\n    }\n    if (!this.componentImportPaths[importContextId]) {\n      this.componentImportPaths[importContextId] = {};\n    }\n\n    const paths = this.componentImportPaths[importContextId];\n\n    if (qualifier) {\n      if (!paths.qualified) {\n        paths.qualified = {};\n      }\n      paths.qualified[qualifier] = dirpath;\n    } else {\n      if (!paths.unqualified) {\n        paths.unqualified = [];\n      }\n      paths.unqualified.push(dirpath);\n    }\n  }\n\n  importSearchPaths(importContextId) {\n    if (!this.componentImportPaths) {\n      return [];\n    }\n    const paths = this.componentImportPaths[importContextId];\n    if (!paths) {\n      return [];\n    }\n    return paths.unqualified || [];\n  }\n\n  qualifiedImportPath(importContextId, qualifier) {\n    if (!this.componentImportPaths) {\n      return \"\";\n    }\n    const paths = this.componentImportPaths[importContextId];\n    if (!paths || !paths.qualified) {\n      return \"\";\n    }\n    return paths.qualified[qualifier] || \"\";\n  }\n\n  setImportPathList(arrayOfDirs) {\n    this.userAddedImportPaths = arrayOfDirs;\n  }\n\n  importPathList() {\n    return this.userAddedImportPaths;\n  }\n\n  // `addModulePath` defines conrete path for module lookup\n  // e.g. addModulePath(\"QtQuick.Controls\", \"http://example.com/controls\")\n  // will force system to `import QtQuick.Controls` module from\n  // `http://example.com/controls/qmldir`\n\n  addModulePath(moduleName, dirPath) {\n    // Keep the mapping. It will be used in loadImports() function.\n    // Remove trailing slash as it required for `readQmlDir`.\n    this.userAddedModulePaths[moduleName] = dirPath.replace(/\\/$/, \"\");\n  }\n\n  registerProperty(obj, propName) {\n    const dependantProperties = [];\n    let value = obj[propName];\n\n    const getter = () => {\n      const QMLProperty = QmlWeb.QMLProperty;\n      if (QMLProperty.evaluatingProperty &&\n          dependantProperties.indexOf(QMLProperty.evaluatingProperty) === -1) {\n        dependantProperties.push(QMLProperty.evaluatingProperty);\n      }\n      return value;\n    };\n\n    const setter = newVal => {\n      value = newVal;\n      for (const i in dependantProperties) {\n        dependantProperties[i].update();\n      }\n    };\n\n    QmlWeb.setupGetterSetter(obj, propName, getter, setter);\n  }\n\n  loadImports(importsArray, currentFileDir = this.$basePath,\n    importContextId = -1)\n  {\n    if (!this.qmldirsContents) {\n      this.qmldirsContents = {}; // cache\n\n      // putting initial keys in qmldirsContents - is a hack. We should find a\n      // way to explain to qmlweb, is this built-in module or qmldir-style\n      // module.\n      for (const module in QmlWeb.modules) {\n        if (module !== \"Main\") {\n          this.qmldirsContents[module] = {};\n        }\n      }\n    }\n\n    if (!this.qmldirs) {\n      this.qmldirs = {}; // resulting components lookup table\n    }\n\n    if (!importsArray || importsArray.length === 0) {\n      return;\n    }\n\n    for (let i = 0; i < importsArray.length; i++) {\n      this.loadImport(importsArray[i], currentFileDir, importContextId);\n    }\n  }\n\n  loadImport(entry, currentFileDir, importContextId) {\n    let name = entry[1];\n\n    // is it url to remote resource\n    const nameIsUrl = name.indexOf(\"//\") === 0 || name.indexOf(\"://\") >= 0;\n    // is it a module name, e.g. QtQuick, QtQuick.Controls, etc\n    const nameIsQualifiedModuleName = entry[4];\n    // local [relative] dir\n    const nameIsDir = !nameIsQualifiedModuleName && !nameIsUrl;\n\n    if (nameIsDir) {\n      name = this.$resolvePath(name, currentFileDir);\n      if (name[name.length - 1] === \"/\") {\n        // remove trailing slash as it required for `readQmlDir`\n        name = name.substr(0, name.length - 1);\n      }\n    }\n\n    let content = this.qmldirsContents[name];\n    // check if we have already loaded that qmldir file\n    if (!content) {\n      if (nameIsQualifiedModuleName && this.userAddedModulePaths[name]) {\n        // 1. we have qualified module and user had configured path for that\n        // module with this.addModulePath\n        content = QmlWeb.readQmlDir(this.userAddedModulePaths[name]);\n      } else if (nameIsUrl || nameIsDir) {\n        // 2. direct load\n        // nameIsUrl => url do not need dirs\n        // nameIsDir => already computed full path above\n        content = QmlWeb.readQmlDir(name);\n      } else {\n        // 3. qt-style lookup for qualified module\n        const probableDirs = [currentFileDir].concat(this.importPathList());\n        const diredName = name.replace(/\\./g, \"/\");\n\n        for (let k = 0; k < probableDirs.length; k++) {\n          const file = probableDirs[k] + diredName;\n          content = QmlWeb.readQmlDir(file);\n          if (content) {\n            break;\n          }\n        }\n      }\n      this.qmldirsContents[name] = content;\n    }\n\n    /* If there is no qmldir, add these directories to the list of places to\n      * search for components (within this import scope). \"noqmldir\" is\n      * inserted into the qmldir cache to avoid future attempts at fetching\n      * the qmldir file, but we always need to the call to\n      * \"addComponentImportPath\" for these sorts of directories. */\n    if (!content || content === \"noqmldir\") {\n      if (nameIsDir) {\n        if (entry[3]) {\n          /* Use entry[1] directly, as we don't want to include the\n            * basePath, otherwise it gets prepended twice in\n            * createComponent. */\n          this.addComponentImportPath(importContextId,\n            `${entry[1]}/`, entry[3]);\n        } else {\n          this.addComponentImportPath(importContextId, `${name}/`);\n        }\n      }\n\n      this.qmldirsContents[name] = \"noqmldir\";\n      return;\n    }\n\n    // copy founded externals to global var\n    // TODO actually we have to copy it to current component\n    for (const attrname in content.externals) {\n      this.qmldirs[attrname] = content.externals[attrname];\n    }\n\n    // keep already loaded qmldir files\n    this.qmldirsContents[name] = content;\n  }\n\n  size() {\n    return {\n      width: this.rootObject.getWidth(),\n      height: this.rootObject.getHeight()\n    };\n  }\n\n  focusedElement() {\n    return this.rootContext().activeFocus;\n  }\n\n  //---------- Private Methods ----------\n\n  $initKeyboard() {\n    document.onkeypress = e => {\n      let focusedElement = this.focusedElement();\n      const event = QmlWeb.eventToKeyboard(e || window.event);\n      const eventName = QmlWeb.keyboardSignals[event.key];\n\n      while (focusedElement && !event.accepted) {\n        const backup = focusedElement.$context.event;\n        focusedElement.$context.event = event;\n        focusedElement.Keys.pressed(event);\n        if (eventName) {\n          focusedElement.Keys[eventName](event);\n        }\n        focusedElement.$context.event = backup;\n        if (event.accepted) {\n          e.preventDefault();\n        } else {\n          focusedElement = focusedElement.$parent;\n        }\n      }\n    };\n\n    document.onkeyup = e => {\n      let focusedElement = this.focusedElement();\n      const event = QmlWeb.eventToKeyboard(e || window.event);\n\n      while (focusedElement && !event.accepted) {\n        const backup = focusedElement.$context.event;\n        focusedElement.$context.event = event;\n        focusedElement.Keys.released(event);\n        focusedElement.$context.event = backup;\n        if (event.accepted) {\n          e.preventDefault();\n        } else {\n          focusedElement = focusedElement.$parent;\n        }\n      }\n    };\n  }\n\n  _tick() {\n    const now = Date.now();\n    const elapsed = now - this._lastTick;\n    this._lastTick = now;\n    this._tickers.forEach(ticker => ticker(now, elapsed));\n  }\n\n  // Load resolved file, parse and construct as Component (.qml)\n  loadComponent(file) {\n    if (file in this.components) {\n      return this.components[file];\n    }\n\n    const uri = this.$parseURI(file);\n    if (!uri) {\n      return undefined;\n    }\n\n    let tree;\n    if (uri.scheme === \"qrc://\") {\n      tree = QmlWeb.qrc[uri.path];\n      if (!tree) {\n        return undefined;\n      }\n      // QmlWeb.qrc contains pre-parsed Component objects, but they still need\n      // convertToEngine called on them.\n      tree = QmlWeb.convertToEngine(tree);\n    } else {\n      const src = QmlWeb.getUrlContents(file, true);\n      if (!src) {\n        console.error(\"QMLEngine.loadComponent: Failed to load:\", file);\n        return undefined;\n      }\n\n      console.log(\"QMLEngine.loadComponent: Loading file:\", file);\n      tree = QmlWeb.parseQML(src, file);\n    }\n\n    if (!tree) {\n      return undefined;\n    }\n\n    if (tree.$children.length !== 1) {\n      console.error(\"QMLEngine.loadComponent: Failed to load:\", file,\n        \": A QML component must only contain one root element!\");\n      return undefined;\n    }\n\n    tree.$file = file;\n    this.components[file] = tree;\n    return tree;\n  }\n\n  // Load resolved file and parse as JavaScript\n  loadJS(file) {\n    if (file in this.js) {\n      return this.js[file];\n    }\n\n    const uri = this.$parseURI(file);\n    if (!uri) {\n      return undefined;\n    }\n\n    if (uri.scheme === \"qrc://\") {\n      return QmlWeb.qrc[uri.path];\n    }\n\n    QmlWeb.loadParser();\n    return QmlWeb.jsparse(QmlWeb.getUrlContents(file));\n  }\n\n  $registerStart(f) {\n    this._whenStart.push(f);\n  }\n\n  $registerStop(f) {\n    this._whenStop.push(f);\n  }\n\n  $addTicker(t) {\n    this._tickers.push(t);\n  }\n\n  $removeTicker(t) {\n    const index = this._tickers.indexOf(t);\n    if (index !== -1) {\n      this._tickers.splice(index, 1);\n    }\n  }\n\n  $initializePropertyBindings() {\n    // Initialize property bindings\n    // we use `while`, because $initializePropertyBindings may be called\n    // recursive (because of Loader and/or createQmlObject )\n    while (this.bindedProperties.length > 0) {\n      const property = this.bindedProperties.shift();\n\n      if (!property.binding) {\n        // Probably, the binding was overwritten by an explicit value. Ignore.\n        continue;\n      }\n\n      if (property.needsUpdate) {\n        property.update();\n      } else if (geometryProperties.indexOf(property.name) >= 0) {\n        // It is possible that bindings with these names was already evaluated\n        // during eval of other bindings but in that case $updateHGeometry and\n        // $updateVGeometry could be blocked during their eval.\n        // So we call them explicitly, just in case.\n        const { obj, changed } = property;\n        if (obj.$updateHGeometry &&\n            changed.isConnected(obj, obj.$updateHGeometry)) {\n          obj.$updateHGeometry(property.val, property.val, property.name);\n        }\n        if (obj.$updateVGeometry &&\n            changed.isConnected(obj, obj.$updateVGeometry)) {\n          obj.$updateVGeometry(property.val, property.val, property.name);\n        }\n      }\n    }\n\n    this.$initializeAliasSignals();\n  }\n\n  // This parses the full URL into scheme, authority and path\n  $parseURI(uri) {\n    const match = uri.match(/^([^/]*?:\\/\\/)(.*?)(\\/.*)$/);\n    if (match) {\n      return {\n        scheme: match[1],\n        authority: match[2],\n        path: match[3]\n      };\n    }\n    return undefined;\n  }\n\n  // Return a path to load the file\n  $resolvePath(file, basePath = this.$basePath) {\n    // probably, replace :// with :/ ?\n    if (!file || file.indexOf(\"://\") !== -1 || file.indexOf(\"data:\") === 0 ||\n      file.indexOf(\"blob:\") === 0) {\n      return file;\n    }\n\n    const basePathURI = this.$parseURI(basePath);\n    if (!basePathURI) {\n      return file;\n    }\n\n    let path = basePathURI.path;\n    if (file.indexOf(\"/\") === 0) {\n      path = file;\n    } else {\n      path = `${path}${file}`;\n    }\n\n    // Remove duplicate slashes and dot segments in the path\n    path = this.removeDotSegments(path.replace(/([^:]\\/)\\/+/g, \"$1\"));\n\n    return `${basePathURI.scheme}${basePathURI.authority}${path}`;\n  }\n\n  // Return a DOM-valid path to load the image (fileURL is an already-resolved\n  // URL)\n  $resolveImageURL(fileURL) {\n    const uri = this.$parseURI(fileURL);\n    // If we are within the resource system, look up a \"real\" path that can be\n    // used by the DOM. If not found, return the path itself without the\n    // \"qrc://\" scheme.\n    if (uri && uri.scheme === \"qrc://\") {\n      return QmlWeb.qrc[uri.path] || uri.path;\n    }\n\n    // Something we can't parse, just pass it through\n    return fileURL;\n  }\n\n  $initializeAliasSignals() {\n    // Perform pending operations. Now we use it only to init alias's \"changed\"\n    // handlers, that's why we have such strange function name.\n    while (this.pendingOperations.length > 0) {\n      const op = this.pendingOperations.shift();\n      op[0](op[1], op[2], op[3]);\n    }\n    this.pendingOperations = [];\n  }\n\n  callCompletedSignals() {\n    // the while loop is better than for..in loop, because completedSignals\n    // array might change dynamically when some completed signal handlers will\n    // create objects dynamically via createQmlObject or Loader\n    while (this.completedSignals.length > 0) {\n      const handler = this.completedSignals.shift();\n      handler();\n    }\n  }\n}\n\nQmlWeb.QMLEngine = QMLEngine;\n","function QMLInteger(val) {\n  return val | 0;\n}\nQMLInteger.plainType = true;\nQmlWeb.qmlInteger = QMLInteger;\n","function QMLList(meta) {\n  const list = [];\n  if (meta.object instanceof Array) {\n    for (const i in meta.object) {\n      list.push(QmlWeb.construct({\n        object: meta.object[i],\n        parent: meta.parent,\n        context: meta.context\n      }));\n    }\n  } else if (meta.object instanceof QmlWeb.QMLMetaElement) {\n    list.push(QmlWeb.construct({\n      object: meta.object,\n      parent: meta.parent,\n      context: meta.context\n    }));\n  }\n\n  return list;\n}\nQMLList.plainType = true;\nQmlWeb.qmlList = QMLList;\n","function QMLNumber(val) {\n  return +val;\n}\nQMLNumber.plainType = true;\nQmlWeb.qmlNumber = QMLNumber;\n","const QMLOperationState = {\n  Idle: 1,\n  Init: 2,\n  Running: 3\n};\n\nQmlWeb.QMLOperationState = QMLOperationState;\n","class QMLProperty {\n  constructor(type, obj, name) {\n    this.obj = obj;\n    this.name = name;\n    this.changed = QmlWeb.Signal.signal([], { obj });\n    this.binding = null;\n    this.objectScope = null;\n    this.componentScope = null;\n    this.value = undefined;\n    this.type = type;\n    this.animation = null;\n    this.needsUpdate = true;\n\n    // This list contains all signals that hold references to this object.\n    // It is needed when deleting, as we need to tidy up all references to this\n    // object.\n    this.$tidyupList = [];\n  }\n\n  // Called by update and set to actually set this.val, performing any type\n  // conversion required.\n  $setVal(val, componentScope) {\n    const constructors = QmlWeb.constructors;\n    if (constructors[this.type] === QmlWeb.qmlList) {\n      this.val = QmlWeb.qmlList({\n        object: val,\n        parent: this.obj,\n        context: componentScope\n      });\n    } else if (val instanceof QmlWeb.QMLMetaElement) {\n      const QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\n      if (constructors[val.$class] === QMLComponent ||\n          constructors[this.type] === QMLComponent) {\n        this.val = new QMLComponent({\n          object: val,\n          parent: this.obj,\n          context: componentScope\n        });\n        /* $basePath must be set here so that Components that are assigned to\n         * properties (e.g. Repeater delegates) can properly resolve child\n         * Components that live in the same directory in\n         * Component.createObject. */\n        this.val.$basePath = componentScope.$basePath;\n      } else {\n        this.val = QmlWeb.construct({\n          object: val,\n          parent: this.obj,\n          context: componentScope\n        });\n      }\n    } else if (val instanceof Object || val === undefined || val === null) {\n      this.val = val;\n    } else if (constructors[this.type].plainType) {\n      this.val = constructors[this.type](val);\n    } else {\n      this.val = new constructors[this.type](val);\n    }\n  }\n\n  // Updater recalculates the value of a property if one of the dependencies\n  // changed\n  update() {\n    this.needsUpdate = false;\n\n    if (!this.binding) {\n      return;\n    }\n\n    const oldVal = this.val;\n\n    try {\n      QMLProperty.pushEvaluatingProperty(this);\n      if (!this.binding.compiled) {\n        this.binding.compile();\n      }\n      this.$setVal(this.binding.eval(this.objectScope, this.componentScope,\n        this.componentScopeBasePath), this.componentScope);\n    } catch (e) {\n      console.log(\"QMLProperty.update binding error:\",\n        e,\n        Function.prototype.toString.call(this.binding.eval)\n      );\n    } finally {\n      QMLProperty.popEvaluatingProperty();\n    }\n\n    if (this.animation) {\n      this.animation.$actions = [{\n        target: this.animation.target || this.obj,\n        property: this.animation.property || this.name,\n        from: this.animation.from || oldVal,\n        to: this.animation.to || this.val\n      }];\n      this.animation.restart();\n    }\n\n    if (this.val !== oldVal) {\n      this.changed(this.val, oldVal, this.name);\n    }\n  }\n\n  // Define getter\n  get() {\n    //if (this.needsUpdate && !QMLProperty.evaluatingPropertyPaused) {\n    if (this.needsUpdate &&\n        QmlWeb.engine.operationState !== QmlWeb.QMLOperationState.Init) {\n      this.update();\n    }\n\n    // If this call to the getter is due to a property that is dependant on this\n    // one, we need it to take track of changes\n    if (QMLProperty.evaluatingProperty) {\n      //console.log(this,QMLProperty.evaluatingPropertyStack.slice(0),this.val);\n      this.changed.connect(\n        QMLProperty.evaluatingProperty,\n        QMLProperty.prototype.update,\n        QmlWeb.Signal.UniqueConnection\n      );\n    }\n\n    if (this.val && this.val.$get) {\n      return this.val.$get();\n    }\n\n    return this.val;\n  }\n  // Define setter\n  set(newVal, reason, objectScope, componentScope) {\n    const oldVal = this.val;\n\n    let val = newVal;\n    if (val instanceof QmlWeb.QMLBinding) {\n      if (!objectScope || !componentScope) {\n        throw new Error(\"Internal error: binding assigned without scope\");\n      }\n      this.binding = val;\n      this.objectScope = objectScope;\n      this.componentScope = componentScope;\n      this.componentScopeBasePath = componentScope.$basePath;\n\n      if (QmlWeb.engine.operationState !== QmlWeb.QMLOperationState.Init) {\n        if (!val.compiled) {\n          val.compile();\n        }\n        try {\n          QMLProperty.pushEvaluatingProperty(this);\n          this.needsUpdate = false;\n          val = this.binding.eval(objectScope, componentScope,\n            this.componentScopeBasePath);\n        } finally {\n          QMLProperty.popEvaluatingProperty();\n        }\n      } else {\n        QmlWeb.engine.bindedProperties.push(this);\n        return;\n      }\n    } else {\n      if (reason !== QMLProperty.ReasonAnimation) {\n        this.binding = null;\n      }\n      if (val instanceof Array) {\n        val = val.slice(); // Copies the array\n      }\n    }\n\n    if (reason === QMLProperty.ReasonInit && typeof val === \"undefined\") {\n      if (QMLProperty.typeInitialValues.hasOwnProperty(this.type)) {\n        val = QMLProperty.typeInitialValues[this.type];\n      }\n    }\n\n    this.$setVal(val, componentScope);\n\n    if (this.val !== oldVal) {\n      if (this.animation && reason === QMLProperty.ReasonUser) {\n        this.animation.running = false;\n        this.animation.$actions = [{\n          target: this.animation.target || this.obj,\n          property: this.animation.property || this.name,\n          from: this.animation.from || oldVal,\n          to: this.animation.to || this.val\n        }];\n        this.animation.running = true;\n      }\n      if (this.obj.$syncPropertyToRemote instanceof Function &&\n          reason === QMLProperty.ReasonUser) {\n        // is a remote object from e.g. a QWebChannel\n        this.obj.$syncPropertyToRemote(this.name, val);\n      } else {\n        this.changed(this.val, oldVal, this.name);\n      }\n    }\n  }\n\n  static pushEvalStack() {\n    QMLProperty.evaluatingPropertyStackOfStacks.push(\n      QMLProperty.evaluatingPropertyStack\n    );\n    QMLProperty.evaluatingPropertyStack = [];\n    QMLProperty.evaluatingProperty = undefined;\n  //  console.log(\"evaluatingProperty=>undefined due to push stck \");\n  }\n\n  static popEvalStack() {\n    QMLProperty.evaluatingPropertyStack =\n      QMLProperty.evaluatingPropertyStackOfStacks.pop() || [];\n    QMLProperty.evaluatingProperty =\n      QMLProperty.evaluatingPropertyStack[\n        QMLProperty.evaluatingPropertyStack.length - 1\n      ];\n  }\n\n  static pushEvaluatingProperty(prop) {\n    // TODO say warnings if already on stack. This means binding loop.\n    // BTW actually we do not loop because needsUpdate flag is reset before\n    // entering update again.\n    if (QMLProperty.evaluatingPropertyStack.indexOf(prop) >= 0) {\n      console.error(\"Property binding loop detected for property\",\n        prop.name,\n        [prop].slice(0)\n      );\n    }\n    QMLProperty.evaluatingProperty = prop;\n    QMLProperty.evaluatingPropertyStack.push(prop); //keep stack of props\n  }\n\n  static popEvaluatingProperty() {\n    QMLProperty.evaluatingPropertyStack.pop();\n    QMLProperty.evaluatingProperty = QMLProperty.evaluatingPropertyStack[\n      QMLProperty.evaluatingPropertyStack.length - 1\n    ];\n  }\n}\n\n// Property that is currently beeing evaluated. Used to get the information\n// which property called the getter of a certain other property for\n// evaluation and is thus dependant on it.\nQMLProperty.evaluatingProperty = undefined;\nQMLProperty.evaluatingPropertyPaused = false;\nQMLProperty.evaluatingPropertyStack = [];\nQMLProperty.evaluatingPropertyStackOfStacks = [];\n\nQMLProperty.typeInitialValues = {\n  int: 0,\n  real: 0,\n  double: 0,\n  string: \"\",\n  bool: false,\n  list: [],\n  enum: 0,\n  url: \"\"\n};\n\nQMLProperty.ReasonUser = 0;\nQMLProperty.ReasonInit = 1;\nQMLProperty.ReasonAnimation = 2;\n\nQmlWeb.QMLProperty = QMLProperty;\n","function QMLString(val) {\n  return `${val}`;\n}\nQMLString.plainType = true;\nQmlWeb.qmlString = QMLString;\n","function QMLUrl(val) {\n  return QmlWeb.engine.$resolvePath(`${val}`);\n}\nQMLUrl.plainType = true;\nQmlWeb.qmlUrl = QMLUrl;\n","function QMLVariant(val) {\n  return val;\n}\nQMLVariant.plainType = true;\nQmlWeb.qmlVariant = QMLVariant;\n","window.addEventListener(\"load\", () => {\n  const metaTags = document.getElementsByTagName(\"body\");\n  for (let i = 0; i < metaTags.length; ++i) {\n    const metaTag = metaTags[i];\n    const source = metaTag.getAttribute(\"data-qml\");\n    if (source) {\n      QmlWeb.qmlEngine = new QmlWeb.QMLEngine();\n      QmlWeb.qmlEngine.loadFile(source);\n      QmlWeb.qmlEngine.start();\n      break;\n    }\n  }\n});\n","const Easing = {\n  Linear: 1,\n  InQuad: 2, OutQuad: 3, InOutQuad: 4, OutInQuad: 5,\n  InCubic: 6, OutCubic: 7, InOutCubic: 8, OutInCubic: 9,\n  InQuart: 10, OutQuart: 11, InOutQuart: 12, OutInQuart: 13,\n  InQuint: 14, OutQuint: 15, InOutQuint: 16, OutInQuint: 17,\n  InSine: 18, OutSine: 19, InOutSine: 20, OutInSine: 21,\n  InExpo: 22, OutExpo: 23, InOutExpo: 24, OutInExpo: 25,\n  InCirc: 26, OutCirc: 27, InOutCirc: 28, OutInCirc: 29,\n  InElastic: 30, OutElastic: 31, InOutElastic: 32, OutInElastic: 33,\n  InBack: 34, OutBack: 35, InOutBack: 36, OutInBack: 37,\n  InBounce: 38, OutBounce: 39, InOutBounce: 40, OutInBounce: 41\n};\n\n// eslint-disable-next-line complexity\nQmlWeb.$ease = (type, period, amplitude, overshoot, t) => {\n  switch (type) {\n    // Linear\n    case Easing.Linear:\n      return t;\n\n    // Quad\n    case Easing.InQuad:\n      return Math.pow(t, 2);\n    case Easing.OutQuad:\n      return -Math.pow(t - 1, 2) + 1;\n    case Easing.InOutQuad:\n      if (t < 0.5) {\n        return 2 * Math.pow(t, 2);\n      }\n      return -2 * Math.pow(t - 1, 2) + 1;\n    case Easing.OutInQuad:\n      if (t < 0.5) {\n        return -2 * Math.pow(t - 0.5, 2) + 0.5;\n      }\n      return 2 * Math.pow(t - 0.5, 2) + 0.5;\n\n    // Cubic\n    case Easing.InCubic:\n      return Math.pow(t, 3);\n    case Easing.OutCubic:\n      return Math.pow(t - 1, 3) + 1;\n    case Easing.InOutCubic:\n      if (t < 0.5) {\n        return 4 * Math.pow(t, 3);\n      }\n      return 4 * Math.pow(t - 1, 3) + 1;\n    case Easing.OutInCubic:\n      return 4 * Math.pow(t - 0.5, 3) + 0.5;\n\n    // Quart\n    case Easing.InQuart:\n      return Math.pow(t, 4);\n    case Easing.OutQuart:\n      return -Math.pow(t - 1, 4) + 1;\n    case Easing.InOutQuart:\n      if (t < 0.5) {\n        return 8 * Math.pow(t, 4);\n      }\n      return -8 * Math.pow(t - 1, 4) + 1;\n    case Easing.OutInQuart:\n      if (t < 0.5) {\n        return -8 * Math.pow(t - 0.5, 4) + 0.5;\n      }\n      return 8 * Math.pow(t - 0.5, 4) + 0.5;\n\n    // Quint\n    case Easing.InQuint:\n      return Math.pow(t, 5);\n    case Easing.OutQuint:\n      return Math.pow(t - 1, 5) + 1;\n    case Easing.InOutQuint:\n      if (t < 0.5) {\n        return 16 * Math.pow(t, 5);\n      }\n      return 16 * Math.pow(t - 1, 5) + 1;\n    case Easing.OutInQuint:\n      if (t < 0.5) {\n        return 16 * Math.pow(t - 0.5, 5) + 0.5;\n      }\n      return 16 * Math.pow(t - 0.5, 5) + 0.5;\n\n    // Sine\n    case Easing.InSine:\n      return -Math.cos(0.5 * Math.PI * t) + 1;\n    case Easing.OutSine:\n      return Math.sin(0.5 * Math.PI * t);\n    case Easing.InOutSine:\n      return -0.5 * Math.cos(Math.PI * t) + 0.5;\n    case Easing.OutInSine:\n      if (t < 0.5) {\n        return 0.5 * Math.sin(Math.PI * t);\n      }\n      return -0.5 * Math.sin(Math.PI * t) + 1;\n\n    // Expo\n    case Easing.InExpo:\n      return 1 / 1023 * (Math.pow(2, 10 * t) - 1);\n    case Easing.OutExpo:\n      return -1024 / 1023 * (Math.pow(2, -10 * t) - 1);\n    case Easing.InOutExpo:\n      if (t < 0.5) {\n        return 1 / 62 * (Math.pow(2, 10 * t) - 1);\n      }\n      return -512 / 31 * Math.pow(2, -10 * t) + 63 / 62;\n    case Easing.OutInExpo:\n      if (t < 0.5) {\n        return -16 / 31 * (Math.pow(2, -10 * t) - 1);\n      }\n      return 1 / 1984 * Math.pow(2, 10 * t) + 15 / 31;\n\n    // Circ\n    case Easing.InCirc:\n      return 1 - Math.sqrt(1 - t * t);\n    case Easing.OutCirc:\n      return Math.sqrt(1 - Math.pow(t - 1, 2));\n    case Easing.InOutCirc:\n      if (t < 0.5) {\n        return 0.5 * (1 - Math.sqrt(1 - 4 * t * t));\n      }\n      return 0.5 * (Math.sqrt(1 - 4 * Math.pow(t - 1, 2)) + 1);\n    case Easing.OutInCirc:\n      if (t < 0.5) {\n        return 0.5 * Math.sqrt(1 - Math.pow(2 * t - 1, 2));\n      }\n      return 0.5 * (2 - Math.sqrt(1 - Math.pow(2 * t - 1, 2)));\n\n    // Elastic\n    case Easing.InElastic:\n      return -amplitude * Math.pow(2, 10 * t - 10) *\n        Math.sin(2 * t * Math.PI / period - Math.asin(1 / amplitude));\n    case Easing.OutElastic:\n      return amplitude * Math.pow(2, -10 * t) *\n        Math.sin(2 * t * Math.PI / period - Math.asin(1 / amplitude)) + 1;\n    case Easing.InOutElastic:\n      if (t < 0.5) {\n        return -0.5 * amplitude * Math.pow(2, 20 * t - 10) *\n          Math.sin(4 * t * Math.PI / period - Math.asin(1 / amplitude));\n      }\n      return -0.5 * amplitude * Math.pow(2, -20 * t + 10) *\n        Math.sin(4 * t * Math.PI / period + Math.asin(1 / amplitude)) + 1;\n    case Easing.OutInElastic:\n      if (t < 0.5) {\n        return 0.5 * amplitude * Math.pow(2, -20 * t) *\n          Math.sin(4 * t * Math.PI / period - Math.asin(1 / amplitude)) + 0.5;\n      }\n      return -0.5 * amplitude * Math.pow(2, 20 * t - 20) *\n        Math.sin(4 * t * Math.PI / period - Math.asin(1 / amplitude)) + 0.5;\n\n    // Back\n    case Easing.InBack:\n      return (overshoot + 1) * Math.pow(t, 3) - overshoot * Math.pow(t, 2);\n    case Easing.OutBack:\n      return (overshoot + 1) * Math.pow(t - 1, 3) +\n             overshoot * Math.pow(t - 1, 2) + 1;\n    case Easing.InOutBack:\n      if (t < 0.5) {\n        return 4 * (overshoot + 1) * Math.pow(t, 3) -\n               2 * overshoot * Math.pow(t, 2);\n      }\n      return 0.5 * (overshoot + 1) * Math.pow(2 * t - 2, 3) +\n             overshoot / 2 * Math.pow(2 * t - 2, 2) + 1;\n    case Easing.OutInBack:\n      if (t < 0.5) {\n        return 0.5 * ((overshoot + 1) * Math.pow(2 * t - 1, 3) +\n               overshoot * Math.pow(2 * t - 1, 2) + 1);\n      }\n      return 4 * (overshoot + 1) * Math.pow(t - 0.5, 3) -\n             2 * overshoot * Math.pow(t - 0.5, 2) + 0.5;\n    // Bounce\n    case Easing.InBounce:\n      if (t < 1 / 11) {\n        return -amplitude * 121 / 16 * (t * t - 1 / 11 * t);\n      } else if (t < 3 / 11) {\n        return -amplitude * 121 / 16 * (t * t - 4 / 11 * t + 3 / 121);\n      } else if (t < 7 / 11) {\n        return -amplitude * 121 / 16 * (t * t - 10 / 11 * t + 21 / 121);\n      }\n      return -(121 / 16) * (t * t - 2 * t + 1) + 1;\n    case Easing.OutBounce:\n      if (t < 4 / 11) {\n        return 121 / 16 * t * t;\n      } else if (t < 8 / 11) {\n        return amplitude * (121 / 16) * (t * t - 12 / 11 * t + 32 / 121) + 1;\n      } else if (t < 10 / 11) {\n        return amplitude * (121 / 16) * (t * t - 18 / 11 * t + 80 / 121) + 1;\n      }\n      return amplitude * (121 / 16) * (t * t - 21 / 11 * t + 10 / 11) + 1;\n    case Easing.InOutBounce:\n      if (t < 1 / 22) {\n        return -amplitude * 121 / 8 * (t * t - 1 / 22 * t);\n      } else if (t < 3 / 22) {\n        return -amplitude * 121 / 8 * (t * t - 2 / 11 * t + 3 / 484);\n      } else if (t < 7 / 22) {\n        return -amplitude * 121 / 8 * (t * t - 5 / 11 * t + 21 / 484);\n      } else if (t < 11 / 22) {\n        return -121 / 8 * (t * t - t + 0.25) + 0.5;\n      } else if (t < 15 / 22) {\n        return 121 / 8 * (t * t - t) + 137 / 32;\n      } else if (t < 19 / 22) {\n        return amplitude * 121 / 8 * (t * t - 17 / 11 * t + 285 / 484) + 1;\n      } else if (t < 21 / 22) {\n        return amplitude * 121 / 8 * (t * t - 20 / 11 * t + 399 / 484) + 1;\n      }\n      return amplitude * 121 / 8 * (t * t - 43 / 22 * t + 21 / 22) + 1;\n    case Easing.OutInBounce:\n      if (t < 4 / 22) {\n        return 121 / 8 * t * t;\n      } else if (t < 8 / 22) {\n        return -amplitude * 121 / 8 * (t * t - 6 / 11 * t + 8 / 121) + 0.5;\n      } else if (t < 10 / 22) {\n        return -amplitude * 121 / 8 * (t * t - 9 / 11 * t + 20 / 121) + 0.5;\n      } else if (t < 11 / 22) {\n        return -amplitude * 121 / 8 * (t * t - 21 / 22 * t + 5 / 22) + 0.5;\n      } else if (t < 12 / 22) {\n        return amplitude * 121 / 8 * (t * t - 23 / 22 * t + 3 / 11) + 0.5;\n      } else if (t < 14 / 22) {\n        return amplitude * 121 / 8 * (t * t - 13 / 11 * t + 42 / 121) + 0.5;\n      } else if (t < 18 / 22) {\n        return amplitude * 121 / 8 * (t * t - 16 / 11 * t + 63 / 121) + 0.5;\n      }\n      return -121 / 8 * (t * t - 2 * t + 117 / 121) + 0.5;\n\n    // Default\n    default:\n      console.error(\"Unsupported animation type: \", type);\n      return t;\n  }\n};\n\nQmlWeb.Easing = Easing;\n","/* eslint accessor-pairs: 0 */\n\nfunction setupGetter(obj, propName, func) {\n  Object.defineProperty(obj, propName, {\n    get: func,\n    configurable: true,\n    enumerable: true\n  });\n}\n\nfunction setupSetter(obj, propName, func) {\n  Object.defineProperty(obj, propName, {\n    set: func,\n    configurable: true,\n    enumerable: false\n  });\n}\n\nfunction setupGetterSetter(obj, propName, getter, setter) {\n  Object.defineProperty(obj, propName, {\n    get: getter,\n    set: setter,\n    configurable: true,\n    enumerable: false\n  });\n}\n\nQmlWeb.setupGetter = setupGetter;\nQmlWeb.setupSetter = setupSetter;\nQmlWeb.setupGetterSetter = setupGetterSetter;\n","class QmlWebHelpers {\n  static arrayFindIndex(array, callback) {\n    // Note: does not support thisArg, we don't need that\n    if (!Array.prototype.findIndex) {\n      for (const key in array) {\n        if (callback(array[key], key, array)) {\n          return key;\n        }\n      }\n      return -1;\n    }\n    return Array.prototype.findIndex.call(array, callback);\n  }\n  static mergeObjects(...args) {\n    const merged = {};\n    for (const i in args) {\n      const arg = args[i];\n      if (!arg) {\n        continue;\n      }\n      for (const key in arg) {\n        merged[key] = arg[key];\n      }\n    }\n    return merged;\n  }\n}\n\nQmlWeb.helpers = QmlWebHelpers;\n","/* @license\n\nMIT License\n\nCopyright (c) 2011 Lauri Paimen <lauri@paimen.info>\nCopyright (c) 2015 Pavel Vasev <pavel.vasev@gmail.com> - initial and working\n                                                         import implementation.\nCopyright (c) 2016 QmlWeb contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n/**\n * Get URL contents.\n * @param url {String} Url to fetch.\n * @param skipExceptions {bool} when turned on, ignore exeptions and return\n *        false. This feature is used by readQmlDir.\n * @private\n * @return {mixed} String of contents or false in errors.\n */\nfunction getUrlContents(url, skipExceptions) {\n  if (typeof QmlWeb.urlContentCache[url] === \"undefined\") {\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, false);\n\n    if (skipExceptions) {\n      try {\n        xhr.send(null);\n      } catch (e) {\n        return false;\n      }\n      // it is OK to not have logging here, because DeveloperTools already will\n      // have red log record\n    } else {\n      xhr.send(null);\n    }\n\n    if (xhr.status !== 200 && xhr.status !== 0) { // 0 if accessing with file://\n      console.log(`Retrieving ${url} failed: ${xhr.responseText}`, xhr);\n      return false;\n    }\n    QmlWeb.urlContentCache[url] = xhr.responseText;\n  }\n  return QmlWeb.urlContentCache[url];\n}\nif (typeof QmlWeb.urlContentCache === \"undefined\") {\n  QmlWeb.urlContentCache = {};\n}\n\n/**\n * Read qmldir spec file at directory.\n * @param url Url of the directory\n * @return {Object} Object, where .internals lists qmldir internal references\n *                          and .externals lists qmldir external references.\n */\n\n/*  Note on how importing works.\n\nparseQML gives us `tree.$imports` variable, which contains information from\n`import` statements.\n\nAfter each call to parseQML, we call engine.loadImports(tree.$imports).\nIt in turn invokes readQmlDir() calls for each import, with respect to current\ncomponent base path and engine.importPathList().\n\nWe keep all component names from all qmldir files in global variable\n`engine.qmldir`.\n\nIn construct() function, we use `engine.qmldir` for component url lookup.\n\nReference import info: http://doc.qt.io/qt-5/qtqml-syntax-imports.html\nAlso please look at notes and TODO's in qtcore.js::loadImports() and\nqtcore.js::construct() methods.\n*/\n\nfunction readQmlDir(url) {\n  // in case 'url' is empty, do not attach \"/\"\n  // Q1: when this happen?\n  const qmldirFileUrl = url.length > 0 ? `${url}/qmldir` : \"qmldir\";\n\n  const parsedUrl = QmlWeb.engine.$parseURI(qmldirFileUrl);\n\n  let qmldir;\n  if (parsedUrl.scheme === \"qrc://\") {\n    qmldir = QmlWeb.qrc[parsedUrl.path];\n  } else {\n    qmldir = getUrlContents(qmldirFileUrl, true) || undefined;\n  }\n\n  const internals = {};\n  const externals = {};\n\n  if (qmldir === undefined) {\n    return false;\n  }\n\n  // we have to check for \"://\"\n  // In that case, item path is meant to be absolute, and we have no need to\n  // prefix it with base url\n  function makeurl(path) {\n    if (path.indexOf(\"://\") > 0) {\n      return path;\n    }\n    return `${url}/${path}`;\n  }\n\n  const lines = qmldir.split(/\\r?\\n/);\n  for (let i = 0; i < lines.length; i++) {\n    // trim\n    const line = lines[i].replace(/^\\s+|\\s+$/g, \"\");\n    if (!line.length || line[0] === \"#\") {\n      // Empty line or comment\n      continue;\n    }\n    const match = line.split(/\\s+/);\n    if (match.length === 2 || match.length === 3) {\n      if (match[0] === \"plugin\") {\n        console.log(`${url}: qmldir plugins are not supported!`);\n      } else if (match[0] === \"internal\") {\n        internals[match[1]] = { url: makeurl(match[2]) };\n      } else if (match.length === 2) {\n        externals[match[0]] = { url: makeurl(match[1]) };\n      } else {\n        externals[match[0]] = { url: makeurl(match[2]), version: match[1] };\n      }\n    } else {\n      console.log(`${url}: unmatched: ${line}`);\n    }\n  }\n  return { internals, externals };\n}\n\nQmlWeb.getUrlContents = getUrlContents;\nQmlWeb.readQmlDir = readQmlDir;\n","function importJavascriptInContext(jsData, $context) {\n  /* Remove any \".pragma\" statements, as they are not valid JavaScript */\n  const source = jsData.source.replace(/\\.pragma.*(?:\\r\\n|\\r|\\n)/, \"\\n\");\n  // TODO: pass more objects to the scope?\n  new Function(\"jsData\", \"$context\", `\n    with(QmlWeb) with ($context) {\n      ${source}\n    }\n    ${jsData.exports.map(sym => `$context.${sym} = ${sym};`).join(\"\")}\n  `)(jsData, $context);\n}\n\nQmlWeb.importJavascriptInContext = importJavascriptInContext;\n","QmlWeb.keyCodeToQt = e => {\n  const Qt = QmlWeb.Qt;\n  e.keypad = e.keyCode >= 96 && e.keyCode <= 111;\n  if (e.keyCode === Qt.Key_Tab && e.shiftKey) {\n    return Qt.Key_Backtab;\n  }\n  if (e.keyCode >= 97 && e.keyCode <= 122) {\n    return e.keyCode - (97 - Qt.Key_A);\n  }\n  return e.keyCode;\n};\n\nQmlWeb.eventToKeyboard = e => ({\n  accepted: false,\n  count: 1,\n  isAutoRepeat: false,\n  key: QmlWeb.keyCodeToQt(e),\n  modifiers: e.ctrlKey * QmlWeb.Qt.CtrlModifier\n           | e.altKey * QmlWeb.Qt.AltModifier\n           | e.shiftKey * QmlWeb.Qt.ShiftModifier\n           | e.metaKey * QmlWeb.Qt.MetaModifier\n           | e.keypad * QmlWeb.Qt.KeypadModifier,\n  text: String.fromCharCode(e.charCode)\n});\n\nQmlWeb.keyboardSignals = {};\n[\n  \"asterisk\", \"back\", \"backtab\", \"call\", \"cancel\", \"delete\", \"escape\", \"flip\",\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \"hangup\", \"menu\", \"no\", \"return\", \"select\",\n  \"space\", \"tab\", \"volumeDown\", \"volumeUp\", \"yes\", \"up\", \"right\", \"down\", \"left\"\n].forEach(key => {\n  const name = key.toString();\n  const qtName = `Key_${name[0].toUpperCase()}${name.slice(1)}`;\n  const prefix = typeof key === \"number\" ? \"digit\" : \"\";\n  QmlWeb.keyboardSignals[QmlWeb.Qt[qtName]] = `${prefix}${name}Pressed`;\n});\n","QmlWeb.executionContext = null;\n\nconst modules = {\n  Main: {\n    int: QmlWeb.qmlInteger,\n    real: QmlWeb.qmlNumber,\n    double: QmlWeb.qmlNumber,\n    string: QmlWeb.qmlString,\n    bool: QmlWeb.qmlBoolean,\n    list: QmlWeb.qmlList,\n    color: QmlWeb.QColor,\n    enum: QmlWeb.qmlNumber,\n    url: QmlWeb.qmlUrl,\n    variant: QmlWeb.qmlVariant,\n    var: QmlWeb.qmlVariant\n  }\n};\n\n// All object constructors\nQmlWeb.constructors = modules.Main;\n\nconst dependants = {};\n\nconst perImportContextConstructors = {};\nlet importContextIds = 0;\n\n// Helper. Adds a type to the constructor list\nfunction registerGlobalQmlType(name, type) {\n  QmlWeb[type.name] = type;\n  QmlWeb.constructors[name] = type;\n  modules.Main[name] = type;\n}\n\n// Helper. Register a type to a module\nfunction registerQmlType(options, constructor) {\n  if (constructor !== undefined) {\n    options.constructor = constructor;\n  }\n\n  if (typeof options.baseClass === \"string\") {\n    // TODO: Does not support version specification (yet?)\n    let baseModule;\n    let baseName;\n    const dot = options.baseClass.lastIndexOf(\".\");\n    if (dot === -1) {\n      baseModule = options.module;\n      baseName = options.baseClass;\n    } else {\n      baseModule = options.baseClass.substring(0, dot);\n      baseName = options.baseClass.substring(dot + 1);\n    }\n    const found = (modules[baseModule] || [])\n                    .filter(descr => descr.name === baseName);\n    if (found.length > 0) {\n      // Ok, we found our base class\n      options.baseClass = found[0].constructor;\n    } else {\n      // Base class not found, delay the loading\n      const baseId = [baseModule, baseName].join(\".\");\n      if (!dependants.hasOwnProperty(baseId)) {\n        dependants[baseId] = [];\n      }\n      dependants[baseId].push(options);\n      return;\n    }\n  }\n\n  const descriptor = typeof options === \"function\" ? {\n    module: options.module,\n    name: options.element,\n    versions: options.versions,\n    baseClass: options.baseClass,\n    enums: options.enums,\n    signals: options.signals,\n    defaultProperty: options.defaultProperty,\n    properties: options.properties,\n    constructor: options\n  } : options;\n\n  descriptor.constructor.$qmlTypeInfo = {\n    enums: descriptor.enums,\n    signals: descriptor.signals,\n    defaultProperty: descriptor.defaultProperty,\n    properties: descriptor.properties\n  };\n\n  if (descriptor.global) {\n    registerGlobalQmlType(descriptor.name, descriptor.constructor);\n  }\n\n  const moduleDescriptor = {\n    name: descriptor.name,\n    versions: descriptor.versions,\n    constructor: descriptor.constructor\n  };\n\n  if (typeof modules[descriptor.module] === \"undefined\") {\n    modules[descriptor.module] = [];\n  }\n  modules[descriptor.module].push(moduleDescriptor);\n\n\n  if (typeof descriptor.baseClass !== \"undefined\") {\n    inherit(descriptor.constructor, descriptor.baseClass);\n  }\n\n  const id = [descriptor.module, descriptor.name].join(\".\");\n  if (dependants.hasOwnProperty(id)) {\n    dependants[id].forEach(opt => registerQmlType(opt));\n    dependants[id].length = 0;\n  }\n}\n\nfunction getConstructor(moduleName, version, name) {\n  if (typeof modules[moduleName] !== \"undefined\") {\n    for (let i = 0; i < modules[moduleName].length; ++i) {\n      const type = modules[moduleName][i];\n      if (type.name === name && type.versions.test(version)) {\n        return type.constructor;\n      }\n    }\n  }\n  return null;\n}\n\nfunction getModuleConstructors(moduleName, version) {\n  const constructors = {};\n  if (typeof modules[moduleName] === \"undefined\") {\n    console.warn(`module \"${moduleName}\" not found`);\n    return constructors;\n  }\n  for (let i = 0; i < modules[moduleName].length; ++i) {\n    const module = modules[moduleName][i];\n    if (module.versions.test(version)) {\n      constructors[module.name] = module.constructor;\n    }\n  }\n  return constructors;\n}\n\nfunction loadImports(self, imports) {\n  const mergeObjects = QmlWeb.helpers.mergeObjects;\n  let constructors = mergeObjects(modules.Main);\n  if (imports.filter(row => row[1] === \"QtQml\").length === 0 &&\n      imports.filter(row => row[1] === \"QtQuick\").length === 1) {\n    imports.push([\"qmlimport\", \"QtQml\", 2, \"\", true]);\n  }\n  for (let i = 0; i < imports.length; ++i) {\n    const [, moduleName, moduleVersion, moduleAlias] = imports[i];\n    const moduleConstructors = getModuleConstructors(moduleName, moduleVersion);\n\n    if (moduleAlias !== \"\") {\n      constructors[moduleAlias] = mergeObjects(\n        constructors[moduleAlias],\n        moduleConstructors\n      );\n    } else {\n      constructors = mergeObjects(constructors, moduleConstructors);\n    }\n  }\n  self.importContextId = importContextIds++;\n  perImportContextConstructors[self.importContextId] = constructors;\n  QmlWeb.constructors = constructors; // TODO: why do we need this?\n}\n\nfunction inherit(constructor, baseClass) {\n  const oldProto = constructor.prototype;\n  constructor.prototype = Object.create(baseClass.prototype);\n  Object.getOwnPropertyNames(oldProto).forEach(prop => {\n    constructor.prototype[prop] = oldProto[prop];\n  });\n  constructor.prototype.constructor = baseClass;\n}\n\nfunction callSuper(self, meta) {\n  const info = meta.super.$qmlTypeInfo || {};\n  meta.super = meta.super.prototype.constructor;\n  meta.super.call(self, meta);\n\n  if (info.enums) {\n    // TODO: not exported to the whole file scope yet\n    Object.keys(info.enums).forEach(name => {\n      self[name] = info.enums[name];\n\n      if (!global[name]) {\n        global[name] = self[name]; // HACK\n      }\n    });\n  }\n  if (info.properties) {\n    Object.keys(info.properties).forEach(name => {\n      let desc = info.properties[name];\n      if (typeof desc === \"string\") {\n        desc = { type: desc };\n      }\n      QmlWeb.createProperty(desc.type, self, name, desc);\n    });\n  }\n  if (info.signals) {\n    Object.keys(info.signals).forEach(name => {\n      const params = info.signals[name];\n      self[name] = QmlWeb.Signal.signal(params);\n    });\n  }\n  if (info.defaultProperty) {\n    self.$defaultProperty = info.defaultProperty;\n  }\n}\n\n/**\n * QML Object constructor.\n * @param {Object} meta Meta information about the object and the creation\n *                      context\n * @return {Object} New qml object\n */\nfunction construct(meta) {\n  let item;\n\n  let constructors = perImportContextConstructors[meta.context.importContextId];\n\n  const classComponents = meta.object.$class.split(\".\");\n  for (let ci = 0; ci < classComponents.length; ++ci) {\n    const c = classComponents[ci];\n    constructors = constructors[c];\n    if (constructors === undefined) {\n      break;\n    }\n  }\n\n  if (constructors !== undefined) {\n    const constructor = constructors;\n    meta.super = constructor;\n    item = new constructor(meta);\n    meta.super = undefined;\n  } else {\n    // Load component from file. Please look at import.js for main notes.\n    // Actually, we have to use that order:\n    // 1) try to load component from current basePath\n    // 2) from importPathList\n    // 3) from directories in imports statements and then\n    // 4) from qmldir files\n    // Currently we support only 1,2 and 4 and use order: 4,1,2\n    // TODO: engine.qmldirs is global for all loaded components.\n    //       That's not qml's original behaviour.\n    const qdirInfo = QmlWeb.engine.qmldirs[meta.object.$class];\n    // Are we have info on that component in some imported qmldir files?\n\n    /* This will also be set in applyProperties, but needs to be set here\n     * for Qt.createComponent to have the correct context. */\n    QmlWeb.executionContext = meta.context;\n\n    let filePath;\n    if (qdirInfo) {\n      filePath = qdirInfo.url;\n    } else if (classComponents.length === 2) {\n      const qualified = QmlWeb.engine.qualifiedImportPath(\n        meta.context.importContextId, classComponents[0]\n      );\n      filePath = `${qualified}${classComponents[1]}.qml`;\n    } else {\n      filePath = `${classComponents[0]}.qml`;\n    }\n\n    const component = QmlWeb.Qt.createComponent(filePath);\n\n    if (!component) {\n      throw new Error(`No constructor found for ${meta.object.$class}`);\n    }\n\n    item = component.$createObject(meta.parent);\n    if (typeof item.dom !== \"undefined\") {\n      item.dom.className += ` ${classComponents[classComponents.length - 1]}`;\n      if (meta.object.id) {\n        item.dom.className += `  ${meta.object.id}`;\n      }\n    }\n    // Handle default properties\n  }\n\n  // id\n  if (meta.object.id) {\n    QmlWeb.setupGetterSetter(\n      meta.context, meta.object.id,\n      () => item,\n      () => {}\n    );\n  }\n\n  // keep path in item for probale use it later in Qt.resolvedUrl\n  item.$context.$basePath = QmlWeb.engine.$basePath; //gut\n\n  // We want to use the item's scope, but this Component's imports\n  item.$context.importContextId = meta.context.importContextId;\n\n  // Apply properties (Bindings won't get evaluated, yet)\n  QmlWeb.applyProperties(meta.object, item, item, item.$context);\n\n  return item;\n}\n\nQmlWeb.modules = modules;\nQmlWeb.registerGlobalQmlType = registerGlobalQmlType;\nQmlWeb.registerQmlType = registerQmlType;\nQmlWeb.getConstructor = getConstructor;\nQmlWeb.loadImports = loadImports;\nQmlWeb.callSuper = callSuper;\nQmlWeb.construct = construct;\n","/**\n * Create property getters and setters for object.\n * @param {Object} obj Object for which gsetters will be set\n * @param {String} propName Property name\n * @param {Object} [options] Options that allow finetuning of the property\n */\nfunction createProperty(type, obj, propName, options = {}) {\n  const QMLProperty = QmlWeb.QMLProperty;\n  const prop = new QMLProperty(type, obj, propName);\n  obj[`${propName}Changed`] = prop.changed;\n  obj.$properties[propName] = prop;\n  obj.$properties[propName].set(options.initialValue, QMLProperty.ReasonInit);\n\n  const getter = () => obj.$properties[propName].get();\n  let setter;\n  if (options.readOnly) {\n    setter = function(newVal) {\n      if (!obj.$canEditReadOnlyProperties) {\n        throw new Error(`property '${propName}' has read only access`);\n      }\n      obj.$properties[propName].set(newVal, QMLProperty.ReasonUser);\n    };\n  } else {\n    setter = function(newVal) {\n      obj.$properties[propName].set(newVal, QMLProperty.ReasonUser);\n    };\n  }\n  QmlWeb.setupGetterSetter(obj, propName, getter, setter);\n  if (obj.$isComponentRoot) {\n    QmlWeb.setupGetterSetter(obj.$context, propName, getter, setter);\n  }\n}\n\n/**\n * Apply properties from metaObject to item.\n * @param {Object} metaObject Source of properties\n * @param {Object} item Target of property apply\n * @param {Object} objectScope Scope in which properties should be evaluated\n * @param {Object} componentScope Component scope in which properties should be\n *                 evaluated\n */\nfunction applyProperties(metaObject, item, objectScopeIn, componentScope) {\n  const QMLProperty = QmlWeb.QMLProperty;\n  const objectScope = objectScopeIn || item;\n  QmlWeb.executionContext = componentScope;\n\n  if (metaObject.$children && metaObject.$children.length !== 0) {\n    if (item.$defaultProperty) {\n      item.$properties[item.$defaultProperty].set(\n        metaObject.$children, QMLProperty.ReasonInit,\n        objectScope, componentScope\n      );\n    } else {\n      throw new Error(\"Cannot assign to unexistant default property\");\n    }\n  }\n  // We purposefully set the default property AFTER using it, in order to only\n  // have it applied for instanciations of this component, but not for its\n  // internal children\n  if (metaObject.$defaultProperty) {\n    item.$defaultProperty = metaObject.$defaultProperty;\n  }\n\n  for (const i in metaObject) {\n    const value = metaObject[i];\n    if (i === \"id\" || i === \"$class\") { // keep them\n      item[i] = value;\n      continue;\n    }\n\n    // skip global id's and internal values\n    if (i === \"id\" || i[0] === \"$\") { // TODO: what? See above.\n      continue;\n    }\n\n    // slots\n    if (i.indexOf(\"on\") === 0 && i.length > 2 && /[A-Z]/.test(i[2])) {\n      const signalName = i[2].toLowerCase() + i.slice(3);\n      if (connectSignal(item, signalName, value, objectScope, componentScope)) {\n        continue;\n      }\n      if (item.$setCustomSlot) {\n        item.$setCustomSlot(signalName, value, objectScope, componentScope);\n        continue;\n      }\n    }\n\n    if (value instanceof Object) {\n      if (applyProperty(item, i, value, objectScope, componentScope)) {\n        continue;\n      }\n    }\n\n    if (item.$properties && i in item.$properties) {\n      item.$properties[i].set(value, QMLProperty.ReasonInit, objectScope,\n                                                             componentScope);\n    } else if (i in item) {\n      item[i] = value;\n    } else if (item.$setCustomData) {\n      item.$setCustomData(i, value);\n    } else {\n      console.warn(\n        `Cannot assign to non-existent property \"${i}\". Ignoring assignment.`\n      );\n    }\n  }\n}\n\nfunction applyProperty(item, i, value, objectScope, componentScope) {\n  const QMLProperty = QmlWeb.QMLProperty;\n\n  if (value instanceof QmlWeb.QMLSignalDefinition) {\n    item[i] = QmlWeb.Signal.signal(value.parameters);\n    if (item.$isComponentRoot) {\n      componentScope[i] = item[i];\n    }\n    return true;\n  }\n\n  if (value instanceof QmlWeb.QMLMethod) {\n    value.compile();\n    item[i] = value.eval(objectScope, componentScope,\n      componentScope.$basePath);\n    if (item.$isComponentRoot) {\n      componentScope[i] = item[i];\n    }\n    return true;\n  }\n\n  if (value instanceof QmlWeb.QMLAliasDefinition) {\n    // TODO\n    // 1. Alias must be able to point to prop or id of local object,\n    //    eg: property alias q: t\n    // 2. Alias may have same name as id it points to: property alias\n    //    someid: someid\n    // 3. Alias proxy (or property proxy) to proxy prop access to selected\n    //    incapsulated object. (think twice).\n    createProperty(\"alias\", item, i);\n    item.$properties[i].componentScope = componentScope;\n    item.$properties[i].componentScopeBasePath = componentScope.$basePath;\n    item.$properties[i].val = value;\n    item.$properties[i].get = function() {\n      const obj = this.componentScope[this.val.objectName];\n      const propertyName = this.val.propertyName;\n      return propertyName ? obj.$properties[propertyName].get() : obj;\n    };\n    item.$properties[i].set = function(newVal, reason, _objectScope,\n                                       _componentScope) {\n      if (!this.val.propertyName) {\n        throw new Error(\"Cannot set alias property pointing to an QML object.\");\n      }\n      const obj = this.componentScope[this.val.objectName];\n      const prop = obj.$properties[this.val.propertyName];\n      prop.set(newVal, reason, _objectScope, _componentScope);\n    };\n\n    if (value.propertyName) {\n      const con = function(prop) {\n        const obj = prop.componentScope[prop.val.objectName];\n        if (!obj) {\n          console.error(\"qtcore: target object \", prop.val.objectName,\n                        \" not found for alias \", prop);\n        } else {\n          const targetProp = obj.$properties[prop.val.propertyName];\n          if (!targetProp) {\n            console.error(\n              \"qtcore: target property [\", prop.val.objectName, \"].\",\n              prop.val.propertyName, \" not found for alias \", prop.name\n            );\n          } else {\n            // targetProp.changed.connect( prop.changed );\n            // it is not sufficient to connect to `changed` of source property\n            // we have to propagate own changed to it too\n            // seems the best way to do this is to make them identical?..\n            // prop.changed = targetProp.changed;\n            // obj[`${i}Changed`] = prop.changed;\n            // no. because those object might be destroyed later.\n            let loopWatchdog = false;\n            targetProp.changed.connect(item, (...args) => {\n              if (loopWatchdog) return;\n              loopWatchdog = true;\n              prop.changed.apply(item, args);\n              loopWatchdog = false;\n            });\n            prop.changed.connect(obj, (...args) => {\n              if (loopWatchdog) return;\n              loopWatchdog = true;\n              targetProp.changed.apply(obj, args);\n              loopWatchdog = false;\n            });\n          }\n        }\n      };\n      QmlWeb.engine.pendingOperations.push([con, item.$properties[i]]);\n    }\n    return true;\n  }\n\n  if (value instanceof QmlWeb.QMLPropertyDefinition) {\n    createProperty(value.type, item, i);\n    item.$properties[i].set(value.value, QMLProperty.ReasonInit,\n                            objectScope, componentScope);\n    return true;\n  }\n\n  if (item[i] && value instanceof QmlWeb.QMLMetaPropertyGroup) {\n    // Apply properties one by one, otherwise apply at once\n    applyProperties(value, item[i], objectScope, componentScope);\n    return true;\n  }\n\n  return false;\n}\n\nfunction connectSignal(item, signalName, value, objectScope, componentScope) {\n  if (!item[signalName]) {\n    console.warn(`No signal called ${signalName} found!`);\n    return undefined;\n  } else if (typeof item[signalName].connect !== \"function\") {\n    console.warn(`${signalName} is not a signal!`);\n    return undefined;\n  }\n\n  if (!value.compiled) {\n    const params = [];\n    for (const j in item[signalName].parameters) {\n      params.push(item[signalName].parameters[j].name);\n    }\n    // Wrap value.src in IIFE in case it includes a \"return\"\n    value.src = `(\n      function(${params.join(\", \")}) {\n        QmlWeb.executionContext = __executionContext;\n        QmlWeb.engine.$oldBasePath = QmlWeb.engine.$basePath;\n        QmlWeb.engine.$basePath = \"${componentScope.$basePath}\";\n        try {\n          (function() {\n            ${value.src}\n          })();\n        } finally {\n          QmlWeb.engine.$basePath = QmlWeb.engine.$oldBasePath;\n        }\n      }\n    )`;\n    value.isFunction = false;\n    value.compile();\n  }\n  // Don't pass in __basePath argument, as QMLEngine.$basePath is set in the\n  // value.src, as we need it set at the time the slot is called.\n  const slot = value.eval(objectScope, componentScope);\n  item[signalName].connect(item, slot);\n  return slot;\n}\n\nQmlWeb.createProperty = createProperty;\nQmlWeb.applyProperties = applyProperties;\nQmlWeb.connectSignal = connectSignal;\n","/* @license\n\nMIT License\n\nCopyright (c) 2011 Lauri Paimen <lauri@paimen.info>\nCopyright (c) 2013 Anton Kreuzkamp <akreuzkamp@web.de>\nCopyright (c) 2016 QmlWeb contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nclass QMLMethod extends QmlWeb.QMLBinding {\n}\n\n/**\n * Create an object representing a QML property definition.\n * @param {String} type The type of the property\n * @param {Array} value The default value of the property\n * @return {Object} Object representing the defintion\n */\nclass QMLPropertyDefinition {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}\n\nclass QMLAliasDefinition {\n  constructor(objName, propName) {\n    this.objectName = objName;\n    this.propertyName = propName;\n  }\n}\n\n/**\n * Create an object representing a QML signal definition.\n * @param {Array} params The parameters the signal ships\n * @return {Object} Object representing the defintion\n */\nclass QMLSignalDefinition {\n  constructor(params) {\n    this.parameters = params;\n  }\n}\n\n/**\n * Create an object representing a group of QML properties (like anchors).\n * @return {Object} Object representing the group\n */\nclass QMLMetaPropertyGroup {\n}\n\n/**\n * Create an object representing a QML element.\n * @param {String} type Type of the element\n * @param {String} onProp Name of the property specified with the \"on\" keyword\n */\nclass QMLMetaElement {\n  constructor(type, onProp) {\n    this.$class = type;\n    this.$children = [];\n    this.$on = onProp;\n  }\n}\n\n// Convert parser tree to the format understood by engine\nfunction convertToEngine(tree) {\n  return convertToEngine.walk(tree);\n}\n\nfunction stringifyDots(elem) {\n  let sub = elem;\n  const path = [];\n  while (sub[0] === \"dot\") {\n    path.push(sub[1]);\n    sub = sub[2];\n  }\n  path.push(sub);\n  return path.join(\".\");\n}\n\nfunction applyProp(item, name, val) {\n  let curr = item; // output structure\n  let sub = name; // input structure\n  while (sub[0] === \"dot\") {\n    if (!curr[sub[1]]) {\n      curr[sub[1]] = new QMLMetaPropertyGroup();\n    }\n    curr = curr[sub[1]];\n    sub = sub[2];\n  }\n  curr[sub] = val;\n}\n\nconvertToEngine.walkers = {\n  toplevel: (imports, statement) => {\n    const item = { $class: \"Component\" };\n    item.$imports = imports;\n    item.$children = [convertToEngine.walk(statement)];\n    return item;\n  },\n  qmlelem: (elem, onProp, statements) => {\n    const item = new QMLMetaElement(stringifyDots(elem), onProp);\n\n    for (const i in statements) {\n      const statement = statements[i];\n      const name = statement[1];\n      const val = convertToEngine.walk(statement);\n      switch (statement[0]) {\n        case \"qmldefaultprop\":\n          item.$defaultProperty = name;\n          item[name] = val;\n          break;\n        case \"qmlprop\":\n        case \"qmlpropdef\":\n        case \"qmlaliasdef\":\n        case \"qmlmethod\":\n        case \"qmlsignaldef\":\n          applyProp(item, name, val);\n          break;\n        case \"qmlelem\":\n          item.$children.push(val);\n          break;\n        case \"qmlobjdef\":\n          throw new Error(\n            \"qmlobjdef support was removed, update qmlweb-parser to ^0.3.0.\"\n          );\n        case \"qmlobj\":\n          // Create object to item\n          item[name] = item[name] || new QMLMetaPropertyGroup();\n          for (const j in val) {\n            item[name][j] = val[j];\n          }\n          break;\n        default:\n          console.log(\"Unknown statement\", statement);\n      }\n    }\n    // Make $children be either a single item or an array, if it's more than one\n    if (item.$children.length === 1) {\n      item.$children = item.$children[0];\n    }\n\n    return item;\n  },\n  qmlprop: (name, tree, src) => {\n    if (name === \"id\") {\n      // id property\n      return tree[1][1];\n    }\n    return convertToEngine.bindout(tree, src);\n  },\n  qmlobjdef: (name, property, tree, src) =>\n    convertToEngine.bindout(tree, src),\n  qmlobj: (elem, statements) => {\n    const item = {};\n    for (const i in statements) {\n      const statement = statements[i];\n      const name = statement[1];\n      const val = convertToEngine.walk(statement);\n      if (statement[0] === \"qmlprop\") {\n        applyProp(item, name, val);\n      }\n    }\n    return item;\n  },\n  qmlmethod: (name, tree, src) =>\n    new QMLMethod(src),\n  qmlpropdef: (name, type, tree, src) =>\n    new QMLPropertyDefinition(\n        type,\n        tree ? convertToEngine.bindout(tree, src) : undefined\n    ),\n  qmlaliasdef: (name, objName, propName) =>\n    new QMLAliasDefinition(objName, propName),\n  qmlsignaldef: (name, params) =>\n    new QMLSignalDefinition(params),\n  qmldefaultprop: tree => convertToEngine.walk(tree),\n  name: src => {\n    if (src === \"true\" || src === \"false\") {\n      return src === \"true\";\n    } else if (typeof src === \"boolean\") {\n      // TODO: is this needed? kept for compat with ==\n      return src;\n    }\n    return new QmlWeb.QMLBinding(src, [\"name\", src]);\n  },\n  num: src => +src,\n  string: src => String(src),\n  array: (tree, src) => {\n    const a = [];\n    let isList = false;\n    let hasBinding = false;\n    for (const i in tree) {\n      const val = convertToEngine.bindout(tree[i]);\n      a.push(val);\n\n      if (val instanceof QMLMetaElement) {\n        isList = true;\n      } else if (val instanceof QmlWeb.QMLBinding) {\n        hasBinding = true;\n      }\n    }\n\n    if (hasBinding) {\n      if (isList) {\n        throw new TypeError(\n          \"An array may either contain bindings or Element definitions.\"\n        );\n      }\n      return new QmlWeb.QMLBinding(src, tree);\n    }\n\n    return a;\n  }\n};\n\nconvertToEngine.walk = function(tree) {\n  const type = tree[0];\n  const walker = convertToEngine.walkers[type];\n  if (!walker) {\n    console.log(`No walker for ${type}`);\n    return undefined;\n  }\n  return walker.apply(type, tree.slice(1));\n};\n\n// Try to bind out tree and return static variable instead of binding\nconvertToEngine.bindout = function(statement, binding) {\n  // We want to process the content of the statement\n  // (but still handle the case, we get the content directly)\n  const tree = statement[0] === \"stat\" ? statement[1] : statement;\n\n  const type = tree[0];\n  const walker = convertToEngine.walkers[type];\n  if (walker) {\n    return walker.apply(type, tree.slice(1));\n  }\n  return new QmlWeb.QMLBinding(binding, tree);\n};\n\n// Help logger\nconvertToEngine.amIn = function(str, tree) {\n  console.log(str);\n  if (tree) console.log(JSON.stringify(tree, null, \"  \"));\n};\n\nfunction loadParser() {\n  if (typeof QmlWeb.parse !== \"undefined\") {\n    return;\n  }\n\n  console.log(\"Loading parser...\");\n  const tags = document.getElementsByTagName(\"script\");\n  for (const i in tags) {\n    if (tags[i].src && tags[i].src.indexOf(\"/qt.\") !== -1) {\n      const src = tags[i].src.replace(\"/qt.\", \"/qmlweb.parser.\");\n      // TODO: rewrite to async loading\n      const xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", src, false);\n      xhr.send(null);\n      if (xhr.status !== 200 && xhr.status !== 0) {\n        // xhr.status === 0 if accessing with file://\n        throw new Error(\"Could not load QmlWeb parser!\");\n      }\n      new Function(xhr.responseText)();\n      QmlWeb.parse = QmlWeb.parse;\n      QmlWeb.jsparse = QmlWeb.jsparse;\n      return;\n    }\n  }\n}\n\n// Function to parse qml and output tree expected by engine\nfunction parseQML(src, file) {\n  loadParser();\n  QmlWeb.parse.nowParsingFile = file;\n  const parsetree = QmlWeb.parse(src, QmlWeb.parse.QmlDocument);\n  return convertToEngine(parsetree);\n}\n\nQmlWeb.QMLMethod = QMLMethod;\nQmlWeb.QMLPropertyDefinition = QMLPropertyDefinition;\nQmlWeb.QMLAliasDefinition = QMLAliasDefinition;\nQmlWeb.QMLSignalDefinition = QMLSignalDefinition;\nQmlWeb.QMLMetaPropertyGroup = QMLMetaPropertyGroup;\nQmlWeb.QMLMetaElement = QMLMetaElement;\nQmlWeb.convertToEngine = convertToEngine;\nQmlWeb.loadParser = loadParser;\nQmlWeb.parseQML = parseQML;\n","/*\n\nQmlWeb.qrc is analogous to the Qt Resource System. It is expected to map a path\nwithin the resource system to the following pieces of data:\n\n1) For a QML Component, it is the return value of QmlWeb.parse\n2) For a JavaScript file, it is the return value of QmlWeb.jsparse\n2) For an image, it is any URL that an <img> tag can accept (e.g. a standard\n   URL to an image resource, or a \"data:\" URI). If there is no entry for a\n   given qrc image path, it will fall back to passing the path right through to\n   the DOM. This is mainly a convenience until support for images is added to\n   gulp-qmlweb.\n\nThe \"data-qml\" tag on <body> can be set to a \"qrc://\" URL like\n\"qrc:///root.qml\" to use a pre-parsed \"/root.qml\" from QmlWeb.qrc.\n\nSince relative URLs are resolved relative to the URL of the containing\ncomponent, any relative URL set within a file in the resource system will also\nresolve within the resource system. To access a Component, JavaScript or image\nfile that is stored outside of the resources system from within the resource\nsystem, a full URL must be used (e.g. \"http://www.example.com/images/foo.png\").\n\nVice-versa, in order to access a Component, JavaScript or image file that is\nstored within the resource system from outside of the resource system, a full\n\"qrc://\" URL must be used (e.g. \"qrc:///images/foo.png\").\n\nMore details here: http://doc.qt.io/qt-5/qml-url.html\n\n*/\nQmlWeb.qrc = {};\n","QmlWeb.registerQmlType({\n  module: \"QmlWeb.Dom\",\n  name: \"DomElement\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    tagName: { type: \"string\", initialValue: \"div\" }\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    const tagName = meta.object.tagName || \"div\";\n    this.dom = document.createElement(tagName);\n\n    // TODO: support properties, styles, perhaps changing the tagName\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QmlWeb\",\n  name: \"RestModel\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    url: \"string\",\n    isLoading: \"bool\",\n    mimeType: { type: \"string\", initialValue: \"application/json\" },\n    queryMimeType: {\n      type: \"string\",\n      initialValue: \"application/x-www-urlencoded\"\n    }\n  },\n  signals: {\n    fetched: [],\n    saved: []\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.attributes = this.getAttributes();\n    this.runningRequests = 0;\n  }\n  fetch() {\n    this.$ajax({\n      method: \"GET\",\n      mimeType: this.mimetype,\n      success: xhr => {\n        this.$xhrReadResponse(xhr);\n        this.fetched();\n      }\n    });\n  }\n  remove() {\n    this.$ajax({\n      method: \"DELETE\",\n      success: () => {\n        this.destroy();\n      }\n    });\n  }\n  create() {\n    this.$sendToServer(\"POST\");\n  }\n  save() {\n    this.$sendToServer(\"PUT\");\n  }\n  $sendToServer(method) {\n    this.$ajax({\n      method,\n      mimeType: this.queryMimeType,\n      body: this.$generateBodyForPostQuery(),\n      success: xhr => {\n        this.$xhrReadResponse(xhr);\n        this.saved();\n      }\n    });\n  }\n  $generateBodyForPostQuery() {\n    const object = {};\n    for (let i = 0; i < this.attributes.length; ++i) {\n      object[this.attributes[i]] = this.$properties[this.attributes[i]].get();\n    }\n    console.log(object);\n    switch (this.queryMimeType) {\n      case \"application/json\":\n      case \"text/json\":\n        return JSON.stringify(object);\n      case \"application/x-www-urlencoded\":\n        return this.$objectToUrlEncoded(object);\n    }\n    return undefined;\n  }\n  $objectToUrlEncoded(object, prefix) {\n    const parts = [];\n    for (let key in object) {\n      if (object.hasOwnProperty(key)) {\n        const value = object[key];\n        if (typeof prefix !== \"undefined\") {\n          key = `${prefix}[${key}]`;\n        }\n        if (typeof value === \"object\") {\n          parts.push(this.$objectToUrlEncoded(value, key));\n        } else {\n          const ekey = this.$myEncodeURIComponent(key);\n          const evalue = this.$myEncodeURIComponent(value);\n          parts.push(`${ekey}=${evalue}`);\n        }\n      }\n    }\n    return parts.join(\"&\");\n  }\n  $myEncodeURIComponent(str) {\n    return encodeURIComponent(str).replace(/[!'()*]/g, c =>\n      `%${c.charCodeAt(0).toString(16)}`\n    );\n  }\n  $ajax(options) {\n    const xhr = new XMLHttpRequest();\n    xhr.overrideMimeType(this.mimeType);\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === XMLHttpRequest.DONE) {\n        if (xhr.status === 200) {\n          options.success(xhr);\n        } else {\n          options.failure(xhr);\n        }\n        this.runningRequests -= 1;\n        if (this.runningRequests <= 0) {\n          this.isLoading = false;\n        }\n      }\n    };\n    xhr.open(options.method, this.url, true);\n    if (typeof options.body !== \"undefined\") {\n      xhr.setRequestHeader(\"Content-Type\", this.queryMimeType);\n      xhr.send(options.body);\n    } else {\n      xhr.send(null);\n    }\n    this.runningRequests += 1;\n    this.isLoading = true;\n  }\n  $xhrReadResponse(xhr) {\n    let responseObject;\n    if (this.mimeType === \"application/json\" || this.mimeType === \"text/json\") {\n      responseObject = JSON.parse(xhr.responseText);\n    }\n    this.$updatePropertiesFromResponseObject(responseObject);\n  }\n  $updatePropertiesFromResponseObject(responseObject) {\n    const QMLProperty = QmlWeb.QMLProperty;\n    for (const key in responseObject) {\n      if (responseObject.hasOwnProperty(key) && this.$hasProperty(key)) {\n        this.$properties[key].set(responseObject[key], QMLProperty.ReasonUser);\n      }\n    }\n  }\n  $hasProperty(name) {\n    return typeof this.$properties[name] !== \"undefined\";\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"Qt.labs.settings\",\n  name: \"Settings\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    category: \"string\"\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    if (typeof window.localStorage === \"undefined\") {\n      return;\n    }\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n  }\n  Component$onCompleted() {\n    this.$loadProperties();\n    this.$initializeProperties();\n  }\n  $getKey(attrName) {\n    return `${this.category}/${attrName}`;\n  }\n  $loadProperties() {\n    this.$attributes.forEach(attrName => {\n      if (!this.$properties[attrName]) return;\n\n      const key = this.$getKey(attrName);\n      this[attrName] = localStorage.getItem(key);\n    });\n  }\n  $initializeProperties() {\n    this.$attributes.forEach(attrName => {\n      if (!this.$properties[attrName]) return;\n\n      let emitter = this;\n      let signalName = `${attrName}Changed`;\n\n      if (this.$properties[attrName].type === \"alias\") {\n        emitter = this.$context[this.$properties[attrName].val.objectName];\n        signalName = `${this.$properties[attrName].val.propertyName}Changed`;\n      }\n\n      emitter[signalName].connect(this, () => {\n        localStorage.setItem(this.$getKey(attrName), this[attrName]);\n      });\n    });\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtGraphicalEffects\",\n  name: \"FastBlur\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    radius: \"real\",\n    source: { type: \"var\", initialValue: null }\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.$previousSource = null;\n    this.$filterObject = undefined;\n\n    this.radiusChanged.connect(this, this.$onRadiusChanged);\n    this.sourceChanged.connect(this, this.$onSourceChanged);\n  }\n  $onRadiusChanged() {\n    this.$updateEffect(this.source);\n  }\n  $onSourceChanged() {\n    this.$updateEffect(this.source);\n  }\n  $updateFilterObject() {\n    this.$filterObject = {\n      transformType: \"filter\",\n      operation: \"blur\",\n      parameters: `${this.radius}px`\n    };\n  }\n  $updateEffect(source) {\n    console.log(\"updating effect\");\n    if (this.$previousSource) {\n      const index = this.$previousSource.transform.indexOf(this.$filterObject);\n      this.$previousSource.transform.splice(index, 1);\n      this.$previousSource.$updateTransform();\n    }\n    if (source && source.transform) {\n      this.$updateFilterObject();\n      console.log(\"updating effect:\", this.$filterObject, source);\n      source.transform.push(this.$filterObject);\n      source.$updateTransform();\n      this.$previousSource = source;\n    } else {\n      this.$previousSource = null;\n    }\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtMobility\",\n  name: \"GeoLocation\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    accuracy: \"double\",\n    altitude: \"double\",\n    altitudeAccuracy: \"double\",\n    heading: \"double\",\n    latitude: \"double\",\n    longitude: \"double\",\n    speed: \"double\",\n    timestamp: \"date\",\n    label: \"string\"\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    if (!navigator.geolocation) {\n      return;\n    }\n\n    navigator.geolocation.getCurrentPosition(pos => this.$updatePosition(pos));\n    navigator.geolocation.watchPosition(pos => this.$updatePosition(pos));\n  }\n  $updatePosition(position) {\n    this.accuracy = position.coords.accuracy;\n    this.altitude = position.coords.altitude;\n    this.altitudeAccuracy = position.coords.altitudeAccuracy;\n    this.heading = position.coords.heading;\n    this.latitude = position.coords.latitude;\n    this.longitude = position.coords.longitude;\n    this.speed = position.coords.speed;\n    this.timestamp = position.timestamp;\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtMultimedia\",\n  name: \"Video\",\n  versions: /^5\\./,\n  baseClass: \"QtQuick.Item\",\n  enums: {\n    MediaPlayer: {\n      NoError: 0, ResourceError: 1, FormatError: 2, NetworkError: 4,\n      AccessDenied: 8, ServiceMissing: 16,\n\n      StoppedState: 0, PlayingState: 1, PausedState: 2,\n\n      NoMedia: 0, Loading: 1, Loaded: 2, Buffering: 4, Stalled: 8,\n      EndOfMedia: 16, InvalidMedia: 32, UnknownStatus: 64\n    },\n    VideoOutput: { PreserveAspectFit: 0, PreserveAspectCrop: 1, Stretch: 2 }\n  },\n  properties: {\n    source: \"string\",\n    duration: \"int\",\n    position: \"int\",\n    autoPlay: \"bool\",\n    muted: \"bool\",\n    volume: \"real\",\n    playbackRate: \"real\",\n    playbackState: \"enum\", // MediaPlayer.StoppedState\n    fillMode: \"enum\", // VideoOutput.PreserveAspectFit\n    status: \"enum\", // MediaPlayer.NoMedia\n    error: \"enum\" // MediaPlayer.NoError\n  },\n  signals: {\n    paused: [],\n    playing: [],\n    stopped: []\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.$runningEventListener = 0;\n\n    this.impl = document.createElement(\"video\");\n    this.impl.style.width = this.impl.style.height = \"100%\";\n    this.impl.style.margin = \"0\";\n    this.dom.appendChild(this.impl);\n\n    this.volume = this.impl.volume;\n    this.duration = this.impl.duration;\n\n    this.impl.addEventListener(\"play\", () => {\n      this.playing();\n      this.playbackState = this.MediaPlayer.PlayingState;\n    });\n\n    this.impl.addEventListener(\"pause\", () => {\n      this.paused();\n      this.playbackState = this.MediaPlayer.PausedState;\n    });\n\n    this.impl.addEventListener(\"timeupdate\", () => {\n      this.$runningEventListener++;\n      this.position = this.impl.currentTime * 1000;\n      this.$runningEventListener--;\n    });\n\n    this.impl.addEventListener(\"ended\", () => {\n      this.stopped();\n      this.playbackState = this.MediaPlayer.StoppedState;\n    });\n\n    this.impl.addEventListener(\"progress\", () => {\n      if (this.impl.buffered.length > 0) {\n        this.progress = this.impl.buffered.end(0) / this.impl.duration;\n        this.status = this.progress < 1 ?\n          this.MediaPlayer.Buffering :\n          this.MediaPlayer.Buffered;\n      }\n    });\n\n    this.impl.addEventListener(\"stalled\", () => {\n      this.status = this.MediaPlayer.Stalled;\n    });\n\n    this.impl.addEventListener(\"canplaythrough\", () => {\n      this.status = this.MediaPlayer.Buffered;\n    });\n\n    this.impl.addEventListener(\"loadstart\", () => {\n      this.status = this.MediaPlayer.Loading;\n    });\n\n    this.impl.addEventListener(\"durationchanged\", () => {\n      this.duration = this.impl.duration;\n    });\n\n    this.impl.addEventListener(\"volumechanged\", () => {\n      this.$runningEventListener++;\n      this.volume = this.impl.volume;\n      this.$runningEventListener--;\n    });\n\n    this.impl.addEventListener(\"suspend\", () => {\n      this.error |= this.MediaPlayer.NetworkError;\n    });\n\n    this.impl.addEventListener(\"error\", () => {\n      this.error |= this.MediaPlayer.ResourceError;\n    });\n\n    this.impl.addEventListener(\"ratechange\", () => {\n      this.$runningEventListener++;\n      this.playbackRate = this.impl.playbackRate;\n      this.$runningEventListener--;\n    });\n\n    this.autoPlayChanged.connect(this, this.$onAutoPlayChanged);\n    this.sourceChanged.connect(this, this.$onSourceChanged);\n    this.positionChanged.connect(this, this.$onPositionChanged);\n    this.volumeChanged.connect(this, this.$onVolumeChanged);\n    this.playbackRateChanged.connect(this, this.$onPlaybackRateChanged);\n    this.mutedChanged.connect(this, this.$onMutedChanged);\n    this.fillModeChanged.connect(this, this.$onFillModeChanged);\n  }\n  $onAutoPlayChanged(newVal) {\n    this.impl.autoplay = newVal;\n  }\n  $onSourceChanged(source) {\n    const parts = source.split(\".\");\n    const extension = parts[parts.length - 1].toLowerCase();\n    const mime = this.mimetypeFromExtension(extension);\n    this.impl.src = source;\n    if (!this.impl.canPlayType(mime)) {\n      this.error |= this.MediaPlayer.FormatError;\n    }\n  }\n  $onPositionChanged(currentTime) {\n    if (this.$runningEventListener > 0) return;\n    this.impl.currentTime = currentTime / 1000;\n  }\n  $onVolumeChanged(volume) {\n    if (this.$runningEventListener > 0) return;\n    this.impl.volume = volume;\n  }\n  $onPlaybackRateChanged(playbackRate) {\n    if (this.$runningEventListener > 0) return;\n    this.impl.playbackRate = playbackRate;\n  }\n  $onMutedChanged(newValue) {\n    if (newValue) {\n      this.$volulmeBackup = this.impl.volume;\n      this.volume = 0;\n    } else {\n      this.volume = this.$volumeBackup;\n    }\n  }\n  $onFillModeChanged(newValue) {\n    switch (newValue) {\n      case this.VideoOutput.Stretch:\n        this.impl.style.objectFit = \"fill\";\n        break;\n      case this.VideoOutput.PreserveAspectFit:\n        this.impl.style.objectFit = \"\";\n        break;\n      case this.VideoOutput.PreserveAspectCrop:\n        this.impl.style.objectFit = \"cover\";\n        break;\n    }\n  }\n  pause() {\n    this.impl.pause();\n  }\n  play() {\n    this.impl.play();\n  }\n  seek(offset) {\n    this.impl.currentTime = offset * 1000;\n  }\n  stop() {\n  }\n  mimetypeFromExtension(extension) {\n    const mimetypes = {\n      ogg: \"video/ogg\",\n      ogv: \"video/ogg\",\n      ogm: \"video/ogg\",\n      mp4: \"video/mp4\",\n      webm: \"video/webm\"\n    };\n    return mimetypes[extension] || \"\";\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQml\",\n  name: \"Binding\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    target: { type: \"QtObject\", initialValue: null },\n    property: { type: \"string\", initialValue: \"\" },\n    value: { type: \"var\", initialValue: undefined },\n    when: { type: \"bool\", initialValue: true }\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.$property = undefined;\n\n    this.valueChanged.connect(this, this.$onValueChanged);\n    this.targetChanged.connect(this, this.$updateBinding);\n    this.propertyChanged.connect(this, this.$updateBinding);\n    this.whenChanged.connect(this, this.$updateBinding);\n  }\n\n  $updateBinding() {\n    if (!this.when || !this.target\n        || !this.target.hasOwnProperty(this.property)\n        || this.value === undefined)\n    {\n      this.$property = undefined;\n      return;\n    }\n    this.$property = this.target.$properties[this.property];\n    this.$onValueChanged(this.value); // trigger value update\n  }\n\n  $onValueChanged(value) {\n    if (value !== undefined && this.$property) {\n      this.$property.set(value);\n    }\n  }\n});\n","class QMLContext {\n  nameForObject(obj) {\n    for (const name in this) {\n      if (this[name] === obj) {\n        return name;\n      }\n    }\n    return undefined;\n  }\n}\n\nclass QMLComponent {\n  constructor(meta) {\n    if (QmlWeb.constructors[meta.object.$class] === QMLComponent) {\n      this.$metaObject = meta.object.$children[0];\n    } else {\n      this.$metaObject = meta.object;\n    }\n    this.$context = meta.context;\n\n    this.$jsImports = [];\n\n    if (meta.object.$imports instanceof Array) {\n      const moduleImports = [];\n      const loadImport = importDesc => {\n        if (/\\.js$/.test(importDesc[1])) {\n          this.$jsImports.push(importDesc);\n        } else {\n          moduleImports.push(importDesc);\n        }\n      };\n\n      for (let i = 0; i < meta.object.$imports.length; ++i) {\n        loadImport(meta.object.$imports[i]);\n      }\n      QmlWeb.loadImports(this, moduleImports);\n      if (this.$context) {\n        this.finalizeImports(this.$context);\n      }\n    }\n\n    /* If this Component does not have any imports, it is likely one that was\n     * created within another Component file. It should inherit the\n     * importContextId of the Component file it was created within. */\n    if (this.importContextId === undefined) {\n      this.importContextId = meta.context.importContextId;\n    }\n  }\n  finalizeImports($context) {\n    const engine = QmlWeb.engine;\n    for (let i = 0; i < this.$jsImports.length; ++i) {\n      const importDesc = this.$jsImports[i];\n      const js = engine.loadJS(engine.$resolvePath(importDesc[1]));\n\n      if (!js) {\n        console.log(\"Component.finalizeImports: failed to import JavaScript\",\n          importDesc[1]);\n        continue;\n      }\n\n      if (importDesc[3] !== \"\") {\n        $context[importDesc[3]] = {};\n        QmlWeb.importJavascriptInContext(js, $context[importDesc[3]]);\n      } else {\n        QmlWeb.importJavascriptInContext(js, $context);\n      }\n    }\n  }\n  $createObject(parent, properties = {}, context = this.$context) {\n    const engine = QmlWeb.engine;\n    const oldState = engine.operationState;\n    engine.operationState = QmlWeb.QMLOperationState.Init;\n    // change base path to current component base path\n    const bp = engine.$basePath;\n    engine.$basePath = this.$basePath ? this.$basePath : engine.$basePath;\n\n    const newContext = context ? Object.create(context) : new QMLContext();\n\n    if (this.importContextId !== undefined) {\n      newContext.importContextId = this.importContextId;\n    }\n\n    const item = QmlWeb.construct({\n      object: this.$metaObject,\n      parent,\n      context: newContext,\n      isComponentRoot: true\n    });\n\n    Object.keys(properties).forEach(propname => {\n      item[propname] = properties.propname;\n    });\n\n    // change base path back\n    // TODO looks a bit hacky\n    engine.$basePath = bp;\n\n    engine.operationState = oldState;\n    return item;\n  }\n  createObject(parent, properties = {}) {\n    const item = this.$createObject(parent, properties);\n    const QMLItem = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Item\");\n\n    if (item instanceof QMLItem) {\n      item.$properties.parent.set(parent, QmlWeb.QMLProperty.ReasonInit);\n    }\n\n    return item;\n  }\n  static getAttachedObject() {\n    if (!this.$Component) {\n      this.$Component = new QmlWeb.QObject(this);\n      this.$Component.completed = QmlWeb.Signal.signal([]);\n      QmlWeb.engine.completedSignals.push(this.$Component.completed);\n\n      this.$Component.destruction = QmlWeb.Signal.signal([]);\n    }\n    return this.$Component;\n  }\n}\n\nQmlWeb.registerQmlType({\n  global: true,\n  module: \"QtQml\",\n  name: \"Component\",\n  versions: /.*/,\n  baseClass: \"QtObject\",\n  constructor: QMLComponent\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQml\",\n  name: \"Connections\",\n  versions: /.*/,\n  baseClass: \"QtObject\",\n  properties: {\n    target: \"QtObject\",\n    ignoreUnknownSignals: \"bool\"\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n    this.target = this.$parent;\n    this.$connections = {};\n\n    this.$old_target = this.target;\n    this.targetChanged.connect(this, this.$onTargetChanged);\n    this.Component.completed.connect(this, this.Component$onCompleted);\n  }\n  $onTargetChanged() {\n    this.$reconnectTarget();\n  }\n  Component$onCompleted() {\n    this.$reconnectTarget();\n  }\n  $reconnectTarget() {\n    const old_target = this.$old_target;\n    for (const i in this.$connections) {\n      const c = this.$connections[i];\n      if (c._currentConnection && old_target && old_target[i] &&\n          typeof old_target[i].disconnect === \"function\") {\n        old_target[i].disconnect(c._currentConnection);\n      }\n      if (this.target) {\n        c._currentConnection = QmlWeb.connectSignal(this.target, i, c.value,\n          c.objectScope, c.componentScope);\n      }\n    }\n    this.$old_target = this.target;\n  }\n  $setCustomSlot(propName, value, objectScope, componentScope) {\n    this.$connections[propName] = { value, objectScope, componentScope };\n  }\n});\n","// Base object for all qml elements\n\nQmlWeb.registerQmlType({\n  module: \"QtQml\",\n  name: \"QtObject\",\n  versions: /.*/,\n}, class extends QmlWeb.QObject {\n  constructor(meta) {\n    super(meta.parent);\n\n    this.$isComponentRoot = meta.isComponentRoot;\n    this.$context = meta.context;\n\n    // Component get own properties\n    this.$attributes = [];\n    for (const key in meta.object) {\n      if (!meta.object.hasOwnProperty(key) || !meta.object[key]) {\n        continue;\n      }\n      const name = meta.object[key].__proto__.constructor.name;\n      if (name === \"QMLPropertyDefinition\" || name === \"QMLAliasDefinition\") {\n        this.$attributes.push(key);\n      }\n    }\n\n    const Signal = QmlWeb.Signal;\n\n    this.Keys = new QmlWeb.QObject(this);\n    this.Keys.asteriskPresed = Signal.signal();\n    this.Keys.backPressed = Signal.signal();\n    this.Keys.backtabPressed = Signal.signal();\n    this.Keys.callPressed = Signal.signal();\n    this.Keys.cancelPressed = Signal.signal();\n    this.Keys.deletePressed = Signal.signal();\n    for (let i = 0; i < 10; ++i) {\n      this.Keys[`digit${i}Pressed`] = Signal.signal();\n    }\n    this.Keys.escapePressed = Signal.signal();\n    this.Keys.flipPressed = Signal.signal();\n    this.Keys.hangupPressed = Signal.signal();\n    this.Keys.leftPressed = Signal.signal();\n    this.Keys.menuPressed = Signal.signal();\n    this.Keys.noPressed = Signal.signal();\n    this.Keys.pressed = Signal.signal();\n    this.Keys.released = Signal.signal();\n    this.Keys.returnPressed = Signal.signal();\n    this.Keys.rightPressed = Signal.signal();\n    this.Keys.selectPressed = Signal.signal();\n    this.Keys.spacePressed = Signal.signal();\n    this.Keys.tabPressed = Signal.signal();\n    this.Keys.upPressed = Signal.signal();\n    this.Keys.volumeDownPressed = Signal.signal();\n    this.Keys.volumeUpPressed = Signal.signal();\n    this.Keys.yesPressed = Signal.signal();\n  }\n  getAttributes() {\n    return this.$attributes;\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQml\",\n  name: \"Timer\",\n  versions: /.*/,\n  baseClass: \"QtObject\",\n  properties: {\n    interval: { type: \"int\", initialValue: 1000 },\n    parent: { type: \"QtObject\", readOnly: true },\n    repeat: \"bool\",\n    running: \"bool\",\n    triggeredOnStart: \"bool\"\n  },\n  signals: {\n    triggered: []\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.$properties.parent.set(this.$parent, QmlWeb.QMLProperty.ReasonInit);\n\n    /* This ensures that if the user toggles the \"running\" property manually,\n     * the timer will trigger. */\n    this.runningChanged.connect(this, this.$onRunningChanged);\n\n    QmlWeb.engine.$addTicker((...args) => this.$ticker(...args));\n\n    QmlWeb.engine.$registerStart(() => {\n      if (this.running) {\n        this.restart();\n      }\n    });\n\n    QmlWeb.engine.$registerStop(() => this.stop());\n  }\n  start() {\n    this.running = true;\n  }\n  stop() {\n    this.running = false;\n  }\n  restart() {\n    this.stop();\n    this.start();\n  }\n  $ticker(now) {\n    if (!this.running) return;\n    if (now - this.$prevTrigger >= this.interval) {\n      this.$prevTrigger = now;\n      this.$trigger();\n    }\n  }\n  $onRunningChanged() {\n    if (this.running) {\n      this.$prevTrigger = Date.now();\n      if (this.triggeredOnStart) {\n        this.$trigger();\n      }\n    }\n  }\n  $trigger() {\n    if (!this.repeat) {\n      // We set the value directly in order to be able to emit the\n      // runningChanged signal after triggered, like Qt does it.\n      this.$properties.running.val = false;\n    }\n\n    // Trigger this.\n    this.triggered();\n\n    if (!this.repeat) {\n      // Emit changed signal manually after setting the value manually above.\n      this.runningChanged();\n    }\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"Button\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    text: \"string\",\n    enabled: { type: \"bool\", initialValue: true }\n  },\n  signals: {\n    clicked: []\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n    this.textChanged.connect(this, this.$onTextChanged);\n    this.enabledChanged.connect(this, this.$onEnabledChanged);\n\n    const button = this.impl = document.createElement(\"button\");\n    button.style.pointerEvents = \"auto\";\n    this.dom.appendChild(button);\n\n    button.onclick = () => {\n      this.clicked();\n    };\n  }\n  Component$onCompleted() {\n    this.implicitWidth = this.impl.offsetWidth;\n    this.implicitHeight = this.impl.offsetHeight;\n  }\n  $onTextChanged(newVal) {\n    this.impl.textContent = newVal;\n    //TODO: Replace those statically sized borders\n    this.implicitWidth = this.impl.offsetWidth;\n    this.implicitHeight = this.impl.offsetHeight;\n  }\n  $onEnabledChanged(newVal) {\n    this.impl.disabled = !newVal;\n  }\n\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"CheckBox\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    text: \"string\",\n    checked: \"bool\",\n    color: \"color\"\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.impl = document.createElement(\"label\");\n    this.impl.style.pointerEvents = \"auto\";\n\n    const checkbox = document.createElement(\"input\");\n    checkbox.type = \"checkbox\";\n    checkbox.style.verticalAlign = \"text-bottom\";\n    checkbox.addEventListener(\"change\", () => {\n      this.checked = checkbox.checked;\n    });\n    this.impl.appendChild(checkbox);\n\n    const span = document.createElement(\"span\");\n    this.impl.appendChild(span);\n\n    this.dom.appendChild(this.impl);\n\n    const QMLFont = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Font\");\n    this.font = new QMLFont(this);\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n    this.textChanged.connect(this, this.$onTextChanged);\n    this.colorChanged.connect(this, this.$onColorChanged);\n    this.checkedChanged.connect(this, this.$onCheckedChanged);\n  }\n  $onTextChanged(newVal) {\n    this.impl.children[1].innerHTML = newVal;\n    this.implicitHeight = this.impl.offsetHeight;\n    this.implicitWidth = this.impl.offsetWidth > 0 ?\n                          this.impl.offsetWidth + 4 :\n                          0;\n  }\n  $onColorChanged(newVal) {\n    this.impl.children[1].style.color = new QmlWeb.QColor(newVal);\n  }\n  $onCheckedChanged() {\n    this.impl.children[0].checked = this.checked;\n  }\n  Component$onCompleted() {\n    this.implicitHeight = this.impl.offsetHeight;\n    this.implicitWidth = this.impl.offsetWidth > 0 ?\n                          this.impl.offsetWidth + 4 :\n                          0;\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"ComboBox\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    count: \"int\",\n    currentIndex: \"int\",\n    currentText: \"string\",\n    menu: { type: \"array\", initialValue: [] },\n    model: { type: \"array\", initialValue: [] },\n    pressed: \"bool\"\n  },\n  signals: {\n    accepted: [],\n    activated: [{ type: \"int\", name: \"index\" }]\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.dom.style.pointerEvents = \"auto\";\n    this.name = \"QMLComboBox\";\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n    this.modelChanged.connect(this, this.$onModelChanged);\n\n    this.dom.onclick = () => {\n      const index = this.dom.firstChild.selectedIndex;\n      this.currentIndex = index;\n      this.currentText = this.model[index];\n      this.accepted();\n      this.activated(index);\n    };\n  }\n  find(text) {\n    return this.model.indexOf(text);\n  }\n  selectAll() {\n    // TODO\n  }\n  textAt(index) {\n    return this.model[index];\n  }\n  $updateImpl() {\n    this.currentIndex = 0;\n    this.count = this.model.length;\n    const entries = [];\n    for (let i = 0; i < this.count; i++) {\n      const elt = this.model[i];\n      //if (elt instanceof Array) { // TODO - optgroups? update model !\n      //    var count_i = elt.length;\n      //    for (var j = 0; j < count_i; j++)\n      //        html += \"<option>\" + elt[j] + \"</option>\";\n      //}\n      //else\n      entries.push(`<option>${elt}</option>`);\n    }\n    // TODO: remove innerHTML, port to DOM\n    this.dom.innerHTML = `<select>${entries.join(\"\")}</select>`;\n    this.impl = this.dom.firstChild;\n  }\n  Component$onCompleted() {\n    this.$updateImpl();\n    this.implicitWidth = this.impl.offsetWidth;\n    this.implicitHeight = this.impl.offsetHeight;\n  }\n  $onModelChanged() {\n    this.$updateImpl();\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"ScrollView\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    contentItem: \"Item\",\n    flickableItem: \"Item\", // TODO  0) implement it  1) make it read-only\n    viewport: \"Item\", // TODO\n    frameVisible: \"bool\",\n    highlightOnFocus: \"bool\", // TODO test\n    verticalScrollBarPolicy: \"enum\",\n    horizontalScrollBarPolicy: \"enum\",\n    style: \"Component\" // TODO\n  },\n  defaultProperty: \"contentItem\"\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.css.pointerEvents = \"auto\";\n    this.setupFocusOnDom(this.dom);\n\n    this.contentItemChanged.connect(this, this.$onContentItemChanged);\n    this.flickableItemChanged.connect(this, this.$onFlickableItemChanged);\n    this.viewportChanged.connect(this, this.$onViewportChanged);\n    this.frameVisibleChanged.connect(this, this.$onFrameVisibleChanged);\n    this.highlightOnFocusChanged.connect(this, this.$onHighlightOnFocusChanged);\n    this.horizontalScrollBarPolicyChanged.connect(this,\n                                      this.$onHorizontalScrollBarPolicyChanged);\n    this.verticalScrollBarPolicyChanged.connect(this,\n                                        this.$onVerticalScrollBarPolicyChanged);\n    this.styleChanged.connect(this, this.$onStyleChanged);\n    this.childrenChanged.connect(this, this.$onChildrenChanged);\n    this.focusChanged.connect(this, this.$onFocusChanged);\n\n    this.width = this.implicitWidth = 240; // default QML ScrollView width\n    this.height = this.implicitHeight = 150; // default QML ScrollView height\n    this.width = this.implicitWidth;\n    this.height = this.implicitHeight;\n\n    const Qt = QmlWeb.Qt;\n    this.contentItem = undefined;\n    this.flickableItem = undefined;\n    this.viewport = undefined;\n    this.frameVisible = false;\n    this.highlightOnFocus = false;\n    this.verticalScrollBarPolicy = Qt.ScrollBarAsNeeded;\n    this.horizontalScrollBarPolicy = Qt.ScrollBarAsNeeded;\n    this.style = undefined;\n  }\n  $onContentItemChanged(newItem) {\n    if (typeof newItem !== undefined) {\n      newItem.parent = this;\n    }\n  }\n  $onFlickableItemChanged() {\n  }\n  $onHighlightOnFocusChanged() {\n  }\n  $onViewportChanged() {\n  }\n  $onFocusChanged(focus) {\n    this.css.outline = this.highlight && focus\n      ? \"outline: lightblue solid 2px;\"\n      : \"\";\n  }\n  $onFrameVisibleChanged(visible) {\n    this.css.border = visible ? \"1px solid gray\" : \"hidden\";\n  }\n  $onHorizontalScrollBarPolicyChanged(newPolicy) {\n    this.css.overflowX = this.$scrollBarPolicyToCssOverflow(newPolicy);\n  }\n  $onVerticalScrollBarPolicyChanged(newPolicy) {\n    this.css.overflowY = this.$scrollBarPolicyToCssOverflow(newPolicy);\n  }\n  $onStyleChanged() {\n  }\n  $onChildrenChanged() {\n    if (typeof this.contentItem === \"undefined\" && this.children.length === 1) {\n      this.contentItem = this.children[0];\n    }\n  }\n  $scrollBarPolicyToCssOverflow(policy) {\n    const Qt = QmlWeb.Qt;\n    switch (policy) {\n      case Qt.ScrollBarAsNeeded:\n        return \"auto\";\n      case Qt.ScrollBarAlwaysOff:\n        return \"hidden\";\n      case Qt.ScrollBarAlwaysOn:\n        return \"scroll\";\n    }\n    return \"auto\";\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"TextArea\",\n  versions: /.*/,\n  baseClass: \"QtQuick.TextEdit\"\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n    const textarea = this.impl;\n    textarea.style.padding = \"5px\";\n    textarea.style.borderWidth = \"1px\";\n    textarea.style.backgroundColor = \"#fff\";\n  }\n});\n","/**\n *\n * TextField is used to accept a line of text input.\n * Input constraints can be placed on a TextField item\n * (for example, through a validator or inputMask).\n * Setting echoMode to an appropriate value enables TextField\n * to be used for a password input field.\n *\n * Valid entries for echoMode and alignment are defined in TextInput.\n *\n */\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"TextField\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  enums: {\n    TextInput: { Normal: 0, Password: 1, NoEcho: 2, PasswordEchoOnEdit: 3 }\n  },\n  properties: {\n    text: \"string\",\n    maximumLength: { type: \"int\", initialValue: -1 },\n    readOnly: \"bool\",\n    validator: \"var\",\n    echoMode: \"enum\" // TextInput.Normal\n  },\n  signals: {\n    accepted: []\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    const QMLFont = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Font\");\n    this.font = new QMLFont(this);\n\n    const input = this.impl = document.createElement(\"input\");\n    input.type = \"text\";\n    input.disabled = true;\n    input.style.pointerEvents = \"auto\";\n    input.style.margin = \"0\";\n    input.style.width = \"100%\";\n    this.dom.appendChild(input);\n    this.setupFocusOnDom(input);\n    input.disabled = false;\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n    this.textChanged.connect(this, this.$onTextChanged);\n    this.echoModeChanged.connect(this, this.$onEchoModeChanged);\n    this.maximumLengthChanged.connect(this, this.$onMaximumLengthChanged);\n    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);\n    this.Keys.pressed.connect(this, this.Keys$onPressed);\n\n    this.impl.addEventListener(\"input\", () => this.$updateValue());\n  }\n  Component$onCompleted() {\n    this.implicitWidth = this.impl.offsetWidth;\n    this.implicitHeight = this.impl.offsetHeight;\n  }\n  $onTextChanged(newVal) {\n    // See TextInput for comments\n    if (this.impl.value !== newVal) {\n      this.impl.value = newVal;\n    }\n  }\n  $onEchoModeChanged(newVal) {\n    const TextInput = this.TextInput;\n    const input = this.impl;\n    switch (newVal) {\n      case TextInput.Normal:\n        input.type = \"text\";\n        break;\n      case TextInput.Password:\n        input.type = \"password\";\n        break;\n      case TextInput.NoEcho:\n        // Not supported, use password, that's nearest\n        input.type = \"password\";\n        break;\n      case TextInput.PasswordEchoOnEdit:\n        // Not supported, use password, that's nearest\n        input.type = \"password\";\n        break;\n    }\n  }\n  $onMaximumLengthChanged(newVal) {\n    this.impl.maxLength = newVal < 0 ? null : newVal;\n  }\n  $onReadOnlyChanged(newVal) {\n    this.impl.disabled = newVal;\n  }\n  Keys$onPressed(e) {\n    const Qt = QmlWeb.Qt;\n    const submit = e.key === Qt.Key_Return || e.key === Qt.Key_Enter;\n    if (submit && this.$testValidator()) {\n      this.accepted();\n      e.accepted = true;\n    }\n  }\n  $testValidator() {\n    if (this.validator) {\n      return this.validator.validate(this.text);\n    }\n    return true;\n  }\n  $updateValue() {\n    if (this.text !== this.impl.value) {\n      this.$canEditReadOnlyProperties = true;\n      this.text = this.impl.value;\n      this.$canEditReadOnlyProperties = false;\n    }\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick.Window\",\n  name: \"Screen\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    name: \"string\",\n    orientation: \"enum\",\n    orientationUpdateMask: \"enum\",\n    primaryOrientation: \"enum\",\n    pixelDensity: \"real\",\n    devicePixelRatio: \"real\",\n    desktopAvailableHeight: \"int\",\n    desktopAvailableWidth: \"int\",\n    height: \"int\",\n    width: \"int\"\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    // TODO: rewrite as an attached object and forbid constructing\n    this.Component.completed.connect(this, this.Component$onCompleted);\n  }\n  Component$onCompleted() {\n    const Qt = QmlWeb.Qt;\n    this.desktopAvailableHeight = window.outerHeight;\n    this.desktopAvailableWidth = window.outerWidth;\n    this.devicePixelRatio = window.devicePixelRatio;\n    this.height = window.innerHeight;\n    this.name = this.name;\n    this.orientation = Qt.PrimaryOrientation;\n    this.orientationUpdateMask = 0;\n    this.pixelDensity = 100.0;  // TODO\n    this.primaryOrientation = Qt.PrimaryOrientation;\n    this.width = window.innerWidth;\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"AnimatedImage\",\n  versions: /.*/,\n  baseClass: \"Image\"\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Animation\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    Animation: { Infinite: -1 },\n    Easing: QmlWeb.Easing\n  },\n  properties: {\n    alwaysRunToEnd: \"bool\",\n    loops: { type: \"int\", initialValue: 1 },\n    paused: \"bool\",\n    running: \"bool\"\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n  }\n  restart() {\n    this.stop();\n    this.start();\n  }\n  start() {\n    this.running = true;\n  }\n  stop() {\n    this.running = false;\n  }\n  pause() {\n    this.paused = true;\n  }\n  resume() {\n    this.paused = false;\n  }\n  complete() {\n    // To be overridden\n    console.log(\"Unbound method for\", this);\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Behavior\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    animation: \"Animation\",\n    enabled: { type: \"bool\", initialValue: true }\n  },\n  defaultProperty: \"animation\"\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n    this.$on = meta.object.$on;\n\n    this.animationChanged.connect(this, this.$onAnimationChanged);\n    this.enabledChanged.connect(this, this.$onEnabledChanged);\n  }\n  $onAnimationChanged(newVal) {\n    newVal.target = this.$parent;\n    newVal.property = this.$on;\n    this.$parent.$properties[this.$on].animation = newVal;\n  }\n  $onEnabledChanged(newVal) {\n    this.$parent.$properties[this.$on].animation = newVal\n      ? this.animation\n      : null;\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"BorderImage\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    BorderImage: {\n      Stretch: \"stretch\", Repeat: \"repeat\", Round: \"round\",\n      Null: 1, Ready: 2, Loading: 3, Error: 4\n    }\n  },\n  properties: {\n    source: \"url\",\n    smooth: { type: \"bool\", initialValue: true },\n    // BorderImage.Stretch\n    horizontalTileMode: { type: \"enum\", initialValue: \"stretch\" },\n    // BorderImage.Stretch\n    verticalTileMode: { type: \"enum\", initialValue: \"stretch\" },\n    progress: \"real\",\n    status: { type: \"enum\", initialValue: 1 } // BorderImage.Null\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    const createProperty = QmlWeb.createProperty;\n    this.border = new QmlWeb.QObject(this);\n    createProperty(\"int\", this.border, \"left\");\n    createProperty(\"int\", this.border, \"right\");\n    createProperty(\"int\", this.border, \"top\");\n    createProperty(\"int\", this.border, \"bottom\");\n\n    const bg = this.impl = document.createElement(\"div\");\n    bg.style.pointerEvents = \"none\";\n    bg.style.height = \"100%\";\n    bg.style.boxSizing = \"border-box\";\n    this.dom.appendChild(bg);\n\n    this.$img = new Image();\n    this.$img.addEventListener(\"load\", () => {\n      this.progress = 1;\n      this.status = this.BorderImage.Ready;\n    });\n    this.$img.addEventListener(\"error\", () => {\n      this.status = this.BorderImage.Error;\n    });\n\n    this.sourceChanged.connect(this, this.$onSourceChanged);\n    this.border.leftChanged.connect(this, this.$updateBorder);\n    this.border.rightChanged.connect(this, this.$updateBorder);\n    this.border.topChanged.connect(this, this.$updateBorder);\n    this.border.bottomChanged.connect(this, this.$updateBorder);\n    this.horizontalTileModeChanged.connect(this, this.$updateBorder);\n    this.verticalTileModeChanged.connect(this, this.$updateBorder);\n    this.smoothChanged.connect(this, this.$onSmoothChanged);\n  }\n  $onSourceChanged(source) {\n    this.progress = 0;\n    this.status = this.BorderImage.Loading;\n    const style = this.impl.style;\n    const imageURL = QmlWeb.engine.$resolveImageURL(source);\n    style.OBorderImageSource = `url(\"${imageURL}\")`;\n    style.borderImageSource = `url(\"${imageURL}\")`;\n    this.$img.src = imageURL;\n    if (this.$img.complete) {\n      this.progress = 1;\n      this.status = this.BorderImage.Ready;\n    }\n  }\n  $updateBorder() {\n    const style = this.impl.style;\n    const { right, left, top, bottom } = this.border;\n    const slice = `${top} ${right} ${bottom} ${left} fill`;\n    const width = `${top}px ${right}px ${bottom}px ${left}px`;\n    const repeat = `${this.horizontalTileMode} ${this.verticalTileMode}`;\n    style.OBorderImageSlice = slice;\n    style.OBorderImageRepeat = repeat;\n    style.OBorderImageWidth = width;\n    style.borderImageSlice = slice;\n    style.borderImageRepeat = repeat;\n    style.borderImageWidth = width;\n  }\n  $onSmoothChanged(val) {\n    const style = this.impl.style;\n    if (val) {\n      style.imageRendering = \"auto\";\n    } else {\n      style.imageRendering = \"-webkit-optimize-contrast\";\n      style.imageRendering = \"-moz-crisp-edges\";\n      style.imageRendering = \"crisp-edges\";\n      style.imageRendering = \"pixelated\";\n    }\n  }\n});\n","// TODO\n// Currently only a skeleton implementation\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Canvas\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    available: { type: \"bool\", initialValue: true },\n    canvasSize: { type: \"var\", initialValue: [0, 0] },\n    canvasWindow: { type: \"var\", initialValue: [0, 0, 0, 0] },\n    context: { type: \"var\", initialValue: {} },\n    contextType: { type: \"string\", initialValue: \"contextType\" },\n    renderStrategy: \"enum\",\n    renderTarget: \"enum\",\n    tileSize: { type: \"var\", initialValue: [0, 0] }\n  },\n  signals: {\n    imageLoaded: [],\n    paint: [{ type: \"var\", name: \"region\" }],\n    painted: []\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n  }\n  cancelRequestAnimationFrame(/*handle*/) {\n    return false;\n  }\n  getContext(/*context_id, ...args*/) {\n    return {};\n  }\n  isImageError(/*image*/) {\n    return true;\n  }\n  isImageLoaded(/*image*/) {\n    return false;\n  }\n  isImageLoading(/*image*/) {\n    return false;\n  }\n  loadImage(image) {\n    //loadImageAsync(image);\n    if (this.isImageLoaded(image)) {\n      this.imageLoaded();\n    }\n  }\n  markDirty(area) {\n    // if dirty\n    this.paint(area);\n  }\n  requestAnimationFrame(/*callback*/) {\n    return 0;\n  }\n  requestPaint() {\n  }\n  save(/*file_name*/) {\n    return false;\n  }\n  toDataURL(/*mime_type*/) {\n    return \"\";\n  }\n  unloadImage(/*image*/) {\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Column\",\n  versions: /.*/,\n  baseClass: \"Positioner\"\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n  }\n  layoutChildren() {\n    let curPos = 0;\n    let maxWidth = 0;\n    for (let i = 0; i < this.children.length; i++) {\n      const child = this.children[i];\n      if (!child.visible || !child.width || !child.height) {\n        continue;\n      }\n      maxWidth = child.width > maxWidth ? child.width : maxWidth;\n      child.y = curPos;\n      curPos += child.height + this.spacing;\n    }\n    this.implicitWidth = maxWidth;\n    this.implicitHeight = curPos - this.spacing;\n    // We want no spacing at the bottom side\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"DoubleValidator\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    DoubleValidator: { StandardNotation: 1, ScientificNotation: 2 }\n  },\n  properties: {\n    bottom: { type: \"real\", initialValue: -Infinity },\n    top: { type: \"real\", initialValue: Infinity },\n    decimals: { type: \"int\", initialValue: 1000 },\n    // DoubleValidator.ScientificNotation\n    notation: { type: \"enum\", initialValue: 2 }\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n    this.$standardRegExp = /^(-|\\+)?\\s*[0-9]+(\\.[0-9]+)?$/;\n    this.$scientificRegExp = /^(-|\\+)?\\s*[0-9]+(\\.[0-9]+)?(E(-|\\+)?[0-9]+)?$/;\n  }\n  getRegExpForNotation(notation) {\n    switch (notation) {\n      case this.DoubleValidator.ScientificNotation:\n        return this.$scientificRegExp;\n      case this.DoubleValidator.StandardNotation:\n        return this.$standardRegExp;\n    }\n    return null;\n  }\n  $getDecimalsForNumber(number) {\n    if (Math.round(number) === number) {\n      return 0;\n    }\n    const str = `${number}`;\n    return /\\d*$/.exec(str)[0].length;\n  }\n  validate(string) {\n    const regExp = this.getRegExpForNotation(this.notation);\n    if (!regExp.test(string.trim())) {\n      return false;\n    }\n    const value = parseFloat(string);\n    return this.bottom <= value && this.top >= value &&\n           this.$getDecimalsForNumber(value) <= this.decimals;\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Flow\",\n  versions: /.*/,\n  baseClass: \"Positioner\",\n  enums: {\n    Flow: { LeftToRight: 0, TopToBottom: 1 }\n  },\n  properties: {\n    flow: \"enum\", // Flow.LeftToRight\n    layoutDirection: \"enum\" // Flow.LeftToRight\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.flowChanged.connect(this, this.layoutChildren);\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\n    this.widthChanged.connect(this, this.layoutChildren);\n    this.heightChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n  }\n\n  layoutChildren() {\n    if (this.flow === undefined) {\n      // Flow has not been fully initialized yet\n      return;\n    }\n\n    let curHPos = 0;\n    let curVPos = 0;\n    let rowSize = 0;\n    for (let i = 0; i < this.children.length; i++) {\n      const child = this.children[i];\n      if (!child.visible || !child.width || !child.height) {\n        continue;\n      }\n\n      if (this.flow === this.Flow.LeftToRight) {\n        if (!this.$isUsingImplicitWidth && curHPos + child.width > this.width) {\n          curHPos = 0;\n          curVPos += rowSize + this.spacing;\n          rowSize = 0;\n        }\n        rowSize = child.height > rowSize ? child.height : rowSize;\n        child.x = this.layoutDirection === this.Flow.TopToBottom\n                ? this.width - curHPos - child.width : curHPos;\n        child.y = curVPos;\n        curHPos += child.width + this.spacing;\n      } else { // Flow.TopToBottom\n        if (!this.$isUsingImplicitHeight\n          && curVPos + child.height > this.height)\n        {\n          curVPos = 0;\n          curHPos += rowSize + this.spacing;\n          rowSize = 0;\n        }\n        rowSize = child.width > rowSize ? child.width : rowSize;\n        child.x = this.layoutDirection === this.Flow.TopToBottom\n                ? this.width - curHPos - child.width : curHPos;\n        child.y = curVPos;\n        curVPos += child.height + this.spacing;\n      }\n    }\n\n    if (this.flow === this.Flow.LeftToRight) {\n      this.implicitWidth = curHPos - this.spacing;\n      this.implicitHeight = curVPos + rowSize;\n    } else { // Flow.TopToBottom\n      this.implicitWidth = curHPos + rowSize;\n      this.implicitHeight = curVPos - this.spacing;\n    }\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Font\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\"\n}, class extends QmlWeb.QObject {\n  constructor(parent) {\n    super(parent); // TODO: callSuper support?\n    this.Font = global.Font; // TODO: make a sane enum\n\n    const Font = this.Font;\n    const createProperty = QmlWeb.createProperty;\n\n    createProperty(\"bool\", this, \"bold\");\n    createProperty(\"enum\", this, \"capitalization\", { initialValue:\n                                                      Font.MixedCase });\n    createProperty(\"string\", this, \"family\", { initialValue: \"sans-serif\" });\n    createProperty(\"bool\", this, \"italic\");\n    createProperty(\"real\", this, \"letterSpacing\");\n    createProperty(\"int\", this, \"pixelSize\", { initialValue: 13 });\n    createProperty(\"real\", this, \"pointSize\", { initialValue: 10 });\n    createProperty(\"bool\", this, \"strikeout\");\n    createProperty(\"bool\", this, \"underline\");\n    createProperty(\"enum\", this, \"weight\", { initialValue: Font.Normal });\n    createProperty(\"real\", this, \"wordSpacing\");\n\n    this.$sizeLock = false;\n\n    this.boldChanged.connect(this, this.$onBoldChanged);\n    this.capitalizationChanged.connect(this, this.$onCapitalizationChanged);\n    this.familyChanged.connect(this, this.$onFamilyChanged);\n    this.italicChanged.connect(this, this.$onItalicChanged);\n    this.letterSpacingChanged.connect(this, this.$onLetterSpacingChanged);\n    this.pixelSizeChanged.connect(this, this.$onPixelSizeChanged);\n    this.pointSizeChanged.connect(this, this.$onPointSizeChanged);\n    this.strikeoutChanged.connect(this, this.$onStrikeoutChanged);\n    this.underlineChanged.connect(this, this.$onUnderlineChanged);\n    this.weightChanged.connect(this, this.$onWidthChanged);\n    this.wordSpacingChanged.connect(this, this.$onWordSpacingChanged);\n  }\n  $onBoldChanged(newVal) {\n    const Font = this.Font;\n    this.weight = newVal ? Font.Bold : Font.Normal;\n  }\n  $onCapitalizationChanged(newVal) {\n    const style = this.$parent.dom.firstChild.style;\n    style.fontVariant = newVal === this.Font.SmallCaps ? \"small-caps\" : \"none\";\n    style.textTransform = this.$capitalizationToTextTransform(newVal);\n  }\n  $onFamilyChanged(newVal) {\n    const style = this.$parent.dom.firstChild.style;\n    style.fontFamily = newVal;\n  }\n  $onItalicChanged(newVal) {\n    const style = this.$parent.dom.firstChild.style;\n    style.fontStyle = newVal ? \"italic\" : \"normal\";\n  }\n  $onLetterSpacingChanged(newVal) {\n    const style = this.$parent.dom.firstChild.style;\n    style.letterSpacing = newVal !== undefined ? `${newVal}px` : \"\";\n  }\n  $onPixelSizeChanged(newVal) {\n    if (!this.$sizeLock) {\n      this.pointSize = newVal * 0.75;\n    }\n    const val = `${newVal}px`;\n    this.$parent.dom.style.fontSize = val;\n    this.$parent.dom.firstChild.style.fontSize = val;\n  }\n  $onPointSizeChanged(newVal) {\n    this.$sizeLock = true;\n    this.pixelSize = Math.round(newVal / 0.75);\n    this.$sizeLock = false;\n  }\n  $onStrikeoutChanged(newVal) {\n    const style = this.$parent.dom.firstChild.style;\n    style.textDecoration = newVal\n      ? \"line-through\"\n      : this.$parent.font.underline\n        ? \"underline\"\n        : \"none\";\n  }\n  $onUnderlineChanged(newVal) {\n    const style = this.$parent.dom.firstChild.style;\n    style.textDecoration = this.$parent.font.strikeout\n      ? \"line-through\"\n      : newVal\n        ? \"underline\"\n        : \"none\";\n  }\n  $onWidthChanged(newVal) {\n    const style = this.$parent.dom.firstChild.style;\n    style.fontWeight = this.$weightToCss(newVal);\n  }\n  $onWordSpacingChanged(newVal) {\n    const style = this.$parent.dom.firstChild.style;\n    style.wordSpacing = newVal !== undefined ? `${newVal}px` : \"\";\n  }\n\n  $weightToCss(weight) {\n    const Font = this.Font;\n    switch (weight) {\n      case Font.Thin: return \"100\";\n      case Font.ExtraLight: return \"200\";\n      case Font.Light: return \"300\";\n      case Font.Normal: return \"400\";\n      case Font.Medium: return \"500\";\n      case Font.DemiBold: return \"600\";\n      case Font.Bold: return \"700\";\n      case Font.ExtraBold: return \"800\";\n      case Font.Black: return \"900\";\n    }\n    return \"normal\";\n  }\n  $capitalizationToTextTransform(capitalization) {\n    const Font = this.Font;\n    switch (capitalization) {\n      case Font.AllUppercase: return \"uppercase\";\n      case Font.AllLowercase: return \"lowercase\";\n      case Font.Capitalize: return \"capitalize\";\n    }\n    return \"none\";\n  }\n});\n","global.Font = {\n  // Capitalization\n  MixedCase: 0,\n  AllUppercase: 1,\n  AllLowercase: 2,\n  SmallCaps: 3,\n  Capitalize: 4,\n  // Weight\n  Thin: 0,\n  ExtraLight: 12,\n  Light: 25,\n  Normal: 50,\n  Medium: 57,\n  DemiBold: 63,\n  Bold: 75,\n  ExtraBold: 81,\n  Black: 87\n};\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"FontLoader\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    FontLoader: { Null: 0, Ready: 1, Loading: 2, Error: 3 }\n  },\n  properties: {\n    name: \"string\",\n    source: \"url\",\n    status: \"enum\" // FontLoader.Null\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.$domStyle = document.createElement(\"style\");\n    this.$lastName = \"\";\n    this.$inTouchName = false;\n\n    /*\n      Maximum timeout is the maximum time for a font to load. If font isn't\n      loaded in this time, the status is set to Error.\n      For both cases (with and without FontLoader.js) if the font takes more\n      than the maximum timeout to load, dimensions recalculations for elements\n      that are using this font will not be triggered or will have no effect.\n\n      FontLoader.js uses only the last timeout. The state and name properties\n      are set immediately when the font loads. If the font could not be loaded,\n      the Error status will be set only when this timeout expires. If the font\n      loading takes more than the timeout, the name property is set, but the\n      status is set to Error.\n\n      Fallback sets the font name immediately and touches it several times to\n      trigger dimensions recalcuations. The status is set to Error and should\n      not be used.\n    */\n    // 15 seconds maximum\n    this.$timeouts = [20, 50, 100, 300, 500, 1000, 3000, 5000, 10000, 15000];\n\n    this.sourceChanged.connect(this, this.$onSourceChanged);\n    this.nameChanged.connect(this, this.$onNameChanged);\n  }\n  $loadFont(fontName) {\n    /* global FontLoader */\n    if (this.$lastName === fontName || this.$inTouchName) {\n      return;\n    }\n    this.$lastName = fontName;\n\n    if (!fontName) {\n      this.status = this.FontLoader.Null;\n      return;\n    }\n    this.status = this.FontLoader.Loading;\n    if (typeof FontLoader === \"function\") {\n      const fontLoader = new FontLoader([fontName], {\n        fontsLoaded: error => {\n          if (error !== null) {\n            if (this.$lastName === fontName &&\n                error.notLoadedFontFamilies[0] === fontName) {\n              // Set the name for the case of font loading after the timeout.\n              this.name = fontName;\n              this.status = this.FontLoader.Error;\n            }\n          }\n        },\n        fontLoaded: fontFamily => {\n          if (this.$lastName === fontName && fontFamily === fontName) {\n            this.name = fontName;\n            this.status = this.FontLoader.Ready;\n          }\n        }\n      }, this.$timeouts[this.$timeouts.length - 1]);\n      // Else I get problems loading multiple fonts (FontLoader.js bug?)\n      FontLoader.testDiv = null;\n      fontLoader.loadFonts();\n    } else {\n      console.warn(`FontLoader.js library is not loaded.\nYou should load FontLoader.js if you want to use QtQuick FontLoader elements.\nRefs: https://github.com/smnh/FontLoader.`);\n      // You should not rely on 'status' property without FontLoader.js.\n      this.status = this.FontLoader.Error;\n      this.name = fontName;\n      this.$cycleTouchName(fontName, 0);\n    }\n  }\n  $cycleTouchName(fontName, i) {\n    if (this.$lastName !== fontName) {\n      return;\n    }\n    if (i > 0) {\n      const name = this.name;\n      this.$inTouchName = true;\n      // Calling this.nameChanged() is not enough, we have to actually change\n      // the value to flush the bindings.\n      this.name = \"sans-serif\";\n      this.name = name;\n      this.$inTouchName = false;\n    }\n    if (i < this.$timeouts.length) {\n      setTimeout(() => {\n        this.$cycleTouchName(fontName, i + 1);\n      }, this.$timeouts[i] - (i > 0 ? this.$timeouts[i - 1] : 0));\n    }\n  }\n  $onSourceChanged(font_src) {\n    const rand = Math.round(Math.random() * 1e15);\n    const fontName = `font_${Date.now().toString(36)}_${rand.toString(36)}`;\n    this.$domStyle.innerHTML = `@font-face {\n      font-family: ${fontName};\n      src: url('${font_src}');\n    }`;\n    document.getElementsByTagName(\"head\")[0].appendChild(this.$domStyle);\n    this.$loadFont(fontName);\n  }\n  $onNameChanged(fontName) {\n    this.$loadFont(fontName);\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Grid\",\n  versions: /.*/,\n  baseClass: \"Positioner\",\n  enums: {\n    Grid: { LeftToRight: 0, TopToBottom: 1 }\n  },\n  properties: {\n    columns: \"int\",\n    rows: \"int\",\n    flow: \"enum\",\n    layoutDirection: \"enum\"\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.columnsChanged.connect(this, this.layoutChildren);\n    this.rowsChanged.connect(this, this.layoutChildren);\n    this.flowChanged.connect(this, this.layoutChildren);\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n  }\n  layoutChildren() {\n    // How many items are actually visible?\n    const visibleItems = this.$getVisibleItems();\n\n    // How many rows and columns do we need?\n    const [c, r] = this.$calculateSize(visibleItems.length);\n\n    // How big are the colums/rows?\n    const [colWidth, rowHeight] = this.$calculateGrid(visibleItems, c, r);\n\n    // Do actual positioning\n    // When layoutDirection is RightToLeft we need oposite order of coumns\n    const step = this.layoutDirection === 1 ? -1 : 1;\n    const startingPoint = this.layoutDirection === 1 ? c - 1 : 0;\n    const endPoint = this.layoutDirection === 1 ? -1 : c;\n    let curHPos = 0;\n    let curVPos = 0;\n    if (this.flow === 0) {\n      for (let i = 0; i < r; i++) {\n        for (let j = startingPoint; j !== endPoint; j += step) {\n          const item = visibleItems[i * c + j];\n          if (!item) {\n            break;\n          }\n          item.x = curHPos;\n          item.y = curVPos;\n\n          curHPos += colWidth[j] + this.spacing;\n        }\n        curVPos += rowHeight[i] + this.spacing;\n        curHPos = 0;\n      }\n    } else {\n      for (let i = startingPoint; i !== endPoint; i += step) {\n        for (let j = 0; j < r; j++) {\n          const item = visibleItems[i * r + j];\n          if (!item) {\n            break;\n          }\n          item.x = curHPos;\n          item.y = curVPos;\n\n          curVPos += rowHeight[j] + this.spacing;\n        }\n        curHPos += colWidth[i] + this.spacing;\n        curVPos = 0;\n      }\n    }\n\n    // Set implicit size\n    let gridWidth = -this.spacing;\n    let gridHeight = -this.spacing;\n    for (const i in colWidth) {\n      gridWidth += colWidth[i] + this.spacing;\n    }\n    for (const i in rowHeight) {\n      gridHeight += rowHeight[i] + this.spacing;\n    }\n    this.implicitWidth = gridWidth;\n    this.implicitHeight = gridHeight;\n  }\n  $getVisibleItems() {\n    return this.children.filter(child =>\n      child.visible && child.width && child.height\n    );\n  }\n  $calculateSize(length) {\n    let cols;\n    let rows;\n    if (!this.columns && !this.rows) {\n      cols = 4;\n      rows = Math.ceil(length / cols);\n    } else if (!this.columns) {\n      rows = this.rows;\n      cols = Math.ceil(length / rows);\n    } else {\n      cols = this.columns;\n      rows = Math.ceil(length / cols);\n    }\n    return [cols, rows];\n  }\n  $calculateGrid(visibleItems, cols, rows) {\n    const colWidth = [];\n    const rowHeight = [];\n\n    if (this.flow === 0) {\n      for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n          const item = visibleItems[i * cols + j];\n          if (!item) {\n            break;\n          }\n          if (!colWidth[j] || item.width > colWidth[j]) {\n            colWidth[j] = item.width;\n          }\n          if (!rowHeight[i] || item.height > rowHeight[i]) {\n            rowHeight[i] = item.height;\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i < cols; i++) {\n        for (let j = 0; j < rows; j++) {\n          const item = visibleItems[i * rows + j];\n          if (!item) {\n            break;\n          }\n          if (!rowHeight[j] || item.height > rowHeight[j]) {\n            rowHeight[j] = item.height;\n          }\n          if (!colWidth[i] || item.width > colWidth[i]) {\n            colWidth[i] = item.width;\n          }\n        }\n      }\n    }\n\n    return [colWidth, rowHeight];\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Image\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    Image: {\n      Stretch: 1, PreserveAspectFit: 2, PreserveAspectCrop: 3,\n      Tile: 4, TileVertically: 5, TileHorizontally: 6,\n\n      Null: 1, Ready: 2, Loading: 3, Error: 4\n    }\n  },\n  properties: {\n    asynchronous: { type: \"bool\", initialValue: true },\n    cache: { type: \"bool\", initialValue: true },\n    smooth: { type: \"bool\", initialValue: true },\n    fillMode: { type: \"enum\", initialValue: 1 }, // Image.Stretch\n    mirror: \"bool\",\n    progress: \"real\",\n    source: \"url\",\n    status: { type: \"enum\", initialValue: 1 } // Image.Null\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    const createProperty = QmlWeb.createProperty;\n\n    this.sourceSize = new QmlWeb.QObject(this);\n    createProperty(\"int\", this.sourceSize, \"width\");\n    createProperty(\"int\", this.sourceSize, \"height\");\n\n    const bg = this.impl = document.createElement(\"div\");\n    bg.style.pointerEvents = \"none\";\n    bg.style.height = \"100%\";\n    this.dom.appendChild(bg);\n\n    this.$img = new Image();\n    this.$img.addEventListener(\"load\", () => {\n      const w = this.$img.naturalWidth;\n      const h = this.$img.naturalHeight;\n      this.sourceSize.width = w;\n      this.sourceSize.height = h;\n      this.implicitWidth = w;\n      this.implicitHeight = h;\n      this.progress = 1;\n      this.status = this.Image.Ready;\n    });\n    this.$img.addEventListener(\"error\", () => {\n      this.status = this.Image.Error;\n    });\n\n    this.sourceChanged.connect(this, this.$onSourceChanged);\n    this.mirrorChanged.connect(this, this.$onMirrorChanged);\n    this.fillModeChanged.connect(this, this.$onFillModeChanged);\n    this.smoothChanged.connect(this, this.$onSmoothChanged);\n  }\n  $updateFillMode(val = this.fillMode) {\n    const style = this.impl.style;\n    switch (val) {\n      default:\n      case this.Image.Stretch:\n        style.backgroundRepeat = \"auto\";\n        style.backgroundSize = \"100% 100%\";\n        style.backgroundPosition = \"auto\";\n        break;\n      case this.Image.Tile:\n        style.backgroundRepeat = \"auto\";\n        style.backgroundSize = \"auto\";\n        style.backgroundPosition = \"center\";\n        break;\n      case this.Image.PreserveAspectFit:\n        style.backgroundRepeat = \"no-repeat\";\n        style.backgroundSize = \"contain\";\n        style.backgroundPosition = \"center\";\n        break;\n      case this.Image.PreserveAspectCrop:\n        style.backgroundRepeat = \"no-repeat\";\n        style.backgroundSize = \"cover\";\n        style.backgroundPosition = \"center\";\n        break;\n      case this.Image.TileVertically:\n        style.backgroundRepeat = \"repeat-y\";\n        style.backgroundSize = \"100% auto\";\n        style.backgroundPosition = \"auto\";\n        break;\n      case this.Image.TileHorizontally:\n        style.backgroundRepeat = \"repeat-x\";\n        style.backgroundSize = \"auto 100%\";\n        style.backgroundPosition = \"auto\";\n        break;\n    }\n  }\n  $onSourceChanged(source) {\n    this.progress = 0;\n    this.status = this.Image.Loading;\n    const imageURL = QmlWeb.engine.$resolveImageURL(source);\n    this.impl.style.backgroundImage = `url(\"${imageURL}\")`;\n    this.$img.src = imageURL;\n    if (this.$img.complete) {\n      this.progress = 1;\n      this.status = this.Image.Ready;\n    }\n    this.$updateFillMode();\n  }\n  $onMirrorChanged(val) {\n    const transformRule = \"scale(-1,1)\";\n    if (!val) {\n      const index = this.transform.indexOf(transformRule);\n      if (index >= 0) {\n        this.transform.splice(index, 1);\n      }\n    } else {\n      this.transform.push(transformRule);\n    }\n    this.$updateTransform();\n  }\n  $onFillModeChanged(val) {\n    this.$updateFillMode(val);\n  }\n  $onSmoothChanged(val) {\n    const style = this.impl.style;\n    if (val) {\n      style.imageRendering = \"auto\";\n    } else {\n      style.imageRendering = \"-webkit-optimize-contrast\";\n      style.imageRendering = \"-moz-crisp-edges\";\n      style.imageRendering = \"crisp-edges\";\n      style.imageRendering = \"pixelated\";\n    }\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"IntValidator\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    bottom: { type: \"int\", initialValue: -2147483647 },\n    top: { type: \"int\", initialValue: 2147483647 }\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n  }\n  validate(string) {\n    const regExp = /^(-|\\+)?\\s*[0-9]+$/;\n    let acceptable = regExp.test(string.trim());\n\n    if (acceptable) {\n      const value = parseInt(string, 10);\n      acceptable = this.bottom <= value && this.top >= value;\n    }\n    return acceptable;\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Item\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    $opacity: { type: \"real\", initialValue: 1 },\n    parent: \"Item\",\n    state: \"string\",\n    states: \"list\",\n    transitions: \"list\",\n    data: \"list\",\n    children: \"list\",\n    resources: \"list\",\n    transform: \"list\",\n    x: \"real\",\n    y: \"real\",\n    z: \"real\",\n    width: \"real\",\n    height: \"real\",\n    implicitWidth: \"real\",\n    implicitHeight: \"real\",\n    left: \"real\",\n    right: \"real\",\n    top: \"real\",\n    bottom: \"real\",\n    horizontalCenter: \"real\",\n    verticalCenter: \"real\",\n    rotation: \"real\",\n    scale: { type: \"real\", initialValue: 1 },\n    opacity: { type: \"real\", initialValue: 1 },\n    visible: { type: \"bool\", initialValue: true },\n    clip: \"bool\",\n    focus: \"bool\"\n  },\n  defaultProperty: \"data\"\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    if (this.$parent === null) { // This is the root element. Initialize it.\n      this.dom = QmlWeb.engine.rootElement || document.body;\n      this.dom.innerHTML = \"\";\n      // Needed to make absolute positioning work\n      this.dom.style.position = \"relative\";\n      this.dom.style.top = \"0\";\n      this.dom.style.left = \"0\";\n      // No QML stuff should stand out the root element\n      this.dom.style.overflow = \"hidden\";\n    } else {\n      if (!this.dom) { // Create a dom element for this item.\n        this.dom = document.createElement(\"div\");\n      }\n      this.dom.style.position = \"absolute\";\n    }\n    this.dom.style.pointerEvents = \"none\";\n    // In case the class is qualified, only use the last part for the css class\n    // name.\n    const classComponent = meta.object.$class.split(\".\").pop();\n    this.dom.className = `${classComponent}${this.id ? ` ${this.id}` : \"\"}`;\n    this.css = this.dom.style;\n    this.impl = null; // Store the actually drawn element\n\n    this.css.boxSizing = \"border-box\";\n\n    const createProperty = QmlWeb.createProperty;\n\n    if (this.$isComponentRoot) {\n      createProperty(\"var\", this, \"activeFocus\");\n    }\n\n    this.parentChanged.connect(this, this.$onParentChanged_);\n    this.dataChanged.connect(this, this.$onDataChanged);\n    this.stateChanged.connect(this, this.$onStateChanged);\n    this.visibleChanged.connect(this, this.$onVisibleChanged_);\n    this.clipChanged.connect(this, this.$onClipChanged);\n    this.zChanged.connect(this, this.$onZChanged);\n    this.xChanged.connect(this, this.$onXChanged);\n    this.yChanged.connect(this, this.$onYChanged);\n    this.widthChanged.connect(this, this.$onWidthChanged_);\n    this.heightChanged.connect(this, this.$onHeightChanged_);\n    this.focusChanged.connect(this, this.$onFocusChanged_);\n\n    this.widthChanged.connect(this, this.$updateHGeometry);\n    this.heightChanged.connect(this, this.$updateVGeometry);\n    this.implicitWidthChanged.connect(this, this.$onImplicitWidthChanged);\n    this.implicitHeightChanged.connect(this, this.$onImplicitHeightChanged);\n\n    this.$isUsingImplicitWidth = true;\n    this.$isUsingImplicitHeight = true;\n\n    this.anchors = new QmlWeb.QObject(this);\n    createProperty(\"var\", this.anchors, \"left\");\n    createProperty(\"var\", this.anchors, \"right\");\n    createProperty(\"var\", this.anchors, \"top\");\n    createProperty(\"var\", this.anchors, \"bottom\");\n    createProperty(\"var\", this.anchors, \"horizontalCenter\");\n    createProperty(\"var\", this.anchors, \"verticalCenter\");\n    createProperty(\"Item\", this.anchors, \"fill\");\n    createProperty(\"Item\", this.anchors, \"centerIn\");\n    createProperty(\"real\", this.anchors, \"margins\");\n    createProperty(\"real\", this.anchors, \"leftMargin\");\n    createProperty(\"real\", this.anchors, \"rightMargin\");\n    createProperty(\"real\", this.anchors, \"topMargin\");\n    createProperty(\"real\", this.anchors, \"bottomMargin\");\n    this.anchors.leftChanged.connect(this, this.$updateHGeometry);\n    this.anchors.rightChanged.connect(this, this.$updateHGeometry);\n    this.anchors.topChanged.connect(this, this.$updateVGeometry);\n    this.anchors.bottomChanged.connect(this, this.$updateVGeometry);\n    this.anchors.horizontalCenterChanged.connect(this, this.$updateHGeometry);\n    this.anchors.verticalCenterChanged.connect(this, this.$updateVGeometry);\n    this.anchors.fillChanged.connect(this, this.$updateHGeometry);\n    this.anchors.fillChanged.connect(this, this.$updateVGeometry);\n    this.anchors.centerInChanged.connect(this, this.$updateHGeometry);\n    this.anchors.centerInChanged.connect(this, this.$updateVGeometry);\n    this.anchors.leftMarginChanged.connect(this, this.$updateHGeometry);\n    this.anchors.rightMarginChanged.connect(this, this.$updateHGeometry);\n    this.anchors.topMarginChanged.connect(this, this.$updateVGeometry);\n    this.anchors.bottomMarginChanged.connect(this, this.$updateVGeometry);\n    this.anchors.marginsChanged.connect(this, this.$updateHGeometry);\n    this.anchors.marginsChanged.connect(this, this.$updateVGeometry);\n\n    // childrenRect property\n    this.childrenRect = new QmlWeb.QObject(this);\n    createProperty(\"real\", this.childrenRect, \"x\"); // TODO ro\n    createProperty(\"real\", this.childrenRect, \"y\"); // TODO ro\n    createProperty(\"real\", this.childrenRect, \"width\"); // TODO ro\n    createProperty(\"real\", this.childrenRect, \"height\"); // TODO ro\n\n    this.rotationChanged.connect(this, this.$updateTransform);\n    this.scaleChanged.connect(this, this.$updateTransform);\n    this.transformChanged.connect(this, this.$updateTransform);\n\n    this.Component.completed.connect(this, this.Component$onCompleted_);\n    this.opacityChanged.connect(this, this.$calculateOpacity);\n    if (this.$parent) {\n      this.$parent.$opacityChanged.connect(this, this.$calculateOpacity);\n    }\n\n    this.spacing = 0;\n    this.$revertActions = [];\n    this.css.left = `${this.x}px`;\n    this.css.top = `${this.y}px`;\n\n    // Init size of root element\n    if (this.$parent === null) {\n      if (!QmlWeb.engine.rootElement) {\n        // Case 1: Qml scene is placed in body tag\n\n        // event handling by addEventListener is probably better than setting\n        // window.onresize\n        const updateQmlGeometry = () => {\n          this.implicitHeight = window.innerHeight;\n          this.implicitWidth = window.innerWidth;\n        };\n        window.addEventListener(\"resize\", updateQmlGeometry);\n        updateQmlGeometry();\n      } else {\n        // Case 2: Qml scene is placed in some element tag\n\n        // we have to call `this.implicitHeight =` and `this.implicitWidth =`\n        // each time the rootElement changes it's geometry\n        // to reposition child elements of qml scene\n\n        // it is good to have this as named method of dom element, so we can\n        // call it from outside too, whenever element changes it's geometry\n        // (not only on window resize)\n        this.dom.updateQmlGeometry = () => {\n          this.implicitHeight = this.dom.offsetHeight;\n          this.implicitWidth = this.dom.offsetWidth;\n        };\n        window.addEventListener(\"resize\", this.dom.updateQmlGeometry);\n        this.dom.updateQmlGeometry();\n      }\n    }\n  }\n  $onParentChanged_(newParent, oldParent, propName) {\n    if (oldParent) {\n      oldParent.children.splice(oldParent.children.indexOf(this), 1);\n      oldParent.childrenChanged();\n      oldParent.dom.removeChild(this.dom);\n    }\n    if (newParent && newParent.children.indexOf(this) === -1) {\n      newParent.children.push(this);\n      newParent.childrenChanged();\n    }\n    if (newParent) {\n      newParent.dom.appendChild(this.dom);\n    }\n    this.$updateHGeometry(newParent, oldParent, propName);\n    this.$updateVGeometry(newParent, oldParent, propName);\n  }\n  $onDataChanged(newData) {\n    const QMLItem = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Item\");\n    for (const i in newData) {\n      const child = newData[i];\n      if (child instanceof QMLItem) {\n        child.parent = this; // This will also add it to children.\n      } else {\n        this.resources.push(child);\n      }\n    }\n  }\n  $onStateChanged(newVal, oldVal) {\n    // let oldState; // TODO: do we need oldState?\n    let newState;\n    for (let i = 0; i < this.states.length; i++) {\n      if (this.states[i].name === newVal) {\n        newState = this.states[i];\n      }\n      /*\n      else if (this.states[i].name === oldVal) {\n        oldState = this.states[i];\n      }\n      */\n    }\n\n    const actions = this.$revertActions.slice();\n\n    // Get current values for revert actions\n    for (const i in actions) {\n      const action = actions[i];\n      action.from = action.target[action.property];\n    }\n    if (newState) {\n      const changes = newState.$getAllChanges();\n\n      // Get all actions we need to do and create actions to revert them\n      for (let i = 0; i < changes.length; i++) {\n        this.$applyChange(actions, changes[i]);\n      }\n    }\n\n    // Set all property changes and fetch the actual values afterwards\n    // The latter is needed for transitions. We need to set all properties\n    // before we fetch the values because properties can be interdependent.\n    for (const i in actions) {\n      const action = actions[i];\n      action.target.$properties[action.property].set(\n        action.value, QmlWeb.QMLProperty.ReasonUser, action.target,\n        newState ? newState.$context : action.target.$context\n      );\n    }\n    for (const i in actions) {\n      const action = actions[i];\n      action.to = action.target[action.property];\n      if (action.explicit) {\n        // Remove binding\n        action.target[action.property] = action.target[action.property];\n        action.value = action.target[action.property];\n      }\n    }\n\n    // Find the best transition to use\n    let transition;\n    let rating = 0;\n    for (let i = 0; i < this.transitions.length; i++) {\n      // We need to stop running transitions, so let's do\n      // it while iterating through the transitions anyway\n      this.transitions[i].$stop();\n      const curTransition = this.transitions[i];\n      let curRating = 0;\n      if (curTransition.from === oldVal ||\n          curTransition.reversible && curTransition.from === newVal) {\n        curRating += 2;\n      } else if (curTransition.from === \"*\") {\n        curRating++;\n      } else {\n        continue;\n      }\n      if (curTransition.to === newVal ||\n        curTransition.reversible && curTransition.to === oldVal) {\n        curRating += 2;\n      } else if (curTransition.to === \"*\") {\n        curRating++;\n      } else {\n        continue;\n      }\n      if (curRating > rating) {\n        rating = curRating;\n        transition = curTransition;\n      }\n    }\n    if (transition) {\n      transition.$start(actions);\n    }\n  }\n  $applyChange(actions, change) {\n    const arrayFindIndex = QmlWeb.helpers.arrayFindIndex;\n    for (let j = 0; j < change.$actions.length; j++) {\n      const item = change.$actions[j];\n\n      const action = {\n        target: change.target,\n        property: item.property,\n        origValue: change.target.$properties[item.property].binding ||\n                    change.target.$properties[item.property].val,\n        value: item.value,\n        from: change.target[item.property],\n        to: undefined,\n        explicit: change.explicit\n      };\n\n      const actionIndex = arrayFindIndex(actions, element =>\n        element.target === action.target &&\n        element.property === action.property\n      );\n      if (actionIndex !== -1) {\n        actions[actionIndex] = action;\n      } else {\n        actions.push(action);\n      }\n\n      // Look for existing revert action, else create it\n      const revertIndex = arrayFindIndex(this.$revertActions, element =>\n        element.target === change.target &&\n        element.property === item.property\n      );\n      if (revertIndex !== -1 && !change.restoreEntryValues) {\n        // We don't want to revert, so remove it\n        this.$revertActions.splice(revertIndex, 1);\n      } else if (revertIndex === -1 && change.restoreEntryValues) {\n        this.$revertActions.push({\n          target: change.target,\n          property: item.property,\n          value: change.target.$properties[item.property].binding ||\n                  change.target.$properties[item.property].val,\n          from: undefined,\n          to: change.target[item.property]\n        });\n      }\n    }\n  }\n  $onVisibleChanged_(newVal) {\n    this.css.visibility = newVal ? \"inherit\" : \"hidden\";\n  }\n  $onClipChanged(newVal) {\n    this.css.overflow = newVal ? \"hidden\" : \"visible\";\n  }\n  $onZChanged() {\n    this.$updateTransform();\n  }\n  $onXChanged(newVal) {\n    this.css.left = `${newVal}px`;\n    this.$updateHGeometry();\n  }\n  $onYChanged(newVal) {\n    this.css.top = `${newVal}px`;\n    this.$updateVGeometry();\n  }\n  $onWidthChanged_(newVal) {\n    this.css.width = newVal ? `${newVal}px` : \"auto\";\n  }\n  $onHeightChanged_(newVal) {\n    this.css.height = newVal ? `${newVal}px` : \"auto\";\n  }\n  $onFocusChanged(newVal) {\n    if (newVal) {\n      if (this.dom.firstChild) {\n        this.dom.firstChild.focus();\n      }\n      document.qmlFocus = this;\n      this.$context.activeFocus = this;\n    } else if (document.qmlFocus === this) {\n      document.getElementsByTagName(\"BODY\")[0].focus();\n      document.qmlFocus = QmlWeb.engine.rootContext().base;\n      this.$context.activeFocus = null;\n    }\n  }\n  setupFocusOnDom(element) {\n    const updateFocus = () => {\n      const hasFocus = document.activeElement === this.dom ||\n                       document.activeElement === this.dom.firstChild;\n      if (this.focus !== hasFocus) {\n        this.focus = hasFocus;\n      }\n    };\n    element.addEventListener(\"focus\", updateFocus);\n    element.addEventListener(\"blur\", updateFocus);\n  }\n  $updateTransform() {\n    const QMLTranslate = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Translate\");\n    const QMLRotation = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Rotation\");\n    const QMLScale = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Scale\");\n    let transform = `rotate(${this.rotation}deg) scale(${this.scale})`;\n    let filter = \"\";\n    const transformStyle = \"preserve-3d\";\n\n    for (let i = 0; i < this.transform.length; i++) {\n      const t = this.transform[i];\n      if (t instanceof QMLRotation) {\n        const ax = t.axis;\n        transform += ` rotate3d(${ax.x}, ${ax.y}, ${ax.z}, ${ax.angle}deg)`;\n      } else if (t instanceof QMLScale) {\n        transform += ` scale(${t.xScale}, ${t.yScale})`;\n      } else if (t instanceof QMLTranslate) {\n        transform += ` translate(${t.x}px, ${t.y}px)`;\n      } else if (typeof t.transformType !== \"undefined\") {\n        if (t.transformType === \"filter\") {\n          filter += `${t.operation}(${t.parameters}) `;\n        }\n      } else if (typeof t === \"string\") {\n        transform += t;\n      }\n    }\n    if (typeof this.z === \"number\") {\n      transform += ` translate3d(0, 0, ${this.z}px)`;\n    }\n    this.dom.style.transform = transform;\n    this.dom.style.transformStyle = transformStyle;\n    this.dom.style.webkitTransform = transform; // Chrome, Safari and Opera\n    this.dom.style.webkitTransformStyle = transformStyle;\n    this.dom.style.msTransform = transform;     // IE\n    this.dom.style.filter = filter;\n    this.dom.style.webkitFilter = filter; // Chrome, Safari and Opera\n  }\n  Component$onCompleted_() {\n    this.$calculateOpacity();\n  }\n  $calculateOpacity() {\n    // TODO: reset all opacity on layer.enabled changed\n    /*\n    if (false) { // TODO: check layer.enabled\n      this.css.opacity = this.opacity;\n    }\n    */\n    const parentOpacity = this.$parent && this.$parent.$opacity || 1;\n    this.$opacity = this.opacity * parentOpacity;\n    if (this.impl) {\n      this.impl.style.opacity = this.$opacity;\n    }\n  }\n  $onImplicitWidthChanged() {\n    if (this.$isUsingImplicitWidth) {\n      this.width = this.implicitWidth;\n      this.$isUsingImplicitWidth = true;\n    }\n  }\n  $onImplicitHeightChanged() {\n    if (this.$isUsingImplicitHeight) {\n      this.height = this.implicitHeight;\n      this.$isUsingImplicitHeight = true;\n    }\n  }\n  $updateHGeometry(newVal, oldVal, propName) {\n    const anchors = this.anchors || this;\n    if (this.$updatingHGeometry) {\n      return;\n    }\n    this.$updatingHGeometry = true;\n\n    const flags = QmlWeb.Signal.UniqueConnection;\n    const lM = anchors.leftMargin || anchors.margins;\n    const rM = anchors.rightMargin || anchors.margins;\n    const w = this.width;\n    const left = this.parent ? this.parent.left : 0;\n\n    // Width\n    if (propName === \"width\") {\n      this.$isUsingImplicitWidth = false;\n    }\n\n    // Position TODO: Layouts\n\n    const u = {}; // our update object\n\n    if (anchors.fill !== undefined) {\n      const fill = anchors.fill;\n      const props = fill.$properties;\n      props.left.changed.connect(this, this.$updateHGeometry, flags);\n      props.right.changed.connect(this, this.$updateHGeometry, flags);\n      props.width.changed.connect(this, this.$updateHGeometry, flags);\n\n      this.$isUsingImplicitWidth = false;\n      u.width = fill.width - lM - rM;\n      u.x = fill.left - left + lM;\n      u.left = fill.left + lM;\n      u.right = fill.right - rM;\n      u.horizontalCenter = (u.left + u.right) / 2;\n    } else if (anchors.centerIn !== undefined) {\n      const horizontalCenter = anchors.centerIn.$properties.horizontalCenter;\n      horizontalCenter.changed.connect(this, this.$updateHGeometry, flags);\n\n      u.horizontalCenter = anchors.centerIn.horizontalCenter;\n      u.x = u.horizontalCenter - w / 2 - left;\n      u.left = u.horizontalCenter - w / 2;\n      u.right = u.horizontalCenter + w / 2;\n    } else if (anchors.left !== undefined) {\n      u.left = anchors.left + lM;\n      if (anchors.right !== undefined) {\n        u.right = anchors.right - rM;\n        this.$isUsingImplicitWidth = false;\n        u.width = u.right - u.left;\n        u.x = u.left - left;\n        u.horizontalCenter = (u.right + u.left) / 2;\n      } else if (anchors.horizontalCenter !== undefined) {\n        u.horizontalCenter = anchors.horizontalCenter;\n        this.$isUsingImplicitWidth = false;\n        u.width = (u.horizontalCenter - u.left) * 2;\n        u.x = u.left - left;\n        u.right = 2 * u.horizontalCenter - u.left;\n      } else {\n        u.x = u.left - left;\n        u.right = u.left + w;\n        u.horizontalCenter = u.left + w / 2;\n      }\n    } else if (anchors.right !== undefined) {\n      u.right = anchors.right - rM;\n      if (anchors.horizontalCenter !== undefined) {\n        u.horizontalCenter = anchors.horizontalCenter;\n        this.$isUsingImplicitWidth = false;\n        u.width = (u.right - u.horizontalCenter) * 2;\n        u.x = 2 * u.horizontalCenter - u.right - left;\n        u.left = 2 * u.horizontalCenter - u.right;\n      } else {\n        u.x = u.right - w - left;\n        u.left = u.right - w;\n        u.horizontalCenter = u.right - w / 2;\n      }\n    } else if (anchors.horizontalCenter !== undefined) {\n      u.horizontalCenter = anchors.horizontalCenter;\n      u.x = u.horizontalCenter - w / 2 - left;\n      u.left = u.horizontalCenter - w / 2;\n      u.right = u.horizontalCenter + w / 2;\n    } else {\n      if (this.parent) {\n        const leftProp = this.parent.$properties.left;\n        leftProp.changed.connect(this, this.$updateHGeometry, flags);\n      }\n\n      u.left = this.x + left;\n      u.right = u.left + w;\n      u.horizontalCenter = u.left + w / 2;\n    }\n\n    for (const key in u) {\n      this[key] = u[key];\n    }\n\n    this.$updatingHGeometry = false;\n\n    if (this.parent) this.$updateChildrenRect(this.parent);\n  }\n  $updateVGeometry(newVal, oldVal, propName) {\n    const anchors = this.anchors || this;\n    if (this.$updatingVGeometry) {\n      return;\n    }\n    this.$updatingVGeometry = true;\n\n    const flags = QmlWeb.Signal.UniqueConnection;\n    const tM = anchors.topMargin || anchors.margins;\n    const bM = anchors.bottomMargin || anchors.margins;\n    const h = this.height;\n    const top = this.parent ? this.parent.top : 0;\n\n    // HeighttopProp\n    if (propName === \"height\") {\n      this.$isUsingImplicitHeight = false;\n    }\n\n    // Position TODO: Layouts\n\n    const u = {}; // our update object\n\n    if (anchors.fill !== undefined) {\n      const fill = anchors.fill;\n      const props = fill.$properties;\n      props.top.changed.connect(this, this.$updateVGeometry, flags);\n      props.bottom.changed.connect(this, this.$updateVGeometry, flags);\n      props.height.changed.connect(this, this.$updateVGeometry, flags);\n\n      this.$isUsingImplicitHeight = false;\n      u.height = fill.height - tM - bM;\n      u.y = fill.top - top + tM;\n      u.top = fill.top + tM;\n      u.bottom = fill.bottom - bM;\n      u.verticalCenter = (u.top + u.bottom) / 2;\n    } else if (anchors.centerIn !== undefined) {\n      const verticalCenter = anchors.centerIn.$properties.verticalCenter;\n      verticalCenter.changed.connect(this, this.$updateVGeometry, flags);\n\n      u.verticalCenter = anchors.centerIn.verticalCenter;\n      u.y = u.verticalCenter - h / 2 - top;\n      u.top = u.verticalCenter - h / 2;\n      u.bottom = u.verticalCenter + h / 2;\n    } else if (anchors.top !== undefined) {\n      u.top = anchors.top + tM;\n      if (anchors.bottom !== undefined) {\n        u.bottom = anchors.bottom - bM;\n        this.$isUsingImplicitHeight = false;\n        u.height = u.bottom - u.top;\n        u.y = u.top - top;\n        u.verticalCenter = (u.bottom + u.top) / 2;\n      } else if ((u.verticalCenter = anchors.verticalCenter) !== undefined) {\n        this.$isUsingImplicitHeight = false;\n        u.height = (u.verticalCenter - u.top) * 2;\n        u.y = u.top - top;\n        u.bottom = 2 * u.verticalCenter - u.top;\n      } else {\n        u.y = u.top - top;\n        u.bottom = u.top + h;\n        u.verticalCenter = u.top + h / 2;\n      }\n    } else if (anchors.bottom !== undefined) {\n      u.bottom = anchors.bottom - bM;\n      if ((u.verticalCenter = anchors.verticalCenter) !== undefined) {\n        this.$isUsingImplicitHeight = false;\n        u.height = (u.bottom - u.verticalCenter) * 2;\n        u.y = 2 * u.verticalCenter - u.bottom - top;\n        u.top = 2 * u.verticalCenter - u.bottom;\n      } else {\n        u.y = u.bottom - h - top;\n        u.top = u.bottom - h;\n        u.verticalCenter = u.bottom - h / 2;\n      }\n    } else if (anchors.verticalCenter !== undefined) {\n      u.verticalCenter = anchors.verticalCenter;\n      u.y = u.verticalCenter - h / 2 - top;\n      u.top = u.verticalCenter - h / 2;\n      u.bottom = u.verticalCenter + h / 2;\n    } else {\n      if (this.parent) {\n        const topProp = this.parent.$properties.top;\n        topProp.changed.connect(this, this.$updateVGeometry, flags);\n      }\n\n      u.top = this.y + top;\n      u.bottom = u.top + h;\n      u.verticalCenter = u.top + h / 2;\n    }\n\n    for (const key in u) {\n      this[key] = u[key];\n    }\n\n    this.$updatingVGeometry = false;\n\n    if (this.parent) this.$updateChildrenRect(this.parent);\n  }\n  $updateChildrenRect(component) {\n    if (!component || !component.children || component.children.length === 0) {\n      return;\n    }\n    const children = component.children;\n\n    let maxWidth = 0;\n    let maxHeight = 0;\n    let minX = children.length > 0 ? children[0].x : 0;\n    let minY = children.length > 0 ? children[0].y : 0;\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      maxWidth = Math.max(maxWidth, child.x + child.width);\n      maxHeight = Math.max(maxHeight, child.y + child.heighth);\n      minX = Math.min(minX, child.x);\n      minY = Math.min(minX, child.y);\n    }\n\n    component.childrenRect.x = minX;\n    component.childrenRect.y = minY;\n    component.childrenRect.width = maxWidth;\n    component.childrenRect.height = maxHeight;\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"ListElement\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\"\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    const createProperty = QmlWeb.createProperty;\n    for (const i in meta.object) {\n      if (i[0] !== \"$\") {\n        createProperty(\"variant\", this, i);\n      }\n    }\n    QmlWeb.applyProperties(meta.object, this, this, this.$context);\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"ListModel\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    count: \"int\",\n    $items: \"list\"\n  },\n  defaultProperty: \"$items\"\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.$firstItem = true;\n    this.$itemsChanged.connect(this, this.$on$itemsChanged);\n    this.$model = new QmlWeb.JSItemModel();\n    this.$model.data = (index, role) => this.$items[index][role];\n    this.$model.rowCount = () => this.$items.length;\n  }\n  $on$itemsChanged(newVal) {\n    this.count = this.$items.length;\n    if (this.$firstItem && newVal.length > 0) {\n      const QMLListElement = QmlWeb.getConstructor(\n        \"QtQuick\", \"2.0\", \"ListElement\"\n      );\n      this.$firstItem = false;\n      const roleNames = [];\n      let dict = newVal[0];\n      if (dict instanceof QMLListElement) {\n        dict = dict.$properties;\n      }\n      for (const i in dict) {\n        if (i !== \"index\") {\n          roleNames.push(i);\n        }\n      }\n      this.$model.setRoleNames(roleNames);\n    }\n  }\n  append(dict) {\n    const index = this.$items.length;\n    let c = 0;\n\n    if (dict instanceof Array) {\n      for (const key in dict) {\n        this.$items.push(dict[key]);\n        c++;\n      }\n    } else {\n      this.$items.push(dict);\n      c = 1;\n    }\n\n    this.$itemsChanged(this.$items);\n    this.$model.rowsInserted(index, index + c);\n  }\n  clear() {\n    this.$items.length = 0;\n    this.count = 0;\n    this.$model.modelReset();\n  }\n  get(index) {\n    return this.$items[index];\n  }\n  insert(index, dict) {\n    this.$items.splice(index, 0, dict);\n    this.$itemsChanged(this.$items);\n    this.$model.rowsInserted(index, index + 1);\n  }\n  move(from, to, n) {\n    const vals = this.$items.splice(from, n);\n    for (let i = 0; i < vals.length; i++) {\n      this.$items.splice(to + i, 0, vals[i]);\n    }\n    this.$model.rowsMoved(from, from + n, to);\n  }\n  remove(index) {\n    this.$items.splice(index, 1);\n    this.$model.rowsRemoved(index, index + 1);\n    this.count = this.$items.length;\n  }\n  set(index, dict) {\n    this.$items[index] = dict;\n    this.$model.dataChanged(index, index);\n  }\n  setProperty(index, property, value) {\n    this.$items[index][property] = value;\n    this.$model.dataChanged(index, index);\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"ListView\",\n  versions: /.*/,\n  baseClass: \"Repeater\",\n  properties: {\n    orientation: \"enum\",\n    spacing: \"real\"\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n    this.modelChanged.connect(this, this.$styleChanged);\n    this.delegateChanged.connect(this, this.$styleChanged);\n    this.orientationChanged.connect(this, this.$styleChanged);\n    this.spacingChanged.connect(this, this.$styleChanged);\n    this._childrenInserted.connect(this, this.$applyStyleOnItem);\n  }\n  container() {\n    return this;\n  }\n  $applyStyleOnItem($item) {\n    const Qt = QmlWeb.Qt;\n    $item.dom.style.position = \"initial\";\n    if (this.orientation === Qt.Horizontal) {\n      $item.dom.style.display = \"inline-block\";\n      if ($item !== this.$items[0]) {\n        $item.dom.style[\"margin-left\"] = `${this.spacing}px`;\n      }\n    } else {\n      $item.dom.style.display = \"block\";\n      if ($item !== this.$items[0]) {\n        $item.dom.style[\"margin-top\"] = `${this.spacing}px`;\n      }\n    }\n  }\n  $styleChanged() {\n    for (let i = 0; i < this.$items.length; ++i) {\n      this.$applyStyleOnItem(this.$items[i]);\n    }\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Loader\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    active: { type: \"bool\", initialValue: true },\n    asynchronous: \"bool\",\n    item: \"var\",\n    progress: \"real\",\n    source: \"url\",\n    sourceComponent: \"Component\",\n    status: { type: \"enum\", initialValue: 1 }\n  },\n  signals: {\n    loaded: []\n  },\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.$sourceUrl = \"\";\n\n    this.activeChanged.connect(this, this.$onActiveChanged);\n    this.sourceChanged.connect(this, this.$onSourceChanged);\n    this.sourceComponentChanged.connect(this, this.$onSourceComponentChanged);\n    this.widthChanged.connect(this, this.$updateGeometry);\n    this.heightChanged.connect(this, this.$updateGeometry);\n  }\n  $onActiveChanged() {\n    if (!this.active) {\n      this.$unload();\n      return;\n    }\n    if (this.source) {\n      this.$onSourceChanged(this.source);\n    } else if (this.sourceComponent) {\n      this.$onSourceComponentChanged(this.sourceComponent);\n    }\n  }\n  $onSourceChanged(fileName) {\n    // TODO\n    // if (fileName == this.$sourceUrl && this.item !== undefined) return;\n    if (!this.active) return;\n    this.$unload();\n\n    if (!fileName) {\n      this.sourceComponent = null;\n      this.$sourceUrl = fileName;\n      return;\n    }\n\n    const tree = QmlWeb.engine.loadComponent(fileName);\n    const QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\n    const meta = { object: tree, context: this, parent: this };\n    const qmlComponent = new QMLComponent(meta);\n    qmlComponent.$basePath = QmlWeb.engine.extractBasePath(tree.$file);\n    qmlComponent.$imports = tree.$imports;\n    qmlComponent.$file = tree.$file;\n    QmlWeb.engine.loadImports(tree.$imports, qmlComponent.$basePath,\n      qmlComponent.importContextId);\n    const loadedComponent = this.$createComponentObject(qmlComponent, this);\n    this.sourceComponent = loadedComponent;\n    this.$sourceUrl = fileName;\n  }\n  $onSourceComponentChanged(newItem) {\n    if (!this.active) return;\n    this.$unload();\n\n    if (!newItem) {\n      this.item = null;\n      return;\n    }\n\n    const QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\n    let qmlComponent = newItem;\n    if (newItem instanceof QMLComponent) {\n      qmlComponent = newItem.$createObject(this, {}, this);\n    }\n    qmlComponent.parent = this;\n    this.item = qmlComponent;\n    this.$updateGeometry();\n    if (this.item) {\n      this.loaded();\n    }\n  }\n  setSource(url, options) {\n    this.$sourceUrl = url;\n    this.props = options;\n    this.source = url;\n  }\n  $unload() {\n    if (!this.item) return;\n    this.item.$delete();\n    this.item.parent = undefined;\n    this.item = undefined;\n  }\n  $callOnCompleted(child) {\n    child.Component.completed();\n    const QMLBaseObject = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"QtObject\");\n    for (let i = 0; i < child.$tidyupList.length; i++) {\n      if (child.$tidyupList[i] instanceof QMLBaseObject) {\n        this.$callOnCompleted(child.$tidyupList[i]);\n      }\n    }\n  }\n  $createComponentObject(qmlComponent, parent) {\n    const newComponent = qmlComponent.createObject(parent);\n    qmlComponent.finalizeImports();\n    if (QmlWeb.engine.operationState !== QmlWeb.QMLOperationState.Init) {\n      // We don't call those on first creation, as they will be called\n      // by the regular creation-procedures at the right time.\n      QmlWeb.engine.$initializePropertyBindings();\n      this.$callOnCompleted(newComponent);\n    }\n    return newComponent;\n  }\n  $updateGeometry() {\n    // Loader size doesn't exist\n    if (!this.width) {\n      this.width = this.item ? this.item.width : 0;\n    } else if (this.item) {\n      // Loader size exists\n      this.item.width = this.width;\n    }\n\n    if (!this.height) {\n      this.height = this.item ? this.item.height : 0;\n    } else if (this.item) {\n      // Loader size exists\n      this.item.height = this.height;\n    }\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"MouseArea\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    acceptedButtons: { type: \"variant\", initialValue: 1 }, // Qt.LeftButton\n    enabled: { type: \"bool\", initialValue: true },\n    hoverEnabled: \"bool\",\n    mouseX: \"real\",\n    mouseY: \"real\",\n    pressed: \"bool\",\n    containsMouse: \"bool\",\n    pressedButtons: { type: \"variant\", initialValue: 0 },\n    cursorShape: \"enum\" // Qt.ArrowCursor\n  },\n  signals: {\n    clicked: [{ type: \"variant\", name: \"mouse\" }],\n    entered: [],\n    exited: [],\n    positionChanged: [{ type: \"variant\", name: \"mouse\" }]\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.dom.style.pointerEvents = \"all\";\n\n    // IE does not handle mouse clicks to transparent divs, so we have\n    // to set a background color and make it invisible using opacity\n    // as that doesn't affect the mouse handling.\n    this.dom.style.backgroundColor = \"white\";\n    this.dom.style.opacity = 0;\n\n    this.cursorShapeChanged.connect(this, this.$onCursorShapeChanged);\n\n    this.dom.addEventListener(\"click\", e => this.$handleClick(e));\n    this.dom.addEventListener(\"contextmenu\", e => this.$handleClick(e));\n    const handleMouseUp = () => {\n      this.pressed = false;\n      this.pressedButtons = 0;\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n    this.dom.addEventListener(\"mousedown\", e => {\n      if (!this.enabled) return;\n      const mouse = this.$eventToMouse(e);\n      this.mouseX = mouse.x;\n      this.mouseY = mouse.y;\n      this.pressed = true;\n      this.pressedButtons = mouse.button;\n      document.addEventListener(\"mouseup\", handleMouseUp);\n    });\n    this.dom.addEventListener(\"mouseover\", () => {\n      this.containsMouse = true;\n      this.entered();\n    });\n    this.dom.addEventListener(\"mouseout\", () => {\n      this.containsMouse = false;\n      this.exited();\n    });\n    this.dom.addEventListener(\"mousemove\", e => {\n      if (!this.enabled || !this.hoverEnabled && !this.pressed) return;\n      const mouse = this.$eventToMouse(e);\n      this.mouseX = mouse.x;\n      this.mouseY = mouse.y;\n      this.positionChanged(mouse);\n    });\n  }\n  $onCursorShapeChanged() {\n    this.dom.style.cursor = this.$cursorShapeToCSS();\n  }\n  $handleClick(e) {\n    const mouse = this.$eventToMouse(e);\n    if (this.enabled && this.acceptedButtons & mouse.button) {\n      this.clicked(mouse);\n    }\n    // This decides whether to show the browser's context menu on right click or\n    // not\n    return !(this.acceptedButtons & QmlWeb.Qt.RightButton);\n  }\n  $eventToMouse(e) {\n    const Qt = QmlWeb.Qt;\n    return {\n      accepted: true,\n      button: e.button === 0 ? Qt.LeftButton :\n              e.button === 1 ? Qt.MiddleButton :\n              e.button === 2 ? Qt.RightButton :\n              0,\n      modifiers: e.ctrlKey * Qt.CtrlModifier\n               | e.altKey * Qt.AltModifier\n               | e.shiftKey * Qt.ShiftModifier\n               | e.metaKey * Qt.MetaModifier,\n      x: e.offsetX || e.layerX,\n      y: e.offsetY || e.layerY\n    };\n  }\n\n  // eslint-disable-next-line complexity\n  $cursorShapeToCSS() {\n    const Qt = QmlWeb.Qt;\n    switch (this.cursorShape) {\n      case Qt.ArrowCursor: return \"default\";\n      case Qt.UpArrowCursor: return \"n-resize\";\n      case Qt.CrossCursor: return \"crosshair\";\n      case Qt.WaitCursor: return \"wait\";\n      case Qt.IBeamCursor: return \"text\";\n      case Qt.SizeVerCursor: return \"ew-resize\";\n      case Qt.SizeHorCursor: return \"ns-resize\";\n      case Qt.SizeBDiagCursor: return \"nesw-resize\";\n      case Qt.SizeFDiagCursor: return \"nwse-resize\";\n      case Qt.SizeAllCursor: return \"all-scroll\";\n      case Qt.BlankCursor: return \"none\";\n      case Qt.SplitVCursor: return \"row-resize\";\n      case Qt.SplitHCursor: return \"col-resize\";\n      case Qt.PointingHandCursor: return \"pointer\";\n      case Qt.ForbiddenCursor: return \"not-allowed\";\n      case Qt.WhatsThisCursor: return \"help\";\n      case Qt.BusyCursor: return \"progress\";\n      case Qt.OpenHandCursor: return \"grab\";\n      case Qt.ClosedHandCursor: return \"grabbing\";\n      case Qt.DragCopyCursor: return \"copy\";\n      case Qt.DragMoveCursor: return \"move\";\n      case Qt.DragLinkCursor: return \"alias\";\n      //case Qt.BitmapCursor: return \"auto\";\n      //case Qt.CustomCursor: return \"auto\";\n    }\n    return \"auto\";\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"NumberAnimation\",\n  versions: /.*/,\n  baseClass: \"PropertyAnimation\"\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.$at = 0;\n    this.$loop = 0;\n\n    QmlWeb.engine.$addTicker((...args) => this.$ticker(...args));\n    this.runningChanged.connect(this, this.$onRunningChanged);\n  }\n  $startLoop() {\n    for (const i in this.$actions) {\n      const action = this.$actions[i];\n      action.from = action.from !== undefined ?\n                      action.from :\n                      action.target[action.property];\n    }\n    this.$at = 0;\n  }\n  $ticker(now, elapsed) {\n    if (!this.running && this.$loop !== -1 || this.paused) {\n      // $loop === -1 is a marker to just finish this run\n      return;\n    }\n    if (this.$at === 0 && this.$loop === 0 && !this.$actions.length) {\n      this.$redoActions();\n    }\n    this.$at += elapsed / this.duration;\n    if (this.$at >= 1) {\n      this.complete();\n      return;\n    }\n    for (const i in this.$actions) {\n      const action = this.$actions[i];\n      const value = action.from + (action.to - action.from) *\n                    this.easing.$valueForProgress(this.$at);\n      const property = action.target.$properties[action.property];\n      property.set(value, QmlWeb.QMLProperty.ReasonAnimation);\n    }\n  }\n  $onRunningChanged(newVal) {\n    if (newVal) {\n      this.$startLoop();\n      this.paused = false;\n    } else if (this.alwaysRunToEnd && this.$at < 1) {\n      this.$loop = -1; // -1 is used as a marker to stop\n    } else {\n      this.$loop = 0;\n      this.$actions = [];\n    }\n  }\n  complete() {\n    for (const i in this.$actions) {\n      const action = this.$actions[i];\n      const property = action.target.$properties[action.property];\n      property.set(action.to, QmlWeb.QMLProperty.ReasonAnimation);\n    }\n    this.$loop++;\n    if (this.$loop === this.loops) {\n      this.running = false;\n    } else if (!this.running) {\n      this.$actions = [];\n    } else {\n      this.$startLoop(this);\n    }\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"ParallelAnimation\",\n  versions: /.*/,\n  baseClass: \"Animation\",\n  enums: {\n    Animation: { Infinite: Math.Infinite }\n  },\n  properties: {\n    animations: \"list\"\n  },\n  defaultProperty: \"animations\"\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.$runningAnimations = 0;\n\n    this.animationsChanged.connect(this, this.$onAnimationsChanged);\n\n    QmlWeb.engine.$registerStart(() => {\n      if (!this.running) return;\n      self.running = false; // toggled back by start();\n      self.start();\n    });\n    QmlWeb.engine.$registerStop(() => this.stop());\n  }\n  $onAnimationsChanged() {\n    const flags = QmlWeb.Signal.UniqueConnection;\n    for (let i = 0; i < this.animations.length; i++) {\n      const animation = this.animations[i];\n      animation.runningChanged.connect(this, this.$animationFinished, flags);\n    }\n  }\n  $animationFinished(newVal) {\n    this.$runningAnimations += newVal ? 1 : -1;\n    if (this.$runningAnimations === 0) {\n      this.running = false;\n    }\n  }\n  start() {\n    if (this.running) return;\n    this.running = true;\n    for (let i = 0; i < this.animations.length; i++) {\n      this.animations[i].start();\n    }\n  }\n  stop() {\n    if (!this.running) return;\n    for (let i = 0; i < this.animations.length; i++) {\n      this.animations[i].stop();\n    }\n    this.running = false;\n  }\n  complete() {\n    this.stop();\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Positioner\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    spacing: \"int\"\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.childrenChanged.connect(this, this.$onChildrenChanged);\n    this.spacingChanged.connect(this, this.layoutChildren);\n    this.childrenChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n  }\n  $onChildrenChanged() {\n    const flags = QmlWeb.Signal.UniqueConnection;\n    for (let i = 0; i < this.children.length; i++) {\n      const child = this.children[i];\n      child.widthChanged.connect(this, this.layoutChildren, flags);\n      child.heightChanged.connect(this, this.layoutChildren, flags);\n      child.visibleChanged.connect(this, this.layoutChildren, flags);\n    }\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"PropertyAnimation\",\n  versions: /.*/,\n  baseClass: \"Animation\",\n  properties: {\n    duration: { type: \"int\", initialValue: 250 },\n    from: \"real\",\n    to: \"real\",\n    properties: \"string\",\n    property: \"string\",\n    target: \"QtObject\",\n    targets: \"list\"\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    const createProperty = QmlWeb.createProperty;\n    this.easing = new QmlWeb.QObject(this);\n    createProperty(\"enum\", this.easing, \"type\",\n      { initialValue: this.Easing.Linear });\n    createProperty(\"real\", this.easing, \"amplitude\", { initialValue: 1 });\n    createProperty(\"real\", this.easing, \"overshoot\", { initialValue: 1.70158 });\n    createProperty(\"real\", this.easing, \"period\", { initialValue: 0.3 });\n\n    this.easing.$valueForProgress = function(t) {\n      return QmlWeb.$ease(\n        this.type, this.period, this.amplitude, this.overshoot, t\n      );\n    };\n\n    this.$props = [];\n    this.$targets = [];\n    this.$actions = [];\n\n    this.targetChanged.connect(this, this.$redoTargets);\n    this.targetsChanged.connect(this, this.$redoTargets);\n    this.propertyChanged.connect(this, this.$redoProperties);\n    this.propertiesChanged.connect(this, this.$redoProperties);\n\n    if (meta.object.$on !== undefined) {\n      this.property = meta.object.$on;\n      this.target = this.$parent;\n    }\n  }\n  $redoActions() {\n    this.$actions = [];\n    for (let i = 0; i < this.$targets.length; i++) {\n      for (const j in this.$props) {\n        this.$actions.push({\n          target: this.$targets[i],\n          property: this.$props[j],\n          from: this.from,\n          to: this.to\n        });\n      }\n    }\n  }\n  $redoProperties() {\n    this.$props = this.properties.split(\",\");\n\n    // Remove whitespaces\n    for (let i = 0; i < this.$props.length; i++) {\n      const matches = this.$props[i].match(/\\w+/);\n      if (matches) {\n        this.$props[i] = matches[0];\n      } else {\n        this.$props.splice(i, 1);\n        i--;\n      }\n    }\n    // Merge properties and property\n    if (this.property && this.$props.indexOf(this.property) === -1) {\n      this.$props.push(this.property);\n    }\n  }\n  $redoTargets() {\n    this.$targets = this.targets.slice();\n    if (this.target && this.$targets.indexOf(this.target) === -1) {\n      this.$targets.push(this.target);\n    }\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"PropertyChanges\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    target: \"QtObject\",\n    explicit: \"bool\",\n    restoreEntryValues: { type: \"bool\", initialValue: true }\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.$actions = [];\n  }\n  $setCustomData(property, value) {\n    this.$actions.push({ property, value });\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Rectangle\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    color: { type: \"color\", initialValue: \"white\" },\n    radius: \"real\"\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    const createProperty = QmlWeb.createProperty;\n    this.border = new QmlWeb.QObject(this);\n    createProperty(\"color\", this.border, \"color\", { initialValue: \"black\" });\n    createProperty(\"int\", this.border, \"width\", { initialValue: 1 });\n    this.$borderActive = false;\n\n    const bg = this.impl = document.createElement(\"div\");\n    bg.style.pointerEvents = \"none\";\n    bg.style.position = \"absolute\";\n    bg.style.left = bg.style.right = bg.style.top = bg.style.bottom = \"0px\";\n    bg.style.borderWidth = \"0px\";\n    bg.style.borderStyle = \"solid\";\n    bg.style.borderColor = \"black\";\n    bg.style.backgroundColor = \"white\";\n    this.dom.appendChild(bg);\n\n    this.colorChanged.connect(this, this.$onColorChanged);\n    this.radiusChanged.connect(this, this.$onRadiusChanged);\n    this.border.colorChanged.connect(this, this.border$onColorChanged);\n    this.border.widthChanged.connect(this, this.border$onWidthChanged);\n    this.widthChanged.connect(this, this.$updateBorder);\n    this.heightChanged.connect(this, this.$updateBorder);\n  }\n  $onColorChanged(newVal) {\n    this.impl.style.backgroundColor = new QmlWeb.QColor(newVal);\n  }\n  border$onColorChanged(newVal) {\n    this.$borderActive = true;\n    this.impl.style.borderColor = new QmlWeb.QColor(newVal);\n    this.$updateBorder();\n  }\n  border$onWidthChanged() {\n    this.$borderActive = true;\n    this.$updateBorder();\n  }\n  $onRadiusChanged(newVal) {\n    this.impl.style.borderRadius = `${newVal}px`;\n  }\n  $updateBorder() {\n    const border = this.$borderActive ? Math.max(0, this.border.width) : 0;\n    const style = this.impl.style;\n    if (border * 2 > this.width || border * 2 > this.height) {\n      // Border is covering the whole background\n      style.borderWidth = \"0px\";\n      style.borderTopWidth = `${this.height}px`;\n    } else {\n      style.borderWidth = `${border}px`;\n    }\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"RegExpValidator\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    regExp: \"var\"\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n  }\n  validate(string) {\n    if (!this.regExp) return true;\n    return this.regExp.test(string);\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Repeater\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    delegate: \"Component\",\n    model: { type: \"variant\", initialValue: 0 },\n    count: \"int\"\n  },\n  signals: {\n    _childrenInserted: []\n  },\n  defaultProperty: \"delegate\"\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.parent = meta.parent;\n    // TODO: some (all ?) of the components including Repeater needs to know own\n    // parent at creation time. Please consider this major change.\n\n    this.$completed = false;\n    this.$items = []; // List of created items\n\n    this.modelChanged.connect(this, this.$onModelChanged);\n    this.delegateChanged.connect(this, this.$onDelegateChanged);\n    this.parentChanged.connect(this, this.$onParentChanged);\n  }\n  container() {\n    return this.parent;\n  }\n  itemAt(index) {\n    return this.$items[index];\n  }\n  $onModelChanged() {\n    this.$applyModel();\n  }\n  $onDelegateChanged() {\n    this.$applyModel();\n  }\n  $onParentChanged() {\n    this.$applyModel();\n  }\n  $getModel() {\n    const QMLListModel = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"ListModel\");\n    return this.model instanceof QMLListModel ?\n            this.model.$model :\n            this.model;\n  }\n  $applyModel() {\n    if (!this.delegate || !this.parent) {\n      return;\n    }\n    const model = this.$getModel();\n    if (model instanceof QmlWeb.JSItemModel) {\n      const flags = QmlWeb.Signal.UniqueConnection;\n      model.dataChanged.connect(this, this.$_onModelDataChanged, flags);\n      model.rowsInserted.connect(this, this.$_onRowsInserted, flags);\n      model.rowsMoved.connect(this, this.$_onRowsMoved, flags);\n      model.rowsRemoved.connect(this, this.$_onRowsRemoved, flags);\n      model.modelReset.connect(this, this.$_onModelReset, flags);\n\n      this.$removeChildren(0, this.$items.length);\n      this.$insertChildren(0, model.rowCount());\n    } else if (typeof model === \"number\") {\n      if (this.$items.length > model) {\n        // have more than we need\n        this.$removeChildren(model, this.$items.length);\n      } else {\n        // need more\n        this.$insertChildren(this.$items.length, model);\n      }\n    } else if (model instanceof Array) {\n      this.$removeChildren(0, this.$items.length);\n      this.$insertChildren(0, model.length);\n    }\n    this.count = this.$items.length;\n  }\n  $callOnCompleted(child) {\n    child.Component.completed();\n    const QMLBaseObject = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"QtObject\");\n    for (let i = 0; i < child.$tidyupList.length; i++) {\n      if (child.$tidyupList[i] instanceof QMLBaseObject) {\n        this.$callOnCompleted(child.$tidyupList[i]);\n      }\n    }\n  }\n  $_onModelDataChanged(startIndex, endIndex, roles) {\n    const model = this.$getModel();\n    const roleNames = roles || model.roleNames;\n    for (let index = startIndex; index <= endIndex; index++) {\n      const item = this.$items[index];\n      for (const i in roleNames) {\n        item.$properties[roleNames[i]].set(\n          model.data(index, roleNames[i]),\n          QmlWeb.QMLProperty.ReasonInit,\n          item,\n          this.model.$context\n        );\n      }\n    }\n  }\n  $_onRowsInserted(startIndex, endIndex) {\n    this.$insertChildren(startIndex, endIndex);\n    this.count = this.$items.length;\n  }\n  $_onRowsMoved(sourceStartIndex, sourceEndIndex, destinationIndex) {\n    const vals = this.$items.splice(\n      sourceStartIndex,\n      sourceEndIndex - sourceStartIndex\n    );\n    for (let i = 0; i < vals.length; i++) {\n      this.$items.splice(destinationIndex + i, 0, vals[i]);\n    }\n    const smallestChangedIndex = sourceStartIndex < destinationIndex ?\n                                  sourceStartIndex :\n                                  destinationIndex;\n    for (let i = smallestChangedIndex; i < this.$items.length; i++) {\n      this.$items[i].index = i;\n    }\n  }\n  $_onRowsRemoved(startIndex, endIndex) {\n    this.$removeChildren(startIndex, endIndex);\n    for (let i = startIndex; i < this.$items.length; i++) {\n      this.$items[i].index = i;\n    }\n    this.count = this.$items.length;\n  }\n  $_onModelReset() {\n    this.$applyModel();\n  }\n  $insertChildren(startIndex, endIndex) {\n    if (endIndex <= 0) {\n      this.count = 0;\n      return;\n    }\n\n    const QMLOperationState = QmlWeb.QMLOperationState;\n    const createProperty = QmlWeb.createProperty;\n    const model = this.$getModel();\n    let index;\n    for (index = startIndex; index < endIndex; index++) {\n      const newItem = this.delegate.$createObject(this.parent);\n      createProperty(\"int\", newItem, \"index\", { initialValue: index });\n\n      // To properly import JavaScript in the context of a component\n      this.delegate.finalizeImports();\n\n      if (typeof model === \"number\" || model instanceof Array) {\n        if (typeof newItem.$properties.modelData === \"undefined\") {\n          createProperty(\"variant\", newItem, \"modelData\");\n        }\n        const value = model instanceof Array ?\n                      model[index] :\n                      typeof model === \"number\" ? index : \"undefined\";\n        newItem.$properties.modelData.set(value, QmlWeb.QMLProperty.ReasonInit,\n          newItem, model.$context);\n      } else {\n        for (let i = 0; i < model.roleNames.length; i++) {\n          const roleName = model.roleNames[i];\n          if (typeof newItem.$properties[roleName] === \"undefined\") {\n            createProperty(\"variant\", newItem, roleName);\n          }\n          newItem.$properties[roleName].set(\n            model.data(index, roleName), QmlWeb.QMLProperty.ReasonInit,\n            newItem, this.model.$context\n          );\n        }\n      }\n\n      this.$items.splice(index, 0, newItem);\n\n      // parent must be set after the roles have been added to newItem scope in\n      // case we are outside of QMLOperationState.Init and parentChanged has\n      // any side effects that result in those roleNames being referenced.\n      newItem.parent = this.parent;\n\n      // TODO debug this. Without check to Init, Completed sometimes called\n      // twice.. But is this check correct?\n      if (QmlWeb.engine.operationState !== QMLOperationState.Init &&\n          QmlWeb.engine.operationState !== QMLOperationState.Idle) {\n        // We don't call those on first creation, as they will be called\n        // by the regular creation-procedures at the right time.\n        this.$callOnCompleted(newItem);\n      }\n    }\n    if (QmlWeb.engine.operationState !== QMLOperationState.Init) {\n      // We don't call those on first creation, as they will be called\n      // by the regular creation-procedures at the right time.\n      QmlWeb.engine.$initializePropertyBindings();\n    }\n\n    if (index > 0) {\n      this.container().childrenChanged();\n    }\n\n    for (let i = endIndex; i < this.$items.length; i++) {\n      this.$items[i].index = i;\n    }\n  }\n  $removeChildren(startIndex, endIndex) {\n    const removed = this.$items.splice(startIndex, endIndex - startIndex);\n    for (const index in removed) {\n      removed[index].$delete();\n      this.$removeChildProperties(removed[index]);\n    }\n  }\n  $removeChildProperties(child) {\n    const signals = QmlWeb.engine.completedSignals;\n    signals.splice(signals.indexOf(child.Component.completed), 1);\n    for (let i = 0; i < child.children.length; i++) {\n      this.$removeChildProperties(child.children[i]);\n    }\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Rotation\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    angle: \"real\"\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    const createProperty = QmlWeb.createProperty;\n\n    this.axis = new QmlWeb.QObject(this);\n    createProperty(\"real\", this.axis, \"x\");\n    createProperty(\"real\", this.axis, \"y\");\n    createProperty(\"real\", this.axis, \"z\", { initialValue: 1 });\n\n    this.origin = new QmlWeb.QObject(this);\n    createProperty(\"real\", this.origin, \"x\");\n    createProperty(\"real\", this.origin, \"y\");\n\n    this.angleChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.axis.xChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.axis.yChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.axis.zChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.origin.xChanged.connect(this, this.$updateOrigin);\n    this.origin.yChanged.connect(this, this.$updateOrigin);\n    this.$parent.$updateTransform();\n  }\n  $updateOrigin() {\n    const style = this.$parent.dom.style;\n    style.transformOrigin = `${this.origin.x}px ${this.origin.y}px`;\n    style.webkitTransformOrigin = `${this.origin.x}px ${this.origin.y}px`;\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Row\",\n  versions: /.*/,\n  baseClass: \"Positioner\",\n  properties: {\n    layoutDirection: \"enum\"\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n  }\n  layoutChildren() {\n    let curPos = 0;\n    let maxHeight = 0;\n    // When layoutDirection is RightToLeft we need oposite order\n    let i = this.layoutDirection === 1 ? this.children.length - 1 : 0;\n    const endPoint = this.layoutDirection === 1 ? -1 : this.children.length;\n    const step = this.layoutDirection === 1 ? -1 : 1;\n    for (; i !== endPoint; i += step) {\n      const child = this.children[i];\n      if (!(child.visible && child.width && child.height)) {\n        continue;\n      }\n      maxHeight = child.height > maxHeight ? child.height : maxHeight;\n\n      child.x = curPos;\n      curPos += child.width + this.spacing;\n    }\n    this.implicitHeight = maxHeight;\n    // We want no spacing at the right side\n    this.implicitWidth = curPos - this.spacing;\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Scale\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    xScale: \"real\",\n    yScale: \"real\"\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    const createProperty = QmlWeb.createProperty;\n    this.origin = new QmlWeb.QObject(this);\n    createProperty(\"real\", this.origin, \"x\");\n    createProperty(\"real\", this.origin, \"y\");\n\n    this.xScaleChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.yScaleChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.origin.xChanged.connect(this, this.$updateOrigin);\n    this.origin.yChanged.connect(this, this.$updateOrigin);\n\n    /* QML default origin is top-left, while CSS default origin is centre, so\n     * $updateOrigin must be called to set the initial transformOrigin. */\n    this.$updateOrigin();\n  }\n  $updateOrigin() {\n    const style = this.$parent.dom.style;\n    style.transformOrigin = `${this.origin.x}px ${this.origin.y}px`;\n    style.webkitTransformOrigin = `${this.origin.x}px ${this.origin.y}px`;\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"SequentialAnimation\",\n  versions: /.*/,\n  baseClass: \"Animation\",\n  properties: {\n    animations: \"list\"\n  },\n  defaultProperty: \"animations\"\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.animationsChanged.connect(this, this.$onAnimatonsChanged);\n\n    QmlWeb.engine.$registerStart(() => {\n      if (!this.running) return;\n      this.running = false; // toggled back by start();\n      this.start();\n    });\n    QmlWeb.engine.$registerStop(() => self.stop());\n  }\n  $onAnimatonsChanged() {\n    const flags = QmlWeb.Signal.UniqueConnection;\n    for (let i = 0; i < this.animations.length; i++) {\n      const animation = this.animations[i];\n      animation.runningChanged.connect(this, this.$nextAnimation, flags);\n    }\n  }\n  $nextAnimation(proceed) {\n    if (this.running && !proceed) {\n      this.$curIndex++;\n      if (this.$curIndex < this.animations.length) {\n        const anim = this.animations[this.$curIndex];\n        console.log(\"nextAnimation\", this, this.$curIndex, anim);\n        anim.start();\n      } else {\n        this.$passedLoops++;\n        if (this.$passedLoops >= this.loops) {\n          this.complete();\n        } else {\n          this.$curIndex = -1;\n          this.$nextAnimation();\n        }\n      }\n    }\n  }\n  start() {\n    if (this.running) return;\n    this.running = true;\n    this.$curIndex = -1;\n    this.$passedLoops = 0;\n    this.$nextAnimation();\n  }\n  stop() {\n    if (!this.running) return;\n    this.running = false;\n    if (this.$curIndex < this.animations.length) {\n      this.animations[this.$curIndex].stop();\n    }\n  }\n  complete() {\n    if (!this.running) return;\n    if (this.$curIndex < this.animations.length) {\n      // Stop current animation\n      this.animations[this.$curIndex].stop();\n    }\n    this.running = false;\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"State\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    name: \"string\",\n    changes: \"list\",\n    extend: \"string\",\n    when: \"bool\"\n  },\n  defaultProperty: \"changes\"\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.$item = this.$parent;\n\n    this.whenChanged.connect(this, this.$onWhenChanged);\n  }\n  $getAllChanges() {\n    if (this.extend) {\n      /* ECMAScript 2015. TODO: polyfill Array?\n      const base = this.$item.states.find(state => state.name === this.extend);\n      */\n      const states = this.$item.states;\n      const base = states.filter(state => state.name === this.extend)[0];\n      if (base) {\n        return base.$getAllChanges().concat(this.changes);\n      }\n      console.error(\"Can't find the state to extend!\");\n    }\n    return this.changes;\n  }\n  $onWhenChanged(newVal) {\n    if (newVal) {\n      this.$item.state = this.name;\n    } else if (this.$item.state === this.name) {\n      this.$item.state = \"\";\n    }\n  }\n});\n","const platformsDetectors = [\n  //{ name: \"W8\", regexp: /Windows NT 6\\.2/ },\n  //{ name: \"W7\", regexp: /Windows NT 6\\.1/ },\n  //{ name: \"Windows\", regexp: /Windows NT/ },\n  { name: \"OSX\", regexp: /Macintosh/ }\n];\n\nconst systemPalettes = {};\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"SystemPalette\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    SystemPalette: {\n      Active: \"active\", Inactive: \"inactive\", Disabled: \"disabled\"\n    }\n  },\n  properties: {\n    alternateBase: { type: \"color\", readOnly: true },\n    base: { type: \"color\", readOnly: true },\n    button: { type: \"color\", readOnly: true },\n    buttonText: { type: \"color\", readOnly: true },\n    dark: { type: \"color\", readOnly: true },\n    highlight: { type: \"color\", readOnly: true },\n    highlightedText: { type: \"color\", readOnly: true },\n    light: { type: \"color\", readOnly: true },\n    mid: { type: \"color\", readOnly: true },\n    midlight: { type: \"color\", readOnly: true },\n    shadow: { type: \"color\", readOnly: true },\n    text: { type: \"color\", readOnly: true },\n    window: { type: \"color\", readOnly: true },\n    windowText: { type: \"color\", readOnly: true },\n\n    colorGroup: \"enum\"\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.colorGroupChanged.connect(this, this.$onColorGroupChanged);\n\n    this.$platform = \"OSX\";\n    // Detect OS\n    for (let i = 0; i < platformsDetectors.length; ++i) {\n      if (platformsDetectors[i].regexp.test(navigator.userAgent)) {\n        this.$platform = platformsDetectors[i].name;\n        break;\n      }\n    }\n  }\n  $onColorGroupChanged(newVal) {\n    const pallete = systemPalettes[this.$platform][newVal];\n    this.$canEditReadOnlyProperties = true;\n    Object.keys(pallete).forEach(key => {\n      this[key] = pallete[key];\n    });\n    delete this.$canEditReadOnlyProperties;\n  }\n});\n\nsystemPalettes.OSX = {\n  active: {\n    alternateBase: \"#f6f6f6\",\n    base: \"#ffffff\",\n    button: \"#ededed\",\n    buttonText: \"#000000\",\n    dark: \"#bfbfbf\",\n    highlight: \"#fbed73\",\n    highlightText: \"#000000\",\n    light: \"#ffffff\",\n    mid: \"#a9a9a9\",\n    midlight: \"#f6f6f6\",\n    shadow: \"#8b8b8b\",\n    text: \"#000000\",\n    window: \"#ededed\",\n    windowText: \"#000000\"\n  },\n  inactive: {\n    alternateBase: \"#f6f6f6\",\n    base: \"#ffffff\",\n    button: \"#ededed\",\n    buttonText: \"#000000\",\n    dark: \"#bfbfbf\",\n    highlight: \"#d0d0d0\",\n    highlightText: \"#000000\",\n    light: \"#ffffff\",\n    mid: \"#a9a9a9\",\n    midlight: \"#f6f6f6\",\n    shadow: \"#8b8b8b\",\n    text: \"#000000\",\n    window: \"#ededed\",\n    windowText: \"#000000\"\n  },\n  disabled: {\n    alternateBase: \"#f6f6f6\",\n    base: \"#ededed\",\n    button: \"#ededed\",\n    buttonText: \"#949494\",\n    dark: \"#bfbfbf\",\n    highlight: \"#d0d0d0\",\n    highlightText: \"#7f7f7f\",\n    light: \"#ffffff\",\n    mid: \"#a9a9a9\",\n    midlight: \"#f6f6f6\",\n    shadow: \"#8b8b8b\",\n    text: \"#7f7f7f\",\n    window: \"#ededed\",\n    windowText: \"#7f7f7f\"\n  }\n};\n\nQmlWeb.systemPalettes = systemPalettes;\nQmlWeb.platformsDetectors = platformsDetectors;\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Text\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    Text: {\n      NoWrap: 0, WordWrap: 1, WrapAnywhere: 2, Wrap: 3,\n      WrapAtWordBoundaryOrAnywhere: 4,\n      AlignLeft: 1, AlignRight: 2, AlignHCenter: 4, AlignJustify: 8,\n      AlignTop: 32, AlignBottom: 64, AlignVCenter: 128,\n      Normal: 0, Outline: 1, Raised: 2, Sunken: 3\n    }\n  },\n  properties: {\n    color: { type: \"color\", initialValue: \"black\" },\n    text: \"string\",\n    lineHeight: \"real\",\n    wrapMode: { type: \"enum\", initialValue: 0 }, // Text.NoWrap\n    horizontalAlignment: { type: \"enum\", initialValue: 1 }, // Text.AlignLeft\n    style: \"enum\",\n    styleColor: \"color\"\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    const fc = this.impl = document.createElement(\"span\");\n    fc.style.pointerEvents = \"none\";\n    fc.style.width = \"100%\";\n    fc.style.height = \"100%\";\n    fc.style.whiteSpace = \"pre\";\n    this.dom.style.textAlign = \"left\";\n    this.dom.appendChild(fc);\n\n    const QMLFont = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Font\");\n    this.font = new QMLFont(this);\n\n    this.colorChanged.connect(this, this.$onColorChanged);\n    this.textChanged.connect(this, this.$onTextChanged);\n    this.lineHeightChanged.connect(this, this.$onLineHeightChanged);\n    this.wrapModeChanged.connect(this, this.$onWrapModeChanged);\n    this.horizontalAlignmentChanged.connect(this,\n                                            this.$onHorizontalAlignmentChanged);\n    this.styleChanged.connect(this, this.$onStyleChanged);\n    this.styleColorChanged.connect(this, this.$onStyleColorChanged);\n\n    this.font.family = \"sans-serif\";\n    this.font.pointSize = 10;\n\n    this.widthChanged.connect(this, this.$onWidthChanged);\n\n    this.font.boldChanged.connect(this, this.$onFontChanged);\n    this.font.weightChanged.connect(this, this.$onFontChanged);\n    this.font.pixelSizeChanged.connect(this, this.$onFontChanged);\n    this.font.pointSizeChanged.connect(this, this.$onFontChanged);\n    this.font.familyChanged.connect(this, this.$onFontChanged);\n    this.font.letterSpacingChanged.connect(this, this.$onFontChanged);\n    this.font.wordSpacingChanged.connect(this, this.$onFontChanged);\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n  }\n  $onColorChanged(newVal) {\n    this.impl.style.color = new QmlWeb.QColor(newVal);\n  }\n  $onTextChanged(newVal) {\n    this.impl.innerHTML = newVal;\n    this.$updateImplicit();\n  }\n  $onWidthChanged() {\n    this.$updateImplicit();\n  }\n  $onLineHeightChanged(newVal) {\n    this.impl.style.lineHeight = `${newVal}px`;\n    this.$updateImplicit();\n  }\n  $onStyleChanged(newVal) {\n    this.$updateShadow(newVal, this.styleColor);\n  }\n  $onStyleColorChanged(newVal) {\n    this.$updateShadow(this.style, new QmlWeb.QColor(newVal));\n  }\n  $onWrapModeChanged(newVal) {\n    const style = this.impl.style;\n    switch (newVal) {\n      case this.Text.NoWrap:\n        style.whiteSpace = \"pre\";\n        break;\n      case this.Text.WordWrap:\n        style.whiteSpace = \"pre-wrap\";\n        style.wordWrap = \"normal\";\n        break;\n      case this.Text.WrapAnywhere:\n        style.whiteSpace = \"pre-wrap\";\n        style.wordBreak = \"break-all\";\n        break;\n      case this.Text.Wrap:\n      case this.Text.WrapAtWordBoundaryOrAnywhere:\n        style.whiteSpace = \"pre-wrap\";\n        style.wordWrap = \"break-word\";\n    }\n    this.$updateJustifyWhiteSpace();\n  }\n  $onHorizontalAlignmentChanged(newVal) {\n    let textAlign = null;\n    switch (newVal) {\n      case this.Text.AlignLeft:\n        textAlign = \"left\";\n        break;\n      case this.Text.AlignRight:\n        textAlign = \"right\";\n        break;\n      case this.Text.AlignHCenter:\n        textAlign = \"center\";\n        break;\n      case this.Text.AlignJustify:\n        textAlign = \"justify\";\n        break;\n    }\n    this.dom.style.textAlign = textAlign;\n    this.$updateJustifyWhiteSpace();\n  }\n  $onFontChanged() {\n    this.$updateImplicit();\n  }\n  Component$onCompleted() {\n    this.$updateImplicit();\n  }\n  $updateImplicit() {\n    if (!this.text || !this.dom) {\n      this.implicitHeight = this.implicitWidth = 0;\n      return;\n    }\n    const fc = this.impl;\n    // Need to move the child out of it's parent so that it can properly\n    // recalculate it's \"natural\" offsetWidth/offsetHeight\n    if (this.$isUsingImplicitWidth) {\n      document.body.appendChild(fc);\n    }\n    const height = fc.offsetHeight;\n    const width = fc.offsetWidth;\n    if (this.$isUsingImplicitWidth) {\n      this.dom.appendChild(fc);\n    }\n\n    this.implicitHeight = height;\n    this.implicitWidth = width;\n  }\n  $updateShadow(textStyle, styleColor) {\n    const style = this.impl.style;\n    switch (textStyle) {\n      case 0:\n        style.textShadow = \"none\";\n        break;\n      case 1:\n        style.textShadow = [\n          `1px 0 0 ${styleColor}`,\n          `-1px 0 0 ${styleColor}`,\n          `0 1px 0 ${styleColor}`,\n          `0 -1px 0 ${styleColor}`\n        ].join(\",\");\n        break;\n      case 2:\n        style.textShadow = `1px 1px 0 ${styleColor}`;\n        break;\n      case 3:\n        style.textShadow = `-1px -1px 0 ${styleColor}`;\n        break;\n    }\n  }\n  $updateJustifyWhiteSpace() {\n    const style = this.impl.style;\n    // AlignJustify doesn't work with pre/pre-wrap, so we decide the lesser of\n    // the two evils to be ignoring \"\\n\"s inside the text.\n    if (this.horizontalAlignment === this.Text.AlignJustify) {\n      style.whiteSpace = \"normal\";\n    }\n    this.$updateImplicit();\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"TextEdit\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    activeFocusOnPress: { type: \"bool\", initialValue: true },\n    baseUrl: \"url\",\n    canPaste: \"bool\",\n    canRedo: \"bool\",\n    canUndo: \"bool\",\n    color: { type: \"color\", initialValue: \"white\" },\n    contentHeight: \"real\",\n    contentWidth: \"real\",\n    cursorDelegate: \"Component\",\n    cursorPosition: \"int\",\n    cursorRectangle: \"rectangle\",\n    cursorVisible: { type: \"bool\", initialValue: true },\n    effectiveHorizontalAlignment: \"enum\",\n    horizontalAlignment: \"enum\",\n    hoveredLink: \"string\",\n    inputMethodComposing: \"bool\",\n    inputMethodHints: \"enum\",\n    length: \"int\",\n    lineCount: \"int\",\n    mouseSelectionMode: \"enum\",\n    persistentSelection: \"bool\",\n    readOnly: \"bool\",\n    renderType: \"enum\",\n    selectByKeyboard: { type: \"bool\", initialValue: true },\n    selectByMouse: \"bool\",\n    selectedText: \"string\",\n    selectedTextColor: { type: \"color\", initialValue: \"yellow\" },\n    selectionColor: { type: \"color\", initialValue: \"pink\" },\n    selectionEnd: \"int\",\n    selectionStart: \"int\",\n    text: \"string\",\n    textDocument: \"TextDocument\",\n    textFormat: \"enum\",\n    textMargin: \"real\",\n    verticalAlignment: \"enum\",\n    wrapMode: \"enum\"\n  },\n  signals: {\n    linkActivated: [{ type: \"string\", name: \"link\" }],\n    linkHovered: [{ type: \"string\", name: \"link\" }]\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    const QMLFont = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Font\");\n    this.font = new QMLFont(this);\n\n    // Undo / Redo stacks;\n    this.undoStack = [];\n    this.undoStackPosition = -1;\n    this.redoStack = [];\n    this.redoStackPosition = -1;\n\n    const textarea = this.impl = document.createElement(\"textarea\");\n    textarea.style.pointerEvents = \"auto\";\n    textarea.style.width = \"100%\";\n    textarea.style.height = \"100%\";\n    textarea.style.boxSizing = \"border-box\";\n    textarea.style.borderWidth = \"0\";\n    textarea.style.background = \"none\";\n    textarea.style.outline = \"none\";\n    textarea.style.resize = \"none\";\n    textarea.style.padding = \"0\"; // TODO: padding/*Padding props from Qt 5.6\n    // In some browsers text-areas have a margin by default, which distorts\n    // the positioning, so we need to manually set it to 0.\n    textarea.style.margin = \"0\";\n    textarea.disabled = false;\n    this.dom.appendChild(textarea);\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n    this.textChanged.connect(this, this.$onTextChanged);\n    this.colorChanged.connect(this, this.$onColorChanged);\n\n    this.impl.addEventListener(\"input\", () => this.$updateValue());\n  }\n  append(text) {\n    this.text += text;\n  }\n  copy() {\n    // TODO\n  }\n  cut() {\n    this.text = this.text(0, this.selectionStart) +\n                this.text(this.selectionEnd, this.text.length);\n    // TODO\n  }\n  deselect() {\n    //this.selectionStart = -1;\n    //this.selectionEnd = -1;\n    //this.selectedText = null;\n    // TODO\n  }\n  getFormattedText(start, end) {\n    const text = this.text.slice(start, end);\n    // TODO\n    // process text\n    return text;\n  }\n  getText(start, end) {\n    return this.text.slice(start, end);\n  }\n  insert(/*position, text*/) {\n    // TODO\n  }\n  isRightToLeft(/*start, end*/) {\n    // TODO\n  }\n  linkAt(/*x, y*/) {\n    // TODO\n  }\n  moveCursorSelection(/*x, y*/) {\n    // TODO\n  }\n  paste() {\n    // TODO\n  }\n  positionAt(/*x, y*/) {\n    // TODO\n  }\n  positionToRectangle(/*position*/) {\n    // TODO\n  }\n  redo() {\n    // TODO\n  }\n  remove(/*start, end*/) {\n    // TODO\n  }\n  select(/*start, end*/) {\n    // TODO\n  }\n  selectAll() {\n    // TODO\n  }\n  selectWord() {\n    // TODO\n  }\n  undo() {\n    // TODO\n  }\n  Component$onCompleted() {\n    this.selectByKeyboard = !this.readOnly;\n    this.$updateValue();\n    this.implicitWidth = this.offsetWidth;\n    this.implicitHeight = this.offsetHeight;\n  }\n  $onTextChanged(newVal) {\n    this.impl.value = newVal;\n  }\n  $onColorChanged(newVal) {\n    this.impl.style.color = newVal;\n  }\n  $updateValue() {\n    if (this.text !== this.impl.value) {\n      this.text = this.impl.value;\n    }\n    this.length = this.text.length;\n    this.lineCount = this.$getLineCount();\n    this.$updateCss();\n  }\n  // Transfer dom style to firstChild,\n  // then clear corresponding dom style\n  $updateCss() {\n    const supported = [\n      \"border\",\n      \"borderRadius\",\n      \"borderWidth\",\n      \"borderColor\",\n      \"backgroundColor\",\n    ];\n    const style = this.impl.style;\n    for (let n = 0; n < supported.length; n++) {\n      const o = supported[n];\n      const v = this.css[o];\n      if (v) {\n        style[o] = v;\n        this.css[o] = null;\n      }\n    }\n  }\n  $getLineCount() {\n    return this.text.split(/\\n/).length;\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"TextInput\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    TextInput: { Normal: 0, Password: 1, NoEcho: 2, PasswordEchoOnEdit: 3 }\n  },\n  properties: {\n    text: \"string\",\n    maximumLength: { type: \"int\", initialValue: -1 },\n    readOnly: \"bool\",\n    validator: \"var\",\n    echoMode: \"enum\" // TextInput.Normal\n  },\n  signals: {\n    accepted: []\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    const QMLFont = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Font\");\n    this.font = new QMLFont(this);\n\n    const input = this.impl = document.createElement(\"input\");\n    input.type = \"text\";\n    input.disabled = true;\n    input.style.pointerEvents = \"auto\";\n    // In some browsers text-inputs have a margin by default, which distorts\n    // the positioning, so we need to manually set it to 0.\n    input.style.margin = \"0\";\n    input.style.padding = \"0\";\n    input.style.width = \"100%\";\n    input.style.height = \"100%\";\n    this.dom.appendChild(input);\n    this.setupFocusOnDom(input);\n    input.disabled = false;\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n    this.textChanged.connect(this, this.$onTextChanged);\n    this.echoModeChanged.connect(this, this.$onEchoModeChanged);\n    this.maximumLengthChanged.connect(this, this.$onMaximumLengthChanged);\n    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);\n    this.Keys.pressed.connect(this, this.Keys$onPressed);\n\n    this.impl.addEventListener(\"input\", () => this.$updateValue());\n  }\n  Component$onCompleted() {\n    this.implicitWidth = this.impl.offsetWidth;\n    this.implicitHeight = this.impl.offsetHeight;\n  }\n  $onTextChanged(newVal) {\n    // We have to check if value actually changes.\n    // If we do not have this check, then after user updates text input\n    // following occurs: user updates gui text -> updateValue gets called ->\n    // textChanged gets called -> gui value updates again -> caret position\n    // moves to the right!\n    if (this.impl.value !== newVal) {\n      this.impl.value = newVal;\n    }\n  }\n  $onEchoModeChanged(newVal) {\n    const TextInput = this.TextInput;\n    const input = this.impl;\n    switch (newVal) {\n      case TextInput.Normal:\n        input.type = \"text\";\n        break;\n      case TextInput.Password:\n        input.type = \"password\";\n        break;\n      case TextInput.NoEcho:\n        // Not supported, use password, that's nearest\n        input.type = \"password\";\n        break;\n      case TextInput.PasswordEchoOnEdit:\n        // Not supported, use password, that's nearest\n        input.type = \"password\";\n        break;\n    }\n  }\n  $onMaximumLengthChanged(newVal) {\n    this.impl.maxLength = newVal < 0 ? null : newVal;\n  }\n  $onReadOnlyChanged(newVal) {\n    this.impl.disabled = newVal;\n  }\n  Keys$onPressed(e) {\n    const Qt = QmlWeb.Qt;\n    const submit = e.key === Qt.Key_Return || e.key === Qt.Key_Enter;\n    if (submit && this.$testValidator()) {\n      this.accepted();\n      e.accepted = true;\n    }\n  }\n  $testValidator() {\n    if (this.validator) {\n      return this.validator.validate(this.text);\n    }\n    return true;\n  }\n  $updateValue() {\n    if (this.text !== this.impl.value) {\n      this.$canEditReadOnlyProperties = true;\n      this.text = this.impl.value;\n      this.$canEditReadOnlyProperties = false;\n    }\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Transition\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    animations: \"list\",\n    from: { type: \"string\", initialValue: \"*\" },\n    to: { type: \"string\", initialValue: \"*\" },\n    reversible: \"bool\"\n  },\n  defaultProperty: \"animations\"\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.$item = this.$parent;\n  }\n  $start(actions) {\n    for (let i = 0; i < this.animations.length; i++) {\n      const animation = this.animations[i];\n      animation.$actions = [];\n      const { $targets, $props, $actions } = animation;\n      for (const j in actions) {\n        const action = actions[j];\n        if (($targets.length === 0 || $targets.indexOf(action.target) !== -1) &&\n            ($props.length === 0 || $props.indexOf(action.property) !== -1)) {\n          $actions.push(action);\n        }\n      }\n      animation.start();\n    }\n  }\n  $stop() {\n    for (let i = 0; i < this.animations.length; i++) {\n      this.animations[i].stop();\n    }\n  }\n});\n","QmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Translate\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    x: \"real\",\n    y: \"real\"\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.xChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.yChanged.connect(this.$parent, this.$parent.$updateTransform);\n  }\n});\n","// WARNING: Can have wrong behavior if url is changed while the socket is in\n// Connecting state.\n// TODO: Recheck everything.\n\nQmlWeb.registerQmlType({\n  module: \"QtWebSockets\",\n  name: \"WebSocket\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    WebSocket: { Connecting: 0, Open: 1, Closing: 2, Closed: 3, Error: 4 }\n  },\n  properties: {\n    active: \"bool\",\n    status: { type: \"enum\", initialValue: 3 }, // WebSocket.Closed\n    errorString: \"string\",\n    url: \"url\"\n  },\n  signals: {\n    textMessageReceived: [{ type: \"string\", name: \"message\" }]\n  }\n}, class {\n  constructor(meta) {\n    QmlWeb.callSuper(this, meta);\n\n    this.$socket = undefined;\n    this.$reconnect = false;\n\n    this.statusChanged.connect(this, this.$onStatusChanged);\n    this.activeChanged.connect(this, this.$reconnectSocket);\n    this.urlChanged.connect(this, this.$reconnectSocket);\n  }\n  $onStatusChanged(status) {\n    if (status !== this.WebSocket.Error) {\n      this.errorString = \"\";\n    }\n  }\n  $connectSocket() {\n    this.$reconnect = false;\n\n    if (!this.url || !this.active) {\n      return;\n    }\n\n    this.status = this.WebSocket.Connecting;\n    this.$socket = new WebSocket(this.url);\n    this.$socket.onopen = () => {\n      this.status = this.WebSocket.Open;\n    };\n    this.$socket.onclose = () => {\n      this.status = this.WebSocket.Closed;\n      if (this.$reconnect) {\n        this.$connectSocket();\n      }\n    };\n    this.$socket.onerror = error => {\n      this.errorString = error.message;\n      this.status = this.WebSocket.Error;\n    };\n    this.$socket.onmessage = message => {\n      this.textMessageReceived(message.data);\n    };\n  }\n  $reconnectSocket() {\n    this.$reconnect = true;\n    if (this.status === this.WebSocket.Open) {\n      this.status = this.WebSocket.Closing;\n      this.$socket.close();\n    } else if (this.status !== this.WebSocket.Closing) {\n      this.$connectSocket();\n    }\n  }\n  sendTextMessage(message) {\n    if (this.status === this.WebSocket.Open) {\n      this.$socket.send(message);\n    }\n  }\n});\n"]}